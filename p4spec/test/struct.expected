;; ../../../../spec-concrete/0-aux.watsup:18.1-18.21
def $sum



;; ../../../../spec-concrete/0-aux.watsup:19.1-19.21
def $max



;; ../../../../spec-concrete/0-aux.watsup:20.1-20.21
def $min



;; ../../../../spec-concrete/0-aux.watsup:26.1-27.17
def $int_to_text



;; ../../../../spec-concrete/0-aux.watsup:29.1-30.17
def $concat_text(text*{text <- text*})

1. Case analysis on text*{text <- text*}

  1. Case (% matches pattern [])

    1. Return ""

  2. Case (% matches pattern _ :: _)

    1. (Let t :: t'*{t' <- t'*} be text*{text <- text*})

    2. Return t ++ $concat_text(t'*{t' <- t'*})

;; ../../../../spec-concrete/0-aux.watsup:35.1-35.37
def $strip_prefix



;; ../../../../spec-concrete/0-aux.watsup:36.1-36.37
def $strip_suffix



;; ../../../../spec-concrete/0-aux.watsup:42.1-42.23
def $init_(nat')

1. Case analysis on nat'

  1. Case (% = 0)

    1. Return []

  2. Case (% =/= 0)

    1. (Let int be (nat' - 1))

    2. If ((int has type nat)), then

      1. (Let n' be (int as nat))

      2. Return n' :: $init_(n')

    2. Else Phantom#0

;; ../../../../spec-concrete/0-aux.watsup:48.1-48.29
def $repeat_<X>(X, nat')

1. Case analysis on nat'

  1. Case (% = 0)

    1. Return []

  2. Case (% =/= 0)

    1. (Let int be (nat' - 1))

    2. If ((int has type nat)), then

      1. (Let n' be (int as nat))

      2. Return [X] ++ $repeat_<X>(X, n')

    2. Else Phantom#1

;; ../../../../spec-concrete/0-aux.watsup:55.1-56.26
def $rev_<X>



;; ../../../../spec-concrete/0-aux.watsup:58.1-59.23
def $concat_<X>



;; ../../../../spec-concrete/0-aux.watsup:61.1-61.39
def $partition_<X>



;; ../../../../spec-concrete/0-aux.watsup:63.1-64.23
def $assoc_<X, Y>



;; ../../../../spec-concrete/0-aux.watsup:66.1-67.28
def $distinct_<K>



;; ../../../../spec-concrete/0-aux.watsup:73.17-73.24
syntax set<K> = 
   | `{%}`(K*)

;; ../../../../spec-concrete/0-aux.watsup:75.1-76.43
def $empty_set<K>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:79.1-80.36
def $in_set<K>(K, ({ K'*{K' <- K'*} }))

1. Return K is in K'*{K' <- K'*}

;; ../../../../spec-concrete/0-aux.watsup:83.1-84.37
def $intersect_set<K>



;; ../../../../spec-concrete/0-aux.watsup:86.1-87.37
def $union_set<K>



;; ../../../../spec-concrete/0-aux.watsup:89.1-90.37
def $unions_set<K>



;; ../../../../spec-concrete/0-aux.watsup:92.1-93.42
def $diff_set<K>



;; ../../../../spec-concrete/0-aux.watsup:95.1-96.40
def $sub_set<K>



;; ../../../../spec-concrete/0-aux.watsup:98.1-99.33
def $eq_set<K>



;; ../../../../spec-concrete/0-aux.watsup:105.21-105.27
syntax pair<K, V> = 
   | `%->%`(K, V)

;; ../../../../spec-concrete/0-aux.watsup:108.20-108.37
syntax map<K, V> = set<pair<K, V>>

;; ../../../../spec-concrete/0-aux.watsup:110.1-111.43
def $empty_map<K, V>

1. Return ({ [] })

;; ../../../../spec-concrete/0-aux.watsup:115.1-116.55
def $dom_map<K, V>(({ (K -> V)*{K <- K*, V <- V*} }))

1. Return ({ K*{K <- K*} })

;; ../../../../spec-concrete/0-aux.watsup:120.1-121.25
def $find_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:123.1-124.25
def $find_maps<K, V>



;; ../../../../spec-concrete/0-aux.watsup:126.1-127.71
def $add_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:129.1-130.71
def $adds_map<K, V>



;; ../../../../spec-concrete/0-aux.watsup:132.1-133.71
def $update_map<K, V>



;; ../../../../spec-concrete/1-syntax.watsup:5.15-5.18
syntax bits = int

;; ../../../../spec-concrete/1-syntax.watsup:6.16-6.19
syntax width = nat

;; ../../../../spec-concrete/1-syntax.watsup:9.1-11.20
syntax number = 
   | `INT%`(int)
   | `FINT%%`(width, bits)
   | `FBIT%%`(width, bits)

;; ../../../../spec-concrete/1-syntax.watsup:21.15-21.19
syntax name = text

;; ../../../../spec-concrete/1-syntax.watsup:28.1-29.17
syntax prefixedName = 
   | `TOP%`(name)
   | `CURRENT%`(name)

;; ../../../../spec-concrete/1-syntax.watsup:31.1-31.47
def $flatten_prefixedName(prefixedName)

1. Case analysis on prefixedName

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP name) be prefixedName)

    2. Return "." ++ name

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT name) be prefixedName)

    2. Return name

;; ../../../../spec-concrete/1-syntax.watsup:39.20-39.41
syntax direction = 
   | `NO`()
   | `IN`()
   | `OUT`()
   | `INOUT`()

;; ../../../../spec-concrete/1-syntax.watsup:52.1-59.21
syntax baseType = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)

;; ../../../../spec-concrete/1-syntax.watsup:68.3-68.21
syntax nameType = 
   | `NameT%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:71.3-71.35
syntax specializedType = 
   | `SpecT%%`(prefixedName, typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:74.1-75.20
syntax namedType = 
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:82.3-82.36
syntax headerStackType = 
   | `HeaderStackT%%`(namedType, expression)

;; ../../../../spec-concrete/1-syntax.watsup:88.19-88.37
syntax listType = 
   | `ListT%`(typeArgument)

;; ../../../../spec-concrete/1-syntax.watsup:94.20-94.40
syntax tupleType = 
   | `TupleT%`(typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:101.1-105.14
syntax type = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)

;; ../../../../spec-concrete/1-syntax.watsup:108.1-109.10
syntax typeOrVoid = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)
   | `VoidT`()

;; ../../../../spec-concrete/1-syntax.watsup:115.24-115.28
syntax typeParameter = name

;; ../../../../spec-concrete/1-syntax.watsup:124.3-124.35
syntax parameter = 
   | `%%%%`(direction, type, name, initializer?)

;; ../../../../spec-concrete/1-syntax.watsup:130.31-130.40
syntax constructorParameter = parameter

;; ../../../../spec-concrete/1-syntax.watsup:136.26-136.41
syntax namedExpression = 
   | `%%`(name, expression)

;; ../../../../spec-concrete/1-syntax.watsup:147.1-149.14
syntax literalExpression = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)

;; ../../../../spec-concrete/1-syntax.watsup:155.30-155.48
syntax referenceExpression = 
   | `NameE%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:161.28-161.36
syntax defaultExpression = 
   | `DefaultE`()

;; ../../../../spec-concrete/1-syntax.watsup:167.15-167.43
syntax unop = 
   | `BNOT`()
   | `LNOT`()
   | `UPLUS`()
   | `UMINUS`()

;; ../../../../spec-concrete/1-syntax.watsup:169.26-169.45
syntax unaryExpression = 
   | `UnE%%`(unop, expression)

;; ../../../../spec-concrete/1-syntax.watsup:172.1-180.15
syntax binop = 
   | `PLUS`()
   | `SPLUS`()
   | `MINUS`()
   | `SMINUS`()
   | `MUL`()
   | `DIV`()
   | `MOD`()
   | `SHL`()
   | `SHR`()
   | `LE`()
   | `GE`()
   | `LT`()
   | `GT`()
   | `EQ`()
   | `NE`()
   | `BAND`()
   | `BXOR`()
   | `BOR`()
   | `CONCAT`()
   | `LAND`()
   | `LOR`()

;; ../../../../spec-concrete/1-syntax.watsup:182.27-182.59
syntax binaryExpression = 
   | `BinE%%%`(expression, binop, expression)

;; ../../../../spec-concrete/1-syntax.watsup:185.3-185.41
syntax ternaryExpression = 
   | `TernE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:191.25-191.46
syntax castExpression = 
   | `CastE%%`(type, expression)

;; ../../../../spec-concrete/1-syntax.watsup:198.1-201.36
syntax dataExpression = 
   | `InvalidE`()
   | `SeqE%`(expression*)
   | `RecordE%`(namedExpression*)
   | `RecordDefaultE%`(namedExpression*)

;; ../../../../spec-concrete/1-syntax.watsup:207.32-207.44
syntax errorAccessExpression = 
   | `ErrAccE%`(name)

;; ../../../../spec-concrete/1-syntax.watsup:210.1-211.29
syntax memberAccessExpression = 
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:214.1-215.45
syntax indexAccessExpression = 
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:218.1-220.26
syntax accessExpression = 
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:231.1-232.30
syntax callExpression = 
   | `CallE%%%`(routineTarget, typeArgument*, argument*)
   | `InstE%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:239.1-248.19
syntax expression = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)
   | `NameE%`(prefixedName)
   | `DefaultE`()
   | `UnE%%`(unop, expression)
   | `BinE%%%`(expression, binop, expression)
   | `TernE%%%`(expression, expression, expression)
   | `CastE%%`(type, expression)
   | `InvalidE`()
   | `SeqE%`(expression*)
   | `RecordE%`(namedExpression*)
   | `RecordDefaultE%`(namedExpression*)
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(expression, name)
   | `ArrAccE%%`(expression, expression)
   | `BitAccE%%%`(expression, expression, expression)
   | `CallE%%%`(routineTarget, typeArgument*, argument*)
   | `InstE%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:250.24-250.34
syntax routineTarget = expression

;; ../../../../spec-concrete/1-syntax.watsup:257.1-261.9
syntax keysetExpression = 
   | `ExprK%`(expression)
   | `MaskK%%`(expression, expression)
   | `RangeK%%`(expression, expression)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec-concrete/1-syntax.watsup:268.1-270.9
syntax typeArgument = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `NameT%`(prefixedName)
   | `SpecT%%`(prefixedName, typeArgument*)
   | `HeaderStackT%%`(namedType, expression)
   | `ListT%`(typeArgument)
   | `TupleT%`(typeArgument*)
   | `VoidT`()
   | `AnyT`()

;; ../../../../spec-concrete/1-syntax.watsup:277.1-280.9
syntax argument = 
   | `ExprA%`(expression)
   | `NameA%%`(name, expression)
   | `NameAnyA%`(name)
   | `AnyA`()

;; ../../../../spec-concrete/1-syntax.watsup:287.1-290.41
syntax lvalue = 
   | `NameL%`(prefixedName)
   | `LvalueAccL%%`(lvalue, name)
   | `ArrAccL%%`(lvalue, expression)
   | `BitAccL%%%`(lvalue, expression, expression)

;; ../../../../spec-concrete/1-syntax.watsup:300.25-300.31
syntax emptyStatement = 
   | `EmptyS`()

;; ../../../../spec-concrete/1-syntax.watsup:306.30-306.55
syntax assignmentStatement = 
   | `AssignS%%`(lvalue, expression)

;; ../../../../spec-concrete/1-syntax.watsup:313.3-313.39
syntax callStatement = 
   | `CallS%%%`(lvalue, typeArgument*, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:319.37-319.62
syntax directApplicationStatement = 
   | `InstS%%`(namedType, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:325.26-325.45
syntax returnStatement = 
   | `ReturnS%`(expression?)

;; ../../../../spec-concrete/1-syntax.watsup:331.24-331.29
syntax exitStatement = 
   | `ExitS`()

;; ../../../../spec-concrete/1-syntax.watsup:340.3-340.32
syntax blockStatement = 
   | `BlockS%`(blockElementStatement*)

;; ../../../../spec-concrete/1-syntax.watsup:349.3-349.38
syntax conditionalStatement = 
   | `IfS%%%`(expression, statement, statement?)

;; ../../../../spec-concrete/1-syntax.watsup:356.1-357.21
syntax switchLabel = 
   | `DefaultL`()
   | `ExprL%`(expression)

;; ../../../../spec-concrete/1-syntax.watsup:360.1-361.38
syntax switchCase = 
   | `FallC%`(switchLabel)
   | `MatchC%%`(switchLabel, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:363.26-363.56
syntax switchStatement = 
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:370.1-378.20
syntax statement = 
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ReturnS%`(expression?)
   | `ExitS`()
   | `BlockS%`(blockElementStatement*)
   | `IfS%%%`(expression, statement, statement?)
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:388.22-388.32
syntax initializer = expression

;; ../../../../spec-concrete/1-syntax.watsup:391.3-391.31
syntax constantDeclaration = 
   | `ConstD%%%`(type, name, initializer)

;; ../../../../spec-concrete/1-syntax.watsup:394.3-394.30
syntax variableDeclaration = 
   | `VarD%%%`(type, name, initializer?)

;; ../../../../spec-concrete/1-syntax.watsup:397.1-399.14
syntax blockElementStatement = 
   | `ConstD%%%`(type, name, initializer)
   | `VarD%%%`(type, name, initializer?)
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ReturnS%`(expression?)
   | `ExitS`()
   | `BlockS%`(blockElementStatement*)
   | `IfS%%%`(expression, statement, statement?)
   | `SwitchS%%`(expression, switchCase*)

;; ../../../../spec-concrete/1-syntax.watsup:406.3-407.49
syntax functionDeclaration = 
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:414.3-414.41
syntax actionDeclaration = 
   | `ActionD%%%`(name, parameter*, blockStatement)

;; ../../../../spec-concrete/1-syntax.watsup:423.3-423.47
syntax instantiation = 
   | `InstD%%%%`(type, argument*, name, objectInitializer?)

;; ../../../../spec-concrete/1-syntax.watsup:426.1-427.18
syntax objectDeclaration = 
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)

;; ../../../../spec-concrete/1-syntax.watsup:429.28-429.46
syntax objectInitializer = objectDeclaration*

;; ../../../../spec-concrete/1-syntax.watsup:435.27-435.37
syntax errorDeclaration = 
   | `ErrD%`(name*)

;; ../../../../spec-concrete/1-syntax.watsup:441.31-441.47
syntax matchKindDeclaration = 
   | `MatchKindD%`(name*)

;; ../../../../spec-concrete/1-syntax.watsup:452.1-453.38
syntax enumTypeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)

;; ../../../../spec-concrete/1-syntax.watsup:459.20-459.29
syntax typeField = 
   | `%%`(type, name)

;; ../../../../spec-concrete/1-syntax.watsup:462.3-462.41
syntax structTypeDeclaration = 
   | `StructD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:465.3-465.41
syntax headerTypeDeclaration = 
   | `HeaderD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:468.3-468.46
syntax headerUnionTypeDeclaration = 
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:471.1-474.31
syntax derivedTypeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)

;; ../../../../spec-concrete/1-syntax.watsup:481.1-482.36
syntax typedefType = 
   | `PlainT%`(type)
   | `DerivedT%`(derivedTypeDeclaration)

;; ../../../../spec-concrete/1-syntax.watsup:485.1-486.23
syntax typedefDeclaration = 
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)

;; ../../../../spec-concrete/1-syntax.watsup:493.3-494.40
syntax externFunctionDeclaration = 
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:497.1-499.62
syntax methodPrototype = 
   | `ConsM%%`(name, constructorParameter*)
   | `MethodM%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `AbstractMethodM%%%%`(typeOrVoid, name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:502.3-502.53
syntax externObjectDeclaration = 
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)

;; ../../../../spec-concrete/1-syntax.watsup:505.1-506.28
syntax externDeclaration = 
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)

;; ../../../../spec-concrete/1-syntax.watsup:516.21-516.43
syntax selectCase = 
   | `%%`(keysetExpression*, name)

;; ../../../../spec-concrete/1-syntax.watsup:523.1-524.36
syntax stateExpression = 
   | `NameE%`(name)
   | `SelectE%%`(expression*, selectCase*)

;; ../../../../spec-concrete/1-syntax.watsup:526.30-526.52
syntax transitionStatement = 
   | `TransS%`(stateExpression)

;; ../../../../spec-concrete/1-syntax.watsup:533.1-535.13
syntax valueSetType = 
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(expression)
   | `FBitT%`(expression)
   | `VBitT%`(expression)
   | `TupleT%`(typeArgument*)
   | `NameT%`(prefixedName)

;; ../../../../spec-concrete/1-syntax.watsup:538.3-538.41
syntax valueSetDeclaration = 
   | `ValueSetD%%%`(valueSetType, expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:545.3-545.45
syntax parserTypeDeclaration = 
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:554.3-554.32
syntax parserBlockStatement = 
   | `ParserBlockS%`(parserStatement*)

;; ../../../../spec-concrete/1-syntax.watsup:557.1-564.25
syntax parserStatement = 
   | `ConstD%%%`(type, name, initializer)
   | `VarD%%%`(type, name, initializer?)
   | `EmptyS`()
   | `AssignS%%`(lvalue, expression)
   | `CallS%%%`(lvalue, typeArgument*, argument*)
   | `InstS%%`(namedType, argument*)
   | `ParserBlockS%`(parserStatement*)
   | `IfS%%%`(expression, statement, statement?)

;; ../../../../spec-concrete/1-syntax.watsup:567.3-567.45
syntax parserState = 
   | `%%%`(name, parserStatement*, transitionStatement?)

;; ../../../../spec-concrete/1-syntax.watsup:570.1-573.24
syntax parserLocalDeclaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `VarD%%%`(type, name, initializer?)
   | `ValueSetD%%%`(valueSetType, expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:576.3-578.47
syntax parserDeclaration = 
   | `ParserD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, parserLocalDeclaration*, parserState*)

;; ../../../../spec-concrete/1-syntax.watsup:588.16-588.21
syntax const = 
   | `CONST`()

;; ../../../../spec-concrete/1-syntax.watsup:594.19-594.34
syntax tableKey = 
   | `%%`(expression, name)

;; ../../../../spec-concrete/1-syntax.watsup:600.31-600.53
syntax tableActionReference = 
   | `%%`(prefixedName, argument*)

;; ../../../../spec-concrete/1-syntax.watsup:602.22-602.42
syntax tableAction = tableActionReference

;; ../../../../spec-concrete/1-syntax.watsup:608.29-608.39
syntax tableEntryPriority = expression

;; ../../../../spec-concrete/1-syntax.watsup:611.3-612.48
syntax tableEntry = 
   | `%%%%`(const?, tableEntryPriority?, keysetExpression*, tableActionReference)

;; ../../../../spec-concrete/1-syntax.watsup:619.1-622.36
syntax tableProperty = 
   | `KeyP%`(tableKey*)
   | `ActionP%`(tableAction*)
   | `EntryP%%`(const?, tableEntry*)
   | `CustomP%%%`(const?, name, initializer)

;; ../../../../spec-concrete/1-syntax.watsup:625.3-625.29
syntax tableDeclaration = 
   | `TableD%%`(name, tableProperty*)

;; ../../../../spec-concrete/1-syntax.watsup:632.3-632.46
syntax controlTypeDeclaration = 
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)

;; ../../../../spec-concrete/1-syntax.watsup:638.22-638.36
syntax controlBody = blockStatement

;; ../../../../spec-concrete/1-syntax.watsup:641.1-645.21
syntax controlLocalDeclaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `VarD%%%`(type, name, initializer?)
   | `ActionD%%%`(name, parameter*, blockStatement)
   | `TableD%%`(name, tableProperty*)

;; ../../../../spec-concrete/1-syntax.watsup:648.3-650.48
syntax controlDeclaration = 
   | `ControlD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, controlLocalDeclaration*, controlBody)

;; ../../../../spec-concrete/1-syntax.watsup:657.3-657.57
syntax packageTypeDeclaration = 
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:664.1-668.27
syntax typeDeclaration = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:675.1-684.20
syntax declaration = 
   | `ConstD%%%`(type, name, initializer)
   | `InstD%%%%`(type, argument*, name, objectInitializer?)
   | `FuncD%%%%%`(typeOrVoid, name, typeParameter*, parameter*, blockStatement)
   | `ActionD%%%`(name, parameter*, blockStatement)
   | `ErrD%`(name*)
   | `MatchKindD%`(name*)
   | `ExternFuncD%%%%`(typeOrVoid, name, typeParameter*, parameter*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototype*)
   | `ParserD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, parserLocalDeclaration*, parserState*)
   | `ControlD%%%%%%`(name, typeParameter*, parameter*, constructorParameter*, controlLocalDeclaration*, controlBody)
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(type, name, namedExpression*)
   | `StructD%%%`(name, typeParameter*, typeField*)
   | `HeaderD%%%`(name, typeParameter*, typeField*)
   | `HeaderUnionD%%%`(name, typeParameter*, typeField*)
   | `TypeDefD%%`(typedefType, name)
   | `NewTypeD%%`(type, name)
   | `ParserTypeD%%%`(name, typeParameter*, parameter*)
   | `ControlTypeD%%%`(name, typeParameter*, parameter*)
   | `PackageTypeD%%%`(name, typeParameter*, constructorParameter*)

;; ../../../../spec-concrete/1-syntax.watsup:690.20-690.32
syntax p4program = declaration*

;; ../../../../spec-concrete/2.0-domain.watsup:5.13-5.17
syntax id = text

;; ../../../../spec-concrete/2.0-domain.watsup:11.14-11.16
syntax tid = id

;; ../../../../spec-concrete/2.0-domain.watsup:13.1-13.23
def $fresh_tid



;; ../../../../spec-concrete/2.0-domain.watsup:14.1-14.28
def $fresh_tids(nat')

1. Case analysis on nat'

  1. Case (% = 0)

    1. Return []

  2. Case (% =/= 0)

    1. (Let int be (nat' - 1))

    2. If ((int has type nat)), then

      1. (Let n' be (int as nat))

      2. Return $fresh_tid :: $fresh_tids(n')

    2. Else Phantom#2

;; ../../../../spec-concrete/2.0-domain.watsup:29.14-29.21
syntax pid = 
   | `%%`(id, bool)

;; ../../../../spec-concrete/2.0-domain.watsup:30.14-30.21
syntax rid = 
   | `%%`(id, pid*)

;; ../../../../spec-concrete/2.0-domain.watsup:32.1-32.33
def $rid(name, parameter*{parameter <- parameter*})

1. Return (name $pid(parameter)*{parameter <- parameter*})

;; ../../../../spec-concrete/2.0-domain.watsup:33.1-33.26
def $pid((_direction _type name initializer''?{initializer'' <- initializer''?}))

1. Case analysis on initializer''?{initializer'' <- initializer''?}

  1. Case (% matches pattern ())

    1. Return (name false)

  2. Case (% matches pattern (_))

    1. (Let ?(initializer) be initializer''?{initializer'' <- initializer''?})

    2. Return (name true)

;; ../../../../spec-concrete/2.0-domain.watsup:45.14-45.17
syntax cid = rid

;; ../../../../spec-concrete/2.0-domain.watsup:47.1-47.44
def $cid(name, constructorParameter*{constructorParameter <- constructorParameter*})

1. Return $rid(name, constructorParameter*{constructorParameter <- constructorParameter*})

;; ../../../../spec-concrete/2.1.1-value.watsup:14.1-17.14
syntax primitiveValue = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)

;; ../../../../spec-concrete/2.1.1-value.watsup:24.1-27.27
syntax numberValue = 
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)

;; ../../../../spec-concrete/2.1.1-value.watsup:30.1-31.16
syntax baseValue = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)

;; ../../../../spec-concrete/2.1.1-value.watsup:39.20-39.32
syntax listValue = 
   | `ListV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:40.21-40.35
syntax tupleValue = 
   | `TupleV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:41.27-41.54
syntax headerStackValue = 
   | `HeaderStackV%%%`(value*, nat, nat)

;; ../../../../spec-concrete/2.1.1-value.watsup:43.21-43.29
syntax fieldValue = 
   | `%%`(value, id)

;; ../../../../spec-concrete/2.1.1-value.watsup:45.22-45.45
syntax structValue = 
   | `StructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:46.22-46.50
syntax headerValue = 
   | `HeaderV%%%`(tid, bool, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:47.27-47.55
syntax headerUnionValue = 
   | `HeaderUnionV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:50.1-51.24
syntax enumValue = 
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:54.1-60.14
syntax dataValue = 
   | `ListV%`(value*)
   | `TupleV%`(value*)
   | `HeaderStackV%%%`(value*, nat, nat)
   | `StructV%%`(tid, fieldValue*)
   | `HeaderV%%%`(tid, bool, fieldValue*)
   | `HeaderUnionV%%`(tid, fieldValue*)
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:66.23-66.31
syntax defaultValue = 
   | `DefaultV`()

;; ../../../../spec-concrete/2.1.1-value.watsup:68.29-68.43
syntax invalidHeaderValue = 
   | `InvalidHeaderV`()

;; ../../../../spec-concrete/2.1.1-value.watsup:71.1-72.23
syntax sequenceValue = 
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)

;; ../../../../spec-concrete/2.1.1-value.watsup:75.1-76.31
syntax recordValue = 
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:79.1-81.26
syntax setValue = 
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)

;; ../../../../spec-concrete/2.1.1-value.watsup:84.1-85.33
syntax tableValue = 
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:88.1-93.15
syntax synthesizedValue = 
   | `DefaultV`()
   | `InvalidHeaderV`()
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.1-value.watsup:100.1-102.21
syntax value = 
   | `BoolV%`(bool)
   | `ErrV%`(id)
   | `MatchKindV%`(id)
   | `StrV%`(text)
   | `IntV%`(int)
   | `FIntV%%`(width, bits)
   | `FBitV%%`(width, bits)
   | `VBitV%%%`(width, width, bits)
   | `ListV%`(value*)
   | `TupleV%`(value*)
   | `HeaderStackV%%%`(value*, nat, nat)
   | `StructV%%`(tid, fieldValue*)
   | `HeaderV%%%`(tid, bool, fieldValue*)
   | `HeaderUnionV%%`(tid, fieldValue*)
   | `EnumV%%`(tid, id)
   | `SEnumV%%%`(tid, id, value)
   | `DefaultV`()
   | `InvalidHeaderV`()
   | `SeqV%`(value*)
   | `SeqDefaultV%`(value*)
   | `RecordV%`(fieldValue*)
   | `RecordDefaultV%`(fieldValue*)
   | `SingletonSetV%`(value)
   | `MaskSetV%%`(value, value)
   | `RangeSetV%%`(value, value)
   | `TableEnumV%%`(tid, id)
   | `TableStructV%%`(tid, fieldValue*)

;; ../../../../spec-concrete/2.1.2-value-aux.watsup:5.1-5.28
def $to_int



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:12.1-12.31
def $to_bitstr



;; ../../../../spec-concrete/2.1.2-value-aux.watsup:18.1-18.29
def $to_number(value')

1. If ((value' has type numberValue)), then

  1. (Let numberValue be (value' as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i) be numberValue)

      2. Return ?(i)

    2. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i) be numberValue)

      2. Return ?($to_int((w as int), i))

    3. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV _width i) be numberValue)

      2. Return ?(i)

    4. Case (% matches pattern `VBitV%%%`)

      1. (Let (VBitV _width _width' i) be numberValue)

      2. Return ?(i)

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/2.2.1-type.watsup:14.1-18.9
syntax primitiveTypeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:25.1-28.14
syntax numberTypeIR = 
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:31.1-32.17
syntax baseTypeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:42.1-43.32
syntax namedTypeIR = 
   | `NameT%`(tid)
   | `SpecT%%`(polyTypeDefIR, typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:54.1-55.20
syntax aliasTypeIR = 
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:61.21-61.33
syntax listTypeIR = 
   | `ListT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:62.22-62.36
syntax tupleTypeIR = 
   | `TupleT%`(typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:63.28-63.51
syntax headerStackTypeIR = 
   | `HeaderStackT%%`(typeIR, nat)

;; ../../../../spec-concrete/2.2.1-type.watsup:65.22-65.31
syntax fieldTypeIR = 
   | `%%`(typeIR, id)

;; ../../../../spec-concrete/2.2.1-type.watsup:67.23-67.47
syntax structTypeIR = 
   | `StructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:68.23-68.47
syntax headerTypeIR = 
   | `HeaderT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:69.28-69.57
syntax headerUnionTypeIR = 
   | `HeaderUnionT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:71.23-71.31
syntax valueFieldIR = 
   | `%%`(id, value)

;; ../../../../spec-concrete/2.2.1-type.watsup:74.1-75.36
syntax enumTypeIR = 
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:78.1-84.15
syntax dataTypeIR = 
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:93.29-93.67
syntax externObjectTypeIR = 
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)

;; ../../../../spec-concrete/2.2.1-type.watsup:94.29-94.53
syntax parserObjectTypeIR = 
   | `ParserT%`(parameterTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:95.30-95.55
syntax controlObjectTypeIR = 
   | `ControlT%`(parameterTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:96.30-96.50
syntax packageObjectTypeIR = 
   | `PackageT%%`(tid, typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:97.28-97.45
syntax tableObjectTypeIR = 
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:100.1-104.22
syntax objectTypeIR = 
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:107.1-109.17
syntax definedTypeIR = 
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:115.24-115.32
syntax defaultTypeIR = 
   | `DefaultT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:117.30-117.44
syntax invalidHeaderTypeIR = 
   | `InvalidHeaderT`()

;; ../../../../spec-concrete/2.2.1-type.watsup:120.1-121.24
syntax sequenceTypeIR = 
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:124.1-125.32
syntax recordTypeIR = 
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:127.20-127.31
syntax setTypeIR = 
   | `SetT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:130.1-131.34
syntax tableTypeIR = 
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:134.1-139.16
syntax synthesizedTypeIR = 
   | `DefaultT`()
   | `InvalidHeaderT`()
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)
   | `SetT%`(typeIR)
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:146.1-149.22
syntax typeIR = 
   | `VoidT`()
   | `BoolT`()
   | `ErrT`()
   | `MatchKindT`()
   | `StrT`()
   | `IntT`()
   | `FIntT%`(nat)
   | `FBitT%`(nat)
   | `VBitT%`(nat)
   | `NameT%`(tid)
   | `SpecT%%`(polyTypeDefIR, typeIR*)
   | `DefT%%`(tid, typeIR)
   | `NewT%%`(tid, typeIR)
   | `ListT%`(typeIR)
   | `TupleT%`(typeIR*)
   | `HeaderStackT%%`(typeIR, nat)
   | `StructT%%`(tid, fieldTypeIR*)
   | `HeaderT%%`(tid, fieldTypeIR*)
   | `HeaderUnionT%%`(tid, fieldTypeIR*)
   | `EnumT%%`(tid, id*)
   | `SEnumT%%%`(tid, typeIR, valueFieldIR*)
   | `ExternT%%`(tid, map<rid, routineTypeDefIR>)
   | `ParserT%`(parameterTypeIR*)
   | `ControlT%`(parameterTypeIR*)
   | `PackageT%%`(tid, typeIR*)
   | `TableT%%`(tid, typeIR)
   | `DefaultT`()
   | `InvalidHeaderT`()
   | `SeqT%`(typeIR*)
   | `SeqDefaultT%`(typeIR*)
   | `RecordT%`(fieldTypeIR*)
   | `RecordDefaultT%`(fieldTypeIR*)
   | `SetT%`(typeIR)
   | `TableEnumT%%`(tid, id*)
   | `TableStructT%%`(tid, fieldTypeIR*)

;; ../../../../spec-concrete/2.2.1-type.watsup:155.24-155.37
syntax monoTypeDefIR = 
   | `MonoTD%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:157.24-157.47
syntax polyTypeDefIR = 
   | `PolyTD%%%`(typeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:160.1-161.18
syntax typeDefIR = 
   | `MonoTD%`(typeIR)
   | `PolyTD%%%`(typeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:167.26-167.52
syntax parameterTypeIR = 
   | `%%%%`(direction, typeIR, id, value?)

;; ../../../../spec-concrete/2.2.1-type.watsup:174.1-183.29
syntax routineTypeIR = 
   | `BuiltinFuncT%%`(parameterTypeIR*, typeIR)
   | `FuncT%%`(parameterTypeIR*, typeIR)
   | `ExternFuncT%%`(parameterTypeIR*, typeIR)
   | `ActionT%`(parameterTypeIR*)
   | `BuiltinMethodT%%`(parameterTypeIR*, typeIR)
   | `ExternMethodT%%`(parameterTypeIR*, typeIR)
   | `ExternAbstractMethodT%%`(parameterTypeIR*, typeIR)
   | `ParserApplyMethodT%`(parameterTypeIR*)
   | `ControlApplyMethodT%`(parameterTypeIR*)
   | `TableApplyMethodT%`(typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:189.31-189.51
syntax monoRoutineTypeDefIR = 
   | `MonoTD%`(routineTypeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:191.31-191.61
syntax polyRoutineTypeDefIR = 
   | `PolyTD%%%`(routineTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:194.1-195.25
syntax routineTypeDefIR = 
   | `MonoTD%`(routineTypeIR)
   | `PolyTD%%%`(routineTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.1-type.watsup:201.37-201.52
syntax constructorParameterTypeIR = parameterTypeIR

;; ../../../../spec-concrete/2.2.1-type.watsup:208.3-208.50
syntax constructorTypeIR = 
   | `ConstructorT%%`(constructorParameterTypeIR*, typeIR)

;; ../../../../spec-concrete/2.2.1-type.watsup:214.31-214.65
syntax constructorTypeDefIR = 
   | `PolyTD%%%`(constructorTypeIR, tid*, tid*)

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:9.1-9.34
def $is_baseTypeIR(typeIR)

1. If ((typeIR has type baseTypeIR)), then

  1. (Let baseTypeIR be (typeIR as baseTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:16.1-16.39
def $is_primitiveTypeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:21.1-21.35
def $is_void_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `VoidT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:26.1-26.35
def $is_bool_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BoolT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:31.1-31.36
def $is_error_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `ErrT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:36.1-36.40
def $is_matchkind_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `MatchKindT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:41.1-41.37
def $is_string_typeIR(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `StrT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:48.1-48.36
def $is_numberTypeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:53.1-53.44
def $is_arbitrary_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `IntT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:58.1-58.40
def $is_fixed_int_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `FIntT%`)), then

    1. (Let (FIntT _nat) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:63.1-63.40
def $is_fixed_bit_typeIR(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. If ((numberTypeIR matches pattern `FBitT%`)), then

    1. (Let (FBitT _nat) be numberTypeIR)

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:76.1-76.34
def $is_dataTypeIR(typeIR)

1. If ((typeIR has type dataTypeIR)), then

  1. (Let dataTypeIR be (typeIR as dataTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:81.1-81.41
def $is_headerStackTypeIR(typeIR)

1. If ((typeIR has type headerStackTypeIR)), then

  1. (Let headerStackTypeIR be (typeIR as headerStackTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:88.1-88.36
def $is_objectTypeIR(typeIR)

1. If ((typeIR has type objectTypeIR)), then

  1. (Let objectTypeIR be (typeIR as objectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:93.1-93.44
def $is_extern_object_typeIR(typeIR)

1. If ((typeIR has type externObjectTypeIR)), then

  1. (Let externObjectTypeIR be (typeIR as externObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:98.1-98.44
def $is_parser_object_typeIR(typeIR)

1. If ((typeIR has type parserObjectTypeIR)), then

  1. (Let parserObjectTypeIR be (typeIR as parserObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:103.1-103.45
def $is_control_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:108.1-108.45
def $is_package_object_typeIR(typeIR)

1. If ((typeIR has type packageObjectTypeIR)), then

  1. (Let packageObjectTypeIR be (typeIR as packageObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:113.1-113.43
def $is_table_object_typeIR(typeIR)

1. If ((typeIR has type controlObjectTypeIR)), then

  1. (Let controlObjectTypeIR be (typeIR as controlObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:120.1-120.41
def $is_synthesizedTypeIR(typeIR)

1. If ((typeIR has type tableObjectTypeIR)), then

  1. (Let tableObjectTypeIR be (typeIR as tableObjectTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.2-type-aux.watsup:125.1-125.34
def $is_set_typeIR(typeIR)

1. If ((typeIR has type setTypeIR)), then

  1. (Let (SetT _typeIR) be (typeIR as setTypeIR))

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:5.16-5.24
syntax bound = set<tid>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:6.16-6.32
syntax theta = map<tid, typeIR>

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:8.1-8.31
def $free_type(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'' as baseTypeIR))

    2. Return ({ [] })

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `NameT%`)

        1. (Let (NameT tid) be namedTypeIR)

        2. Return ({ [tid] })

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT polyTypeDefIR typeIR*{typeIR <- typeIR*}) be namedTypeIR)

        2. (Let bound_base be $free_typeDef((polyTypeDefIR as typeDefIR)))

        3. (Let bound_args be $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*}))

        4. Return $union_set<tid>(bound_base, bound_args)

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `DefT%%`)

        1. (Let (DefT _tid typeIR) be aliasTypeIR)

        2. Return $free_type(typeIR)

      2. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _tid typeIR) be aliasTypeIR)

        2. Return $free_type(typeIR)

  4. Case (% has type listTypeIR)

    1. (Let (ListT typeIR) be (typeIR'' as listTypeIR))

    2. Return $free_type(typeIR)

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR _nat) be (typeIR'' as headerStackTypeIR))

    2. Return $free_type(typeIR)

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return $free_type(typeIR)

  11. Case (% has type externObjectTypeIR)

    1. (Let (ExternT _tid ({ (_rid -> routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} })) be (typeIR'' as externObjectTypeIR))

    2. Return $unions_set<tid>($free_routineTypeDef(routineTypeDefIR)*{routineTypeDefIR <- routineTypeDefIR*})

  12. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR'' as parserObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. Return bound_params

  13. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR'' as controlObjectTypeIR))

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. Return bound_params

  14. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT tid typeIR*{typeIR <- typeIR*}) be (typeIR'' as packageObjectTypeIR))

    2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  15. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid typeIR) be (typeIR'' as tableObjectTypeIR))

    2. Return $free_type(typeIR)

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR'' as defaultTypeIR))

    2. Return ({ [] })

  17. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR'' as invalidHeaderTypeIR))

    2. Return ({ [] })

  18. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  19. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR'' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be recordTypeIR)

        2. Return $unions_set<tid>($free_type(typeIR)*{typeIR <- typeIR*})

  20. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR'' as setTypeIR))

    2. Return $free_type(typeIR)

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _tid _id*{_id <- _id*}) be tableTypeIR)

        2. Return ({ [] })

      2. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be tableTypeIR)

        2. Return ({ [] })

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:9.1-9.37
def $free_typeDef(typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type monoTypeDefIR)

    1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

    2. Return $free_type(typeIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (PolyTD typeIR_base tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (typeDefIR as polyTypeDefIR))

    2. (Let bound_base be $free_type(typeIR_base))

    3. (Let bound_tparams be ({ tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:10.1-10.49
def $free_parameterType((_direction typeIR _id _value?{_value <- _value?}))

1. Return $free_type(typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:11.1-11.45
def $free_routineType(routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% matches pattern `BuiltinFuncT%%`)

    1. (Let (BuiltinFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  3. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  4. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. Return bound_params

  5. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  6. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  7. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. (Let bound_ret be $free_type(typeIR_ret))

    4. Return $union_set<tid>(bound_params, bound_ret)

  8. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. Return bound_params

  9. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let bound_params be $unions_set<tid>($free_parameterType(parameterTypeIR)*{parameterTypeIR <- parameterTypeIR*}))

    3. Return bound_params

  10. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typeIR_ret) be routineTypeIR)

    2. (Let bound_ret be $free_type(typeIR_ret))

    3. Return bound_ret

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:12.1-12.51
def $free_routineTypeDef(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. Return $free_routineType(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let bound_base be $free_routineType(routineTypeIR))

    3. (Let bound_tparams be ({ tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} }))

    4. Return $diff_set<tid>(bound_base, bound_tparams)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:14.1-14.40
def $subst_type(set<pair<tid, typeIR>>', typeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeIR

2. Otherwise

  1. Return $subst_type'(set<pair<tid, typeIR>>', typeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:15.1-15.41
def $subst_type'(theta, typeIR''')

1. Case analysis on typeIR'''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `NameT%`)

        1. (Let (NameT tid) be namedTypeIR)

        2. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<tid, typeIR>(theta, tid))

        3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

          2. Return typeIR

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT polyTypeDefIR typeIR*{typeIR <- typeIR*}) be namedTypeIR)

        2. (Let typeDefIR be $subst_typeDef'(theta, (polyTypeDefIR as typeDefIR)))

        3. If ((typeDefIR has type polyTypeDefIR)), then

          1. (Let polyTypeDefIR_subst be (typeDefIR as polyTypeDefIR))

          2. (Let typeIR_subst be $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

          3. Return ((SpecT polyTypeDefIR_subst typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `DefT%%`)

        1. (Let (DefT tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((DefT tid typeIR_subst) as typeIR)

      2. Case (% matches pattern `NewT%%`)

        1. (Let (NewT tid typeIR) be aliasTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))

        3. Return ((NewT tid typeIR_subst) as typeIR)

  3. Case (% has type listTypeIR)

    1. (Let (ListT typeIR) be (typeIR''' as listTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((ListT typeIR_subst) as typeIR)

  4. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR''' as tupleTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

    3. Return ((TupleT typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR)

  5. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR n) be (typeIR''' as headerStackTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((HeaderStackT typeIR_subst n) as typeIR)

  6. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR''' as structTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

    3. Return ((StructT tid (typeIR_f_subst id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR)

  7. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR''' as headerTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

    3. Return ((HeaderT tid (typeIR_f_subst id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR)

  8. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR''' as headerUnionTypeIR))

    2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

    3. Return ((HeaderUnionT tid (typeIR_f_subst id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR)

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT tid typeIR valueFieldIR*{valueFieldIR <- valueFieldIR*}) be enumTypeIR)

      2. (Let typeIR_subst be $subst_type'(theta, typeIR))

      3. Return ((SEnumT tid typeIR_subst valueFieldIR*{valueFieldIR <- valueFieldIR*}) as typeIR)

  10. Case (% has type externObjectTypeIR)

    1. (Let (ExternT tid ({ (rid -> routineTypeDefIR)*{rid <- rid*, routineTypeDefIR <- routineTypeDefIR*} })) be (typeIR''' as externObjectTypeIR))

    2. (Let routineTypeDefIR_subst be $subst_routineTypeDef'(theta, routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*, routineTypeDefIR_subst <- routineTypeDefIR_subst*}

    3. Return ((ExternT tid ({ (rid -> routineTypeDefIR_subst)*{rid <- rid*, routineTypeDefIR_subst <- routineTypeDefIR_subst*} })) as typeIR)

  11. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR''' as parserObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. Return ((ParserT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}) as typeIR)

  12. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR''' as controlObjectTypeIR))

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. Return ((ControlT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*}) as typeIR)

  13. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT tid typeIR*{typeIR <- typeIR*}) be (typeIR''' as packageObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

    3. Return ((PackageT tid typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR)

  14. Case (% has type tableObjectTypeIR)

    1. (Let (TableT tid typeIR) be (typeIR''' as tableObjectTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((TableT tid typeIR_subst) as typeIR)

  15. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

        3. Return ((SeqT typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR)

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. (Let typeIR_subst be $subst_type'(theta, typeIR))*{typeIR <- typeIR*, typeIR_subst <- typeIR_subst*}

        3. Return ((SeqDefaultT typeIR_subst*{typeIR_subst <- typeIR_subst*}) as typeIR)

  16. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

        3. Return ((RecordT (typeIR_f_subst id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR)

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be recordTypeIR)

        2. (Let typeIR_f_subst be $subst_type'(theta, typeIR_f))*{typeIR_f <- typeIR_f*, typeIR_f_subst <- typeIR_f_subst*}

        3. Return ((RecordDefaultT (typeIR_f_subst id_f)*{id_f <- id_f*, typeIR_f_subst <- typeIR_f_subst*}) as typeIR)

  17. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR''' as setTypeIR))

    2. (Let typeIR_subst be $subst_type'(theta, typeIR))

    3. Return ((SetT typeIR_subst) as typeIR)

2. Otherwise

  1. Return typeIR'''

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:16.1-16.49
def $subst_typeDef(set<pair<tid, typeIR>>', typeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return typeDefIR

2. Otherwise

  1. Return $subst_typeDef'(set<pair<tid, typeIR>>', typeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:17.1-17.50
def $subst_typeDef'(theta, typeDefIR)

1. Case analysis on typeDefIR

  1. Case (% has type monoTypeDefIR)

    1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

    2. Return ((MonoTD $subst_type'(theta, typeIR)) as typeDefIR)

  2. Case (% has type polyTypeDefIR)

    1. (Let (PolyTD typeIR_base tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (typeDefIR as polyTypeDefIR))

    2. (Let ({ tid_free*{tid_free <- tid_free*} }) be $diff_set<tid>($free_type(typeIR_base), ({ tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })))

    3. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}

    4. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

      1. (Let ?(typeIR_free) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*}))

      3. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}, then

        1. (Let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} be tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|])

        2. (Let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} be tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, ((NameT tid_fresh_spec) as typeIR)*{tid_fresh_spec <- tid_fresh_spec*}))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, ((NameT tid_fresh_hidden) as typeIR)*{tid_fresh_hidden <- tid_fresh_hidden*}))

        5. (Let typeIR_base_subst be $subst_type(theta'', typeIR_base))

        6. Return ((PolyTD typeIR_base_subst tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*}) as typeDefIR)

      4. Else Phantom#3

    4. Else Phantom#4

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:18.1-18.67
def $subst_parameterType(set<pair<tid, typeIR>>', parameterTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return parameterTypeIR

2. Otherwise

  1. Return $subst_parameterType'(set<pair<tid, typeIR>>', parameterTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:19.1-19.68
def $subst_parameterType'(theta, (direction typeIR id value?{value <- value?}))

1. (Let typeIR_subst be $subst_type'(theta, typeIR))

2. Return (direction typeIR_subst id value?{value <- value?})

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:20.1-20.61
def $subst_routineType(set<pair<tid, typeIR>>', routineTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeIR

2. Otherwise

  1. Return $subst_routineType'(set<pair<tid, typeIR>>', routineTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:21.1-21.62
def $subst_routineType'(theta, routineTypeIR)

1. Case analysis on routineTypeIR

  1. Case (% matches pattern `BuiltinFuncT%%`)

    1. (Let (BuiltinFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (BuiltinFuncT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (FuncT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  3. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (ExternFuncT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  4. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. Return (ActionT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})

  5. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (BuiltinMethodT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  6. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (ExternMethodT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  7. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    4. Return (ExternAbstractMethodT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_ret_subst)

  8. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. Return (ParserApplyMethodT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})

  9. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

    3. Return (ControlApplyMethodT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*})

  10. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typeIR_ret) be routineTypeIR)

    2. (Let typeIR_ret_subst be $subst_type'(theta, typeIR_ret))

    3. Return (TableApplyMethodT typeIR_ret_subst)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:22.1-22.70
def $subst_routineTypeDef(set<pair<tid, typeIR>>', routineTypeDefIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return routineTypeDefIR

2. Otherwise

  1. Return $subst_routineTypeDef'(set<pair<tid, typeIR>>', routineTypeDefIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:23.1-23.71
def $subst_routineTypeDef'(theta, routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. Return ((MonoTD $subst_routineType'(theta, routineTypeIR)) as routineTypeDefIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let ({ tid_free*{tid_free <- tid_free*} }) be $diff_set<tid>($free_routineType(routineTypeIR), ({ tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*} })))

    3. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(theta, tid_free))*{tid_free <- tid_free*, typeIR? <- typeIR?*}

    4. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

      1. (Let ?(typeIR_free) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_free <- typeIR_free*}

      2. (Let bound_capture be $unions_set<tid>($free_type(typeIR_free)*{typeIR_free <- typeIR_free*}))

      3. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*}|))

      4. If (~$in_set<tid>(tid_fresh, bound_capture))*{tid_fresh <- tid_fresh*}, then

        1. (Let tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} be tid_fresh*{tid_fresh <- tid_fresh*}[0 : |tid*{tid <- tid*}|])

        2. (Let tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*} be tid_fresh*{tid_fresh <- tid_fresh*}[|tid*{tid <- tid*}| : |tid_hidden*{tid_hidden <- tid_hidden*}|])

        3. (Let theta' be $adds_map<tid, typeIR>(theta, tid*{tid <- tid*}, ((NameT tid_fresh_spec) as typeIR)*{tid_fresh_spec <- tid_fresh_spec*}))

        4. (Let theta'' be $adds_map<tid, typeIR>(theta', tid_hidden*{tid_hidden <- tid_hidden*}, ((NameT tid_fresh_hidden) as typeIR)*{tid_fresh_hidden <- tid_fresh_hidden*}))

        5. (Let routineTypeIR_subst be $subst_routineType(theta'', routineTypeIR))

        6. Return ((PolyTD routineTypeIR_subst tid_fresh_spec*{tid_fresh_spec <- tid_fresh_spec*} tid_fresh_hidden*{tid_fresh_hidden <- tid_fresh_hidden*}) as routineTypeDefIR)

      4. Else Phantom#5

    4. Else Phantom#6

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:24.1-24.73
def $subst_constructorType(set<pair<tid, typeIR>>', constructorTypeIR)

1. If ((set<pair<tid, typeIR>>' = ({ [] }))), then

  1. Return constructorTypeIR

2. Otherwise

  1. Return $subst_constructorType'(set<pair<tid, typeIR>>', constructorTypeIR)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:25.1-25.74
def $subst_constructorType'(theta, (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_obj))

1. (Let parameterTypeIR_subst be $subst_parameterType'(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*}

2. (Let typeIR_obj_subst be $subst_type'(theta, typeIR_obj))

3. Return (ConstructorT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR_obj_subst)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:561.1-561.53
def $specialize_typeDef(typeDefIR, typeIR''*{typeIR'' <- typeIR''*})

1. Case analysis on typeDefIR

  1. Case (% has type monoTypeDefIR)

    1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

    2. If ((typeIR''*{typeIR'' <- typeIR''*} matches pattern [])), then

      1. Return typeIR

    2. Else Phantom#7

  2. Case (% has type polyTypeDefIR)

    1. (Let (PolyTD typeIR_base tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (typeDefIR as polyTypeDefIR))

    2. (Let tid_tparam*{tid_tparam <- tid_tparam*} be tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*})

    3. (Let theta be ({ (tid_tparam -> typeIR'')*{tid_tparam <- tid_tparam*, typeIR'' <- typeIR''*} }))

    4. Return $subst_type(theta, typeIR_base)

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:574.1-575.26
def $specialize_routineTypeDef(routineTypeDefIR, typeIR'*{typeIR' <- typeIR'*})

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. If ((typeIR'*{typeIR' <- typeIR'*} matches pattern [])), then

      1. Return (routineTypeIR, [])

    2. Else Phantom#8

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. (Let tid_tparam*{tid_tparam <- tid_tparam*} be tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*})

    3. If ((|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR'*{typeIR' <- typeIR'*}|)), then

      1. (Let theta be ({ (tid_tparam -> typeIR')*{tid_tparam <- tid_tparam*, typeIR' <- typeIR'*} }))

      2. Return ($subst_routineType(theta, routineTypeIR), [])

    3. Else Phantom#9

    4. If (((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR'*{typeIR' <- typeIR'*}| = 0))), then

      1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|))

      2. (Let theta be ({ (tid_tparam -> ((NameT tid_fresh) as typeIR))*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }))

      3. Return ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})

    4. Else Phantom#10

    5. If ((((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR'*{typeIR' <- typeIR'*}|)) /\ (|typeIR'*{typeIR' <- typeIR'*}| > 0))), then

      1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|))

      2. (Let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} be typeIR'*{typeIR' <- typeIR'*} ++ ((NameT tid_fresh) as typeIR)*{tid_fresh <- tid_fresh*})

      3. (Let theta be ({ (tid_tparam -> typeIR_arg_new)*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }))

      4. Return ($subst_routineType(theta, routineTypeIR), tid_fresh*{tid_fresh <- tid_fresh*})

    5. Else Phantom#11

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:616.1-617.30
def $specialize_constructorTypeDef((PolyTD constructorTypeIR tid*{tid <- tid*} tid_hidden*{tid_hidden <- tid_hidden*}), typeIR_arg*{typeIR_arg <- typeIR_arg*})

1. (Let tid_tparam*{tid_tparam <- tid_tparam*} be tid*{tid <- tid*} ++ tid_hidden*{tid_hidden <- tid_hidden*})

2. If ((|tid_tparam*{tid_tparam <- tid_tparam*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)), then

  1. (Let theta be ({ (tid_tparam -> typeIR_arg)*{tid_tparam <- tid_tparam*, typeIR_arg <- typeIR_arg*} }))

  2. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  3. Return (constructorTypeIR_subst, [])

2. Else Phantom#12

3. If (((|tid_tparam*{tid_tparam <- tid_tparam*}| > 0) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| = 0))), then

  1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid_tparam*{tid_tparam <- tid_tparam*}|))

  2. (Let theta be ({ (tid_tparam -> ((NameT tid_fresh) as typeIR))*{tid_fresh <- tid_fresh*, tid_tparam <- tid_tparam*} }))

  3. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  4. Return (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})

3. Else Phantom#13

4. If ((((|tid_hidden*{tid_hidden <- tid_hidden*}| > 0) /\ (|tid*{tid <- tid*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)) /\ (|typeIR_arg*{typeIR_arg <- typeIR_arg*}| > 0))), then

  1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids(|tid_hidden*{tid_hidden <- tid_hidden*}|))

  2. (Let typeIR_arg_new*{typeIR_arg_new <- typeIR_arg_new*} be typeIR_arg*{typeIR_arg <- typeIR_arg*} ++ ((NameT tid_fresh) as typeIR)*{tid_fresh <- tid_fresh*})

  3. (Let theta be ({ (tid_tparam -> typeIR_arg_new)*{tid_tparam <- tid_tparam*, typeIR_arg_new <- typeIR_arg_new*} }))

  4. (Let constructorTypeIR_subst be $subst_constructorType(theta, constructorTypeIR))

  5. Return (constructorTypeIR_subst, tid_fresh*{tid_fresh <- tid_fresh*})

4. Else Phantom#14

;; ../../../../spec-concrete/2.2.3-type-subst.watsup:662.1-662.28
def $canon(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `SpecT%%`)), then

      1. (Let (SpecT polyTypeDefIR typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

      2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*{typeIR_arg <- typeIR_arg*}))

      3. Return $canon(typeIR)

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `DefT%%`)), then

      1. (Let (DefT _tid typeIR) be aliasTypeIR)

      2. Return $canon(typeIR)

2. Otherwise

  1. Return typeIR''

;; ../../../../spec-concrete/2.2.4-type-util.watsup:7.1-7.38
def $is_nominal_typeIR(typeIR)

1. Return $is_nominal_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:8.1-8.39
def $is_nominal_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `DefT%%`)), then

      1. (Let (DefT _tid _typeIR) be aliasTypeIR)

      2. Return true

  2. Case (% has type structTypeIR)

    1. (Let (StructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as structTypeIR))

    2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerTypeIR))

    2. Return true

  4. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerUnionTypeIR))

    2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

  6. Case (% has type externObjectTypeIR)

    1. (Let (ExternT _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return true

  7. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:25.1-25.42
def $is_defaultable_typeIR(typeIR)

1. Return $is_defaultable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:26.1-26.43
def $is_defaultable_typeIR'(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

      3. Case (% matches pattern `StrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `DefT%%`)), then

      1. (Let (DefT _tid typeIR) be aliasTypeIR)

      2. Return $is_defaultable_typeIR(typeIR)

  4. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. If ($is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  5. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR _nat) be (typeIR'' as headerStackTypeIR))

    2. Return $is_defaultable_typeIR(typeIR)

  6. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. If ($is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  7. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerTypeIR))

    2. If ($is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  8. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. If ($is_defaultable_typeIR(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  9. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return $is_defaultable_typeIR(typeIR)

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/2.2.4-type-util.watsup:54.1-54.40
def $is_equalable_typeIR(typeIR)

1. Return $is_equalable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:55.1-55.41
def $is_equalable_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `VoidT`)), then

      1. Return false

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return false

  3. Case (% has type externObjectTypeIR)

    1. (Let (ExternT _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return false

  4. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as parserObjectTypeIR))

    2. Return false

  5. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as controlObjectTypeIR))

    2. Return false

  6. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR as packageObjectTypeIR))

    2. Return false

  7. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return false

  8. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR as defaultTypeIR))

    2. Return false

  9. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SeqDefaultT%`)), then

      1. (Let (SeqDefaultT _typeIR*{_typeIR <- _typeIR*}) be sequenceTypeIR)

      2. Return false

  10. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. If ((recordTypeIR matches pattern `RecordDefaultT%`)), then

      1. (Let (RecordDefaultT _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be recordTypeIR)

      2. Return false

  11. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR as invalidHeaderTypeIR))

    2. Return false

  12. Case (% has type setTypeIR)

    1. (Let (SetT _typeIR) be (typeIR as setTypeIR))

    2. Return false

  13. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _tid _id*{_id <- _id*}) be tableTypeIR)

        2. Return false

      2. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be tableTypeIR)

        2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.4-type-util.watsup:78.1-78.41
def $is_assignable_typeIR(typeIR)

1. Return $is_assignable_typeIR'($canon(typeIR))

;; ../../../../spec-concrete/2.2.4-type-util.watsup:79.1-79.42
def $is_assignable_typeIR'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `VoidT`)

        1. Return false

      2. Case (% matches pattern `StrT`)

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR as objectTypeIR))

    2. Return false

  4. Case (% has type synthesizedTypeIR)

    1. (Let synthesizedTypeIR be (typeIR as synthesizedTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:5.1-7.20
relation Type_alpha: typeIR'', typeIR'''

1. Case analysis on typeIR''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'' as baseTypeIR))

    2. If ((typeIR''' has type baseTypeIR)), then

      1. (Let baseTypeIR' be (typeIR''' as baseTypeIR))

      2. If ((baseTypeIR = baseTypeIR')), then

        1. The relation holds

      2. Else Phantom#15

    2. Else Phantom#16

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `NameT%`)

        1. (Let (NameT tid) be namedTypeIR)

        2. If ((typeIR''' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR''' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `NameT%`)), then

            1. (Let (NameT tid') be namedTypeIR')

            2. If ((tid = tid')), then

              1. The relation holds

            2. Else Phantom#17

          2. Else Phantom#18

        2. Else Phantom#19

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT polyTypeDefIR_a typeIR_a*{typeIR_a <- typeIR_a*}) be namedTypeIR)

        2. If ((typeIR''' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR''' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `SpecT%%`)), then

            1. (Let (SpecT polyTypeDefIR_b typeIR_b*{typeIR_b <- typeIR_b*}) be namedTypeIR')

            2. (Let typeIR_a_spec be $specialize_typeDef((polyTypeDefIR_a as typeDefIR), typeIR_a*{typeIR_a <- typeIR_a*}))

            3. (Let typeIR_b_spec be $specialize_typeDef((polyTypeDefIR_b as typeDefIR), typeIR_b*{typeIR_b <- typeIR_b*}))

            4. If ((Type_alpha: typeIR_a_spec ~~ typeIR_b_spec holds)), then

              1. If (($is_nominal_typeIR(typeIR_a_spec) /\ $is_nominal_typeIR(typeIR_b_spec))), then

                1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

                  1. The relation holds

                1. Else Phantom#20

              1. Else Phantom#21

              2. If ((~$is_nominal_typeIR(typeIR_a_spec) /\ ~$is_nominal_typeIR(typeIR_b_spec))), then

                1. The relation holds

              2. Else Phantom#22

            4. Else Phantom#23

          2. Else Phantom#24

        2. Else Phantom#25

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `DefT%%`)

        1. (Let (DefT _tid typeIR_a) be aliasTypeIR)

        2. If ((Type_alpha: typeIR_a ~~ typeIR''' holds)), then

          1. The relation holds

        2. Else Phantom#26

      2. Case (% matches pattern `NewT%%`)

        1. (Let (NewT tid typeIR_a) be aliasTypeIR)

        2. If ((typeIR''' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR''' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `NewT%%`)), then

            1. (Let (NewT tid' typeIR_b) be aliasTypeIR')

            2. If ((tid = tid')), then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

                1. The relation holds

              1. Else Phantom#27

            2. Else Phantom#28

          2. Else Phantom#29

        2. Else Phantom#30

  4. Case (% has type listTypeIR)

    1. (Let (ListT typeIR_a) be (typeIR'' as listTypeIR))

    2. If ((typeIR''' has type listTypeIR)), then

      1. (Let (ListT typeIR_b) be (typeIR''' as listTypeIR))

      2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#31

    2. Else Phantom#32

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR_a*{typeIR_a <- typeIR_a*}) be (typeIR'' as tupleTypeIR))

    2. If ((typeIR''' has type tupleTypeIR)), then

      1. (Let (TupleT typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR''' as tupleTypeIR))

      2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

        1. The relation holds

      2. Else Phantom#33

    2. Else Phantom#34

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR_a n_s) be (typeIR'' as headerStackTypeIR))

    2. If ((typeIR''' has type headerStackTypeIR)), then

      1. (Let (HeaderStackT typeIR_b n_s') be (typeIR''' as headerStackTypeIR))

      2. If ((n_s = n_s')), then

        1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

          1. The relation holds

        1. Else Phantom#35

      2. Else Phantom#36

    2. Else Phantom#37

  7. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_f_a id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) be (typeIR'' as structTypeIR))

    2. If ((typeIR''' has type structTypeIR)), then

      1. (Let (StructT tid' (typeIR_f_b id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) be (typeIR''' as structTypeIR))

      2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}, then

            1. The relation holds

          1. Else Phantom#38

        1. Else Phantom#39

      2. Else Phantom#40

    2. Else Phantom#41

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_f_a id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) be (typeIR'' as headerTypeIR))

    2. If ((typeIR''' has type headerTypeIR)), then

      1. (Let (HeaderT tid' (typeIR_f_b id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) be (typeIR''' as headerTypeIR))

      2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}, then

            1. The relation holds

          1. Else Phantom#42

        1. Else Phantom#43

      2. Else Phantom#44

    2. Else Phantom#45

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT tid (typeIR_f_a id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) be (typeIR'' as headerUnionTypeIR))

    2. If ((typeIR''' has type headerUnionTypeIR)), then

      1. (Let (HeaderUnionT tid' (typeIR_f_b id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) be (typeIR''' as headerUnionTypeIR))

      2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

        1. If ((tid = tid')), then

          1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}, then

            1. The relation holds

          1. Else Phantom#46

        1. Else Phantom#47

      2. Else Phantom#48

    2. Else Phantom#49

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT tid id_f*{id_f <- id_f*}) be enumTypeIR)

        2. If ((typeIR''' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR''' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `EnumT%%`)), then

            1. (Let (EnumT tid' id_f'*{id_f' <- id_f'*}) be enumTypeIR')

            2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

              1. If ((tid = tid')), then

                1. The relation holds

              1. Else Phantom#50

            2. Else Phantom#51

          2. Else Phantom#52

        2. Else Phantom#53

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT tid typeIR_a (id_f value_f)*{id_f <- id_f*, value_f <- value_f*}) be enumTypeIR)

        2. If ((typeIR''' has type enumTypeIR)), then

          1. (Let enumTypeIR' be (typeIR''' as enumTypeIR))

          2. If ((enumTypeIR' matches pattern `SEnumT%%%`)), then

            1. (Let (SEnumT tid' typeIR_b (id_f' value_f')*{id_f' <- id_f'*, value_f' <- value_f'*}) be enumTypeIR')

            2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

              1. If ((tid = tid')), then

                1. If ((value_f = value_f'))*{value_f <- value_f*, value_f' <- value_f'*}, then

                  1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

                    1. The relation holds

                  1. Else Phantom#54

                1. Else Phantom#55

              1. Else Phantom#56

            2. Else Phantom#57

          2. Else Phantom#58

        2. Else Phantom#59

  11. Case (% has type externObjectTypeIR)

    1. (Let (ExternT tid ({ (rid_a -> routineTypeDefIR_a)*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} })) be (typeIR'' as externObjectTypeIR))

    2. If ((typeIR''' has type externObjectTypeIR)), then

      1. (Let (ExternT tid' ({ (rid_b -> routineTypeDefIR_b)*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} })) be (typeIR''' as externObjectTypeIR))

      2. If ((tid = tid')), then

        1. If ($eq_set<rid>(({ rid_a*{rid_a <- rid_a*} }), ({ rid_b*{rid_b <- rid_b*} }))), then

          1. (Let routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} be $find_map<rid, routineTypeDefIR>(({ (rid_a -> routineTypeDefIR_a)*{rid_a <- rid_a*, routineTypeDefIR_a <- routineTypeDefIR_a*} }), rid_a))*{rid_a <- rid_a*, routineTypeDefIR? <- routineTypeDefIR?*}

          2. If ((routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?} matches pattern (_)))*{routineTypeDefIR? <- routineTypeDefIR?*}, then

            1. (Let ?(routineTypeDefIR_a') be routineTypeDefIR?{routineTypeDefIR <- routineTypeDefIR?})*{routineTypeDefIR? <- routineTypeDefIR?*, routineTypeDefIR_a' <- routineTypeDefIR_a'*}

            2. (Let routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} be $find_map<rid, routineTypeDefIR>(({ (rid_b -> routineTypeDefIR_b)*{rid_b <- rid_b*, routineTypeDefIR_b <- routineTypeDefIR_b*} }), rid_a))*{rid_a <- rid_a*, routineTypeDefIR'? <- routineTypeDefIR'?*}

            3. If ((routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?} matches pattern (_)))*{routineTypeDefIR'? <- routineTypeDefIR'?*}, then

              1. (Let ?(routineTypeDefIR_b') be routineTypeDefIR'?{routineTypeDefIR' <- routineTypeDefIR'?})*{routineTypeDefIR'? <- routineTypeDefIR'?*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}

              2. If ((RoutineTypeDef_alpha: routineTypeDefIR_a' ~~ routineTypeDefIR_b' holds))*{routineTypeDefIR_a' <- routineTypeDefIR_a'*, routineTypeDefIR_b' <- routineTypeDefIR_b'*}, then

                1. The relation holds

              2. Else Phantom#60

            3. Else Phantom#61

          2. Else Phantom#62

        1. Else Phantom#63

      2. Else Phantom#64

    2. Else Phantom#65

  12. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) be (typeIR'' as parserObjectTypeIR))

    2. If ((typeIR''' has type parserObjectTypeIR)), then

      1. (Let (ParserT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) be (typeIR''' as parserObjectTypeIR))

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. The relation holds

      2. Else Phantom#66

    2. Else Phantom#67

  13. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) be (typeIR'' as controlObjectTypeIR))

    2. If ((typeIR''' has type controlObjectTypeIR)), then

      1. (Let (ControlT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) be (typeIR''' as controlObjectTypeIR))

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. The relation holds

      2. Else Phantom#68

    2. Else Phantom#69

  14. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT tid typeIR_a*{typeIR_a <- typeIR_a*}) be (typeIR'' as packageObjectTypeIR))

    2. If ((typeIR''' has type packageObjectTypeIR)), then

      1. (Let (PackageT tid' typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR''' as packageObjectTypeIR))

      2. If ((tid = tid')), then

        1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

          1. The relation holds

        1. Else Phantom#70

      2. Else Phantom#71

    2. Else Phantom#72

  15. Case (% has type tableObjectTypeIR)

    1. (Let (TableT tid typeIR_a) be (typeIR'' as tableObjectTypeIR))

    2. If ((typeIR''' has type tableObjectTypeIR)), then

      1. (Let (TableT tid' typeIR_b) be (typeIR''' as tableObjectTypeIR))

      2. If ((tid = tid')), then

        1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

          1. The relation holds

        1. Else Phantom#73

      2. Else Phantom#74

    2. Else Phantom#75

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR'' as defaultTypeIR))

    2. If ((typeIR''' has type defaultTypeIR)), then

      1. (Let defaultTypeIR' be (typeIR''' as defaultTypeIR))

      2. The relation holds

    2. Else Phantom#76

  17. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. If ((typeIR''' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR''' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SeqT%`)), then

            1. (Let (SeqT typeIR_b*{typeIR_b <- typeIR_b*}) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#77

          2. Else Phantom#78

        2. Else Phantom#79

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. If ((typeIR''' has type sequenceTypeIR)), then

          1. (Let sequenceTypeIR' be (typeIR''' as sequenceTypeIR))

          2. If ((sequenceTypeIR' matches pattern `SeqDefaultT%`)), then

            1. (Let (SeqDefaultT typeIR_b*{typeIR_b <- typeIR_b*}) be sequenceTypeIR')

            2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#80

          2. Else Phantom#81

        2. Else Phantom#82

  18. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR'' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR_a id)*{id <- id*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. If ((typeIR''' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR''' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RecordT%`)), then

            1. (Let (RecordT (typeIR_b id')*{id' <- id'*, typeIR_b <- typeIR_b*}) be recordTypeIR')

            2. If ((id = id'))*{id <- id*, id' <- id'*}, then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

                1. The relation holds

              1. Else Phantom#83

            2. Else Phantom#84

          2. Else Phantom#85

        2. Else Phantom#86

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR_a id)*{id <- id*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. If ((typeIR''' has type recordTypeIR)), then

          1. (Let recordTypeIR' be (typeIR''' as recordTypeIR))

          2. If ((recordTypeIR' matches pattern `RecordDefaultT%`)), then

            1. (Let (RecordDefaultT (typeIR_b id')*{id' <- id'*, typeIR_b <- typeIR_b*}) be recordTypeIR')

            2. If ((id = id'))*{id <- id*, id' <- id'*}, then

              1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

                1. The relation holds

              1. Else Phantom#87

            2. Else Phantom#88

          2. Else Phantom#89

        2. Else Phantom#90

  19. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR'' as invalidHeaderTypeIR))

    2. If ((typeIR''' has type invalidHeaderTypeIR)), then

      1. (Let invalidHeaderTypeIR' be (typeIR''' as invalidHeaderTypeIR))

      2. The relation holds

    2. Else Phantom#91

  20. Case (% has type setTypeIR)

    1. (Let (SetT typeIR_a) be (typeIR'' as setTypeIR))

    2. If ((typeIR''' has type setTypeIR)), then

      1. (Let (SetT typeIR_b) be (typeIR''' as setTypeIR))

      2. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#92

    2. Else Phantom#93

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT tid id_f*{id_f <- id_f*}) be tableTypeIR)

        2. If ((typeIR''' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR''' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TableEnumT%%`)), then

            1. (Let (TableEnumT tid' id_f'*{id_f' <- id_f'*}) be tableTypeIR')

            2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

              1. If ((tid = tid')), then

                1. The relation holds

              1. Else Phantom#94

            2. Else Phantom#95

          2. Else Phantom#96

        2. Else Phantom#97

      2. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT tid (typeIR_f_a id_f)*{id_f <- id_f*, typeIR_f_a <- typeIR_f_a*}) be tableTypeIR)

        2. If ((typeIR''' has type tableTypeIR)), then

          1. (Let tableTypeIR' be (typeIR''' as tableTypeIR))

          2. If ((tableTypeIR' matches pattern `TableStructT%%`)), then

            1. (Let (TableStructT tid' (typeIR_f_b id_f')*{id_f' <- id_f'*, typeIR_f_b <- typeIR_f_b*}) be tableTypeIR')

            2. If ((id_f = id_f'))*{id_f <- id_f*, id_f' <- id_f'*}, then

              1. If ((tid = tid')), then

                1. If ((Type_alpha: typeIR_f_a ~~ typeIR_f_b holds))*{typeIR_f_a <- typeIR_f_a*, typeIR_f_b <- typeIR_f_b*}, then

                  1. The relation holds

                1. Else Phantom#98

              1. Else Phantom#99

            2. Else Phantom#100

          2. Else Phantom#101

        2. Else Phantom#102

2. If ((typeIR''' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `DefT%%`)), then

    1. (Let (DefT _tid typeIR_b) be aliasTypeIR)

    2. If ((Type_alpha: typeIR'' ~~ typeIR_b holds)), then

      1. The relation holds

    2. Else Phantom#103

  2. Else Phantom#104

2. Else Phantom#105

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:9.1-11.20
relation ParameterType_alpha: (_direction typeIR_a _id _value?{_value <- _value?}), (_direction' typeIR_b _id' _value'?{_value' <- _value'?})

1. If ((Type_alpha: typeIR_a ~~ typeIR_b holds)), then

  1. The relation holds

1. Else Phantom#106

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:13.1-15.20
relation RoutineType_alpha: routineTypeIR, routineTypeIR'

1. Case analysis on routineTypeIR

  1. Case (% matches pattern `BuiltinFuncT%%`)

    1. (Let (BuiltinFuncT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `BuiltinFuncT%%`)), then

      1. (Let (BuiltinFuncT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#107

      2. Else Phantom#108

    2. Else Phantom#109

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `FuncT%%`)), then

      1. (Let (FuncT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#110

      2. Else Phantom#111

    2. Else Phantom#112

  3. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ActionT%`)), then

      1. (Let (ActionT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. The relation holds

      2. Else Phantom#113

    2. Else Phantom#114

  4. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ExternFuncT%%`)), then

      1. (Let (ExternFuncT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#115

      2. Else Phantom#116

    2. Else Phantom#117

  5. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `BuiltinMethodT%%`)), then

      1. (Let (BuiltinMethodT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#118

      2. Else Phantom#119

    2. Else Phantom#120

  6. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ExternMethodT%%`)), then

      1. (Let (ExternMethodT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#121

      2. Else Phantom#122

    2. Else Phantom#123

  7. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*} typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ExternAbstractMethodT%%`)), then

      1. (Let (ExternAbstractMethodT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*} typeIR_ret_b) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

          1. The relation holds

        1. Else Phantom#124

      2. Else Phantom#125

    2. Else Phantom#126

  8. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ParserApplyMethodT%`)), then

      1. (Let (ParserApplyMethodT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. The relation holds

      2. Else Phantom#127

    2. Else Phantom#128

  9. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT parameterTypeIR_a*{parameterTypeIR_a <- parameterTypeIR_a*}) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `ControlApplyMethodT%`)), then

      1. (Let (ControlApplyMethodT parameterTypeIR_b*{parameterTypeIR_b <- parameterTypeIR_b*}) be routineTypeIR')

      2. If ((ParameterType_alpha: parameterTypeIR_a ~~ parameterTypeIR_b holds))*{parameterTypeIR_a <- parameterTypeIR_a*, parameterTypeIR_b <- parameterTypeIR_b*}, then

        1. The relation holds

      2. Else Phantom#129

    2. Else Phantom#130

  10. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typeIR_ret_a) be routineTypeIR)

    2. If ((routineTypeIR' matches pattern `TableApplyMethodT%`)), then

      1. (Let (TableApplyMethodT typeIR_ret_b) be routineTypeIR')

      2. If ((Type_alpha: typeIR_ret_a ~~ typeIR_ret_b holds)), then

        1. The relation holds

      2. Else Phantom#131

    2. Else Phantom#132

;; ../../../../spec-concrete/2.2.5-type-alpha.watsup:17.1-19.20
relation RoutineTypeDef_alpha: routineTypeDefIR, routineTypeDefIR'

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR_a) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. If ((routineTypeDefIR' has type monoRoutineTypeDefIR)), then

      1. (Let (MonoTD routineTypeIR_b) be (routineTypeDefIR' as monoRoutineTypeDefIR))

      2. If ((RoutineType_alpha: routineTypeIR_a ~~ routineTypeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#133

    2. Else Phantom#134

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR_a tid_a*{tid_a <- tid_a*} tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (PolyTD routineTypeIR_b tid_b*{tid_b <- tid_b*} tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((|tid_a*{tid_a <- tid_a*}| = |tid_b*{tid_b <- tid_b*}|)), then

        1. If ((|tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}| = |tid_hidden_b*{tid_hidden_b <- tid_hidden_b*}|)), then

          1. (Let tid_fresh*{tid_fresh <- tid_fresh*} be $fresh_tids((|tid_a*{tid_a <- tid_a*}| + |tid_hidden_a*{tid_hidden_a <- tid_hidden_a*}|)))

          2. (Let tid_a'*{tid_a' <- tid_a'*} be tid_a*{tid_a <- tid_a*} ++ tid_hidden_a*{tid_hidden_a <- tid_hidden_a*})

          3. (Let theta_a be ({ (tid_a' -> ((NameT tid_fresh) as typeIR))*{tid_a' <- tid_a'*, tid_fresh <- tid_fresh*} }))

          4. (Let routineTypeIR_a_subst be $subst_routineType(theta_a, routineTypeIR_a))

          5. (Let tid_b'*{tid_b' <- tid_b'*} be tid_b*{tid_b <- tid_b*} ++ tid_hidden_b*{tid_hidden_b <- tid_hidden_b*})

          6. (Let theta_b be ({ (tid_b' -> ((NameT tid_fresh) as typeIR))*{tid_b' <- tid_b'*, tid_fresh <- tid_fresh*} }))

          7. (Let routineTypeIR_b_subst be $subst_routineType(theta_b, routineTypeIR_b))

          8. If ((RoutineType_alpha: routineTypeIR_a_subst ~~ routineTypeIR_b_subst holds)), then

            1. The relation holds

          8. Else Phantom#135

        1. Else Phantom#136

      2. Else Phantom#137

    2. Else Phantom#138

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:5.14-5.30
syntax ctk = 
   | `LCTK`()
   | `CTK`()
   | `DYN`()

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:7.1-7.30
def $join_ctk(ctk'', ctk''')

1. Case analysis on ctk''

  1. Case (% matches pattern `LCTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (LCTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

  2. Case (% matches pattern `CTK`)

    1. Case analysis on ctk'''

      1. Case (% matches pattern `LCTK`)

        1. Return (CTK)

      2. Case (% matches pattern `CTK`)

        1. Return (CTK)

2. Otherwise

  1. Return (DYN)

;; ../../../../spec-concrete/2.3-compile-time-known.watsup:16.1-16.27
def $joins_ctk(ctk*{ctk <- ctk*})

1. Case analysis on ctk*{ctk <- ctk*}

  1. Case (% matches pattern [])

    1. Return (LCTK)

  2. Case (% matches pattern _ :: _)

    1. (Let ctk_h :: ctk_t*{ctk_t <- ctk_t*} be ctk*{ctk <- ctk*})

    2. Return $join_ctk(ctk_h, $joins_ctk(ctk_t*{ctk_t <- ctk_t*}))

;; ../../../../spec-concrete/3-numerics.watsup:5.1-5.21
def $pow2



;; ../../../../spec-concrete/3-numerics.watsup:7.1-7.25
def $shl



;; ../../../../spec-concrete/3-numerics.watsup:8.1-8.25
def $shr



;; ../../../../spec-concrete/3-numerics.watsup:9.1-9.36
def $shr_arith



;; ../../../../spec-concrete/3-numerics.watsup:11.1-11.21
def $bneg



;; ../../../../spec-concrete/3-numerics.watsup:12.1-12.26
def $band



;; ../../../../spec-concrete/3-numerics.watsup:13.1-13.26
def $bxor



;; ../../../../spec-concrete/3-numerics.watsup:14.1-14.25
def $bor



;; ../../../../spec-concrete/3-numerics.watsup:16.1-16.33
def $bitacc



;; ../../../../spec-concrete/3-numerics.watsup:24.1-24.28
def $un_bnot(value)

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `FBitV%%`)), then

    1. (Let (FBitV w i) be numberValue)

    2. (Let i' be $bneg(i))

    3. Return ((FBitV w i') as value)

  2. Else Phantom#139

1. Else Phantom#140

;; ../../../../spec-concrete/3-numerics.watsup:31.1-31.28
def $un_lnot(value)

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `BoolV%`)), then

    1. (Let (BoolV b) be primitiveValue)

    2. Return ((BoolV ~b) as value)

  2. Else Phantom#141

1. Else Phantom#142

;; ../../../../spec-concrete/3-numerics.watsup:37.1-37.28
def $un_plus(value)

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i) be numberValue)

      2. Return ((IntV i) as value)

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i) be numberValue)

      2. Return ((FBitV w i) as value)

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i) be numberValue)

      2. Return ((FIntV w i) as value)

  2. Else Phantom#143

1. Else Phantom#144

;; ../../../../spec-concrete/3-numerics.watsup:45.1-45.29
def $un_minus(value)

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i) be numberValue)

      2. Return ((IntV -i) as value)

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i) be numberValue)

      2. (Let i' be ($pow2(w) - i))

      3. Return ((FBitV w i') as value)

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i) be numberValue)

      2. (Let i' be $to_bitstr((w as int), $to_int((w as int), -i)))

      3. Return ((FIntV w i') as value)

  2. Else Phantom#145

1. Else Phantom#146

;; ../../../../spec-concrete/3-numerics.watsup:59.1-59.36
def $bin_plus(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return ((IntV (i_l + i_r)) as value)

        2. Else Phantom#147

      2. Else Phantom#148

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((FBitV w i') as value)

          2. Else Phantom#149

        2. Else Phantom#150

      2. Else Phantom#151

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' + i_r')))

            4. Return ((FIntV w i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            6. Return ((FIntV w i') as value)

            7. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            8. Return ((FIntV w i') as value)

          2. Else Phantom#152

        2. Else Phantom#153

      2. Else Phantom#154

  2. Else Phantom#155

1. Else Phantom#156

;; ../../../../spec-concrete/3-numerics.watsup:73.1-73.39
def $bin_satplus



;; ../../../../spec-concrete/3-numerics.watsup:77.1-77.37
def $bin_minus(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return ((IntV (i_l - i_r)) as value)

        2. Else Phantom#157

      2. Else Phantom#158

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), (i_l' - i_r')))

            4. Return ((FBitV w i') as value)

            5. (Let i' be $to_bitstr((w as int), (i_l' * i_r')))

            6. Return ((FBitV w i') as value)

          2. Else Phantom#159

        2. Else Phantom#160

      2. Else Phantom#161

  2. Else Phantom#162

1. Else Phantom#163

;; ../../../../spec-concrete/3-numerics.watsup:91.1-91.40
def $bin_satminus



;; ../../../../spec-concrete/3-numerics.watsup:95.1-95.35
def $bin_mul(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `IntV%`)), then

    1. (Let (IntV i_l) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `IntV%`)), then

        1. (Let (IntV i_r) be numberValue')

        2. Return ((IntV (i_l * i_r)) as value)

      2. Else Phantom#164

    2. Else Phantom#165

  2. Else Phantom#166

1. Else Phantom#167

;; ../../../../spec-concrete/3-numerics.watsup:109.1-109.35
def $bin_div(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `IntV%`)), then

    1. (Let (IntV i_l) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `IntV%`)), then

        1. (Let (IntV i_r) be numberValue')

        2. Return ((IntV (i_l / i_r)) as value)

      2. Else Phantom#168

    2. Else Phantom#169

  2. Else Phantom#170

1. Else Phantom#171

;; ../../../../spec-concrete/3-numerics.watsup:115.1-115.35
def $bin_mod(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `IntV%`)), then

    1. (Let (IntV i_l) be numberValue)

    2. If ((value' has type numberValue)), then

      1. (Let numberValue' be (value' as numberValue))

      2. If ((numberValue' matches pattern `IntV%`)), then

        1. (Let (IntV i_r) be numberValue')

        2. Return ((IntV (i_l \ i_r)) as value)

      2. Else Phantom#172

    2. Else Phantom#173

  2. Else Phantom#174

1. Else Phantom#175

;; ../../../../spec-concrete/3-numerics.watsup:121.1-121.35
def $bin_shl(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. Return ((IntV $shl(i_l, i_r)) as value)

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. Return ((IntV $shl(i_l, i_r)) as value)

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((IntV $shl(i_l, i_r')) as value)

        2. Else Phantom#176

      2. Else Phantom#177

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. Return $bin_shl(((FBitV w_l i_l) as value), ((FBitV w_l $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r)))

            3. Return ((FBitV w_l i') as value)

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l, i_r')))

            4. Return ((FBitV w_l i') as value)

        2. Else Phantom#178

      2. Else Phantom#179

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. Return $bin_shl(((FIntV w_l i_l) as value), ((FIntV w_l $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r)))

            4. Return ((FIntV w_l i') as value)

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. (Let i' be $to_bitstr((w_l as int), $shl(i_l', i_r')))

            5. Return ((FIntV w_l i') as value)

        2. Else Phantom#180

      2. Else Phantom#181

  2. Else Phantom#182

1. Else Phantom#183

;; ../../../../spec-concrete/3-numerics.watsup:148.1-148.35
def $bin_shr(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. Return ((IntV $shr(i_l, i_r)) as value)

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. Return ((IntV $shr(i_l, i_r)) as value)

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. Return ((IntV $shr(i_l, i_r')) as value)

        2. Else Phantom#184

      2. Else Phantom#185

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. Return $bin_shr(((FBitV w_l i_l) as value), ((FBitV w_l $to_int((w_l as int), i_r)) as value))

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r)))

            3. Return ((FBitV w_l i') as value)

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_r' be $to_int((w_r as int), i_r))

            3. (Let i' be $to_bitstr((w_l as int), $shr(i_l, i_r')))

            4. Return ((FBitV w_l i') as value)

        2. Else Phantom#186

      2. Else Phantom#187

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `IntV%`)

            1. (Let (IntV i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            3. Else Phantom#188

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            4. Else Phantom#189

          2. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            3. Else Phantom#190

            4. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            4. Else Phantom#191

          3. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_r' be $to_int((w_r as int), i_r))

            4. If ((i_l' < (0 as int))), then

              1. (Let i' be $shr_arith(i_l, i_r, ($pow2(w_l) - (1 as int))))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            4. Else Phantom#192

            5. If ((i_l' >= (0 as int))), then

              1. (Let i' be $shr(i_l, i_r))

              2. (Let i'' be $to_bitstr((w_l as int), i'))

              3. Return ((FIntV w_l i'') as value)

            5. Else Phantom#193

        2. Else Phantom#194

      2. Else Phantom#195

  2. Else Phantom#196

1. Else Phantom#197

;; ../../../../spec-concrete/3-numerics.watsup:198.1-198.33
def $bin_le(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return (i_l <= i_r)

        2. Else Phantom#198

      2. Else Phantom#199

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. Return (i_l <= i_r)

          2. Else Phantom#200

        2. Else Phantom#201

      2. Else Phantom#202

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' <= i_r')

          2. Else Phantom#203

        2. Else Phantom#204

      2. Else Phantom#205

  2. Else Phantom#206

1. Else Phantom#207

;; ../../../../spec-concrete/3-numerics.watsup:208.1-208.33
def $bin_ge(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return (i_l >= i_r)

        2. Else Phantom#208

      2. Else Phantom#209

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. Return (i_l >= i_r)

          2. Else Phantom#210

        2. Else Phantom#211

      2. Else Phantom#212

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' >= i_r')

          2. Else Phantom#213

        2. Else Phantom#214

      2. Else Phantom#215

  2. Else Phantom#216

1. Else Phantom#217

;; ../../../../spec-concrete/3-numerics.watsup:218.1-218.33
def $bin_lt(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return (i_l < i_r)

        2. Else Phantom#218

      2. Else Phantom#219

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. Return (i_l < i_r)

          2. Else Phantom#220

        2. Else Phantom#221

      2. Else Phantom#222

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' < i_r')

          2. Else Phantom#223

        2. Else Phantom#224

      2. Else Phantom#225

  2. Else Phantom#226

1. Else Phantom#227

;; ../../../../spec-concrete/3-numerics.watsup:228.1-228.33
def $bin_gt(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `IntV%`)

      1. (Let (IntV i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `IntV%`)), then

          1. (Let (IntV i_r) be numberValue')

          2. Return (i_l > i_r)

        2. Else Phantom#228

      2. Else Phantom#229

    2. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. Return (i_l > i_r)

          2. Else Phantom#230

        2. Else Phantom#231

      2. Else Phantom#232

    3. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. Return (i_l' > i_r')

          2. Else Phantom#233

        2. Else Phantom#234

      2. Else Phantom#235

  2. Else Phantom#236

1. Else Phantom#237

;; ../../../../spec-concrete/3-numerics.watsup:238.1-238.33
def $bin_eq(value, value')

1. Case analysis on value

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue_a be (value as primitiveValue))

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue_b be (value' as primitiveValue))

      2. Return (primitiveValue_a = primitiveValue_b)

    2. Else Phantom#238

  2. Case (% has type numberValue)

    1. (Let numberValue be (value as numberValue))

    2. Case analysis on numberValue

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i_a) be numberValue)

        2. If ((value' has type numberValue)), then

          1. (Let numberValue' be (value' as numberValue))

          2. If ((numberValue' matches pattern `IntV%`)), then

            1. (Let (IntV i_b) be numberValue')

            2. Return (i_a = i_b)

          2. Else Phantom#239

        2. Else Phantom#240

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w_a i_a) be numberValue)

        2. If ((value' has type numberValue)), then

          1. (Let numberValue' be (value' as numberValue))

          2. If ((numberValue' matches pattern `FBitV%%`)), then

            1. (Let (FBitV w_b i_b) be numberValue')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

          2. Else Phantom#241

        2. Else Phantom#242

      3. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w_a i_a) be numberValue)

        2. If ((value' has type numberValue)), then

          1. (Let numberValue' be (value' as numberValue))

          2. If ((numberValue' matches pattern `FIntV%%`)), then

            1. (Let (FIntV w_b i_b) be numberValue')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

          2. Else Phantom#243

        2. Else Phantom#244

      4. Case (% matches pattern `VBitV%%%`)

        1. (Let (VBitV w_a _width i_a) be numberValue)

        2. If ((value' has type numberValue)), then

          1. (Let numberValue' be (value' as numberValue))

          2. If ((numberValue' matches pattern `VBitV%%%`)), then

            1. (Let (VBitV w_b _width' i_b) be numberValue')

            2. Return ((w_a = w_b) /\ (i_a = i_b))

          2. Else Phantom#245

        2. Else Phantom#246

  3. Case (% has type listValue)

    1. (Let (ListV value_a*{value_a <- value_a*}) be (value as listValue))

    2. If ((value' has type listValue)), then

      1. (Let (ListV value_b*{value_b <- value_b*}) be (value' as listValue))

      2. Return $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})

    2. Else Phantom#247

  4. Case (% has type tupleValue)

    1. (Let (TupleV value_a*{value_a <- value_a*}) be (value as tupleValue))

    2. If ((value' has type tupleValue)), then

      1. (Let (TupleV value_b*{value_b <- value_b*}) be (value' as tupleValue))

      2. Return $bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*})

    2. Else Phantom#248

  5. Case (% has type headerStackValue)

    1. (Let (HeaderStackV value_a*{value_a <- value_a*} _nat n_s_a) be (value as headerStackValue))

    2. If ((value' has type headerStackValue)), then

      1. (Let (HeaderStackV value_b*{value_b <- value_b*} _nat' n_s_b) be (value' as headerStackValue))

      2. Return ($bin_eqs(value_a*{value_a <- value_a*}, value_b*{value_b <- value_b*}) /\ (n_s_a = n_s_b))

    2. Else Phantom#249

  6. Case (% has type structValue)

    1. (Let (StructV tid_a (value_f_a id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) be (value as structValue))

    2. If ((value' has type structValue)), then

      1. (Let (StructV tid_b (value_f_b id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) be (value' as structValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))

    2. Else Phantom#250

  7. Case (% has type headerValue)

    1. (Let (HeaderV tid_a b_a (value_f_a id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) be (value as headerValue))

    2. If ((value' has type headerValue)), then

      1. (Let (HeaderV tid_b b_b (value_f_b id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) be (value' as headerValue))

      2. Return (((tid_a = tid_b) /\ (b_a = b_b)) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))

    2. Else Phantom#251

  8. Case (% has type headerUnionValue)

    1. (Let (HeaderUnionV tid_a (value_f_a id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}) be (value as headerUnionValue))

    2. If ((value' has type headerUnionValue)), then

      1. (Let (HeaderUnionV tid_b (value_f_b id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}) be (value' as headerUnionValue))

      2. Return ((tid_a = tid_b) /\ $bin_eqs_fields((value_f_a, id_f_a)*{id_f_a <- id_f_a*, value_f_a <- value_f_a*}, (value_f_b, id_f_b)*{id_f_b <- id_f_b*, value_f_b <- value_f_b*}))

    2. Else Phantom#252

  9. Case (% has type enumValue)

    1. (Let enumValue be (value as enumValue))

    2. Case analysis on enumValue

      1. Case (% matches pattern `EnumV%%`)

        1. (Let (EnumV tid_a id_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `EnumV%%`)), then

            1. (Let (EnumV tid_b id_f_b) be enumValue')

            2. Return ((tid_a = tid_b) /\ (id_f_a = id_f_b))

          2. Else Phantom#253

        2. Else Phantom#254

      2. Case (% matches pattern `SEnumV%%%`)

        1. (Let (SEnumV tid_a id_f_a value_f_a) be enumValue)

        2. If ((value' has type enumValue)), then

          1. (Let enumValue' be (value' as enumValue))

          2. If ((enumValue' matches pattern `SEnumV%%%`)), then

            1. (Let (SEnumV tid_b id_f_b value_f_b) be enumValue')

            2. Return (((tid_a = tid_b) /\ (id_f_a = id_f_b)) /\ $bin_eq(value_f_a, value_f_b))

          2. Else Phantom#255

        2. Else Phantom#256

  10. Case (% has type invalidHeaderValue)

    1. (Let invalidHeaderValue be (value as invalidHeaderValue))

    2. If ((value' has type invalidHeaderValue)), then

      1. (Let invalidHeaderValue' be (value' as invalidHeaderValue))

      2. Return true

    2. Else Phantom#257

1. Else Phantom#258

;; ../../../../spec-concrete/3-numerics.watsup:239.1-239.36
def $bin_eqs(value*{value <- value*}, value'*{value' <- value'*})

1. Case analysis on value*{value <- value*}

  1. Case (% matches pattern [])

    1. Case analysis on value'*{value' <- value'*}

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _value :: _value'*{_value' <- _value'*} be value'*{value' <- value'*})

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _value :: _value'*{_value' <- _value'*} be value*{value <- value*})

    2. If ((value'*{value' <- value'*} matches pattern [])), then

      1. Return false

    2. Else Phantom#259

    3. (Let value_a_h :: value_a_t*{value_a_t <- value_a_t*} be value*{value <- value*})

    4. If ((value'*{value' <- value'*} matches pattern _ :: _)), then

      1. (Let value_b_h :: value_b_t*{value_b_t <- value_b_t*} be value'*{value' <- value'*})

      2. Return ($bin_eq(value_a_h, value_b_h) /\ $bin_eqs(value_a_t*{value_a_t <- value_a_t*}, value_b_t*{value_b_t <- value_b_t*}))

    4. Else Phantom#260

;; ../../../../spec-concrete/3-numerics.watsup:240.1-240.55
def $bin_eqs_fields((value, id)*{(value, id) <- (value, id)*}, (value, id)'*{(value, id)' <- (value, id)'*})

1. Case analysis on (value, id)*{(value, id) <- (value, id)*}

  1. Case (% matches pattern [])

    1. Case analysis on (value, id)'*{(value, id)' <- (value, id)'*}

      1. Case (% matches pattern [])

        1. Return true

      2. Case (% matches pattern _ :: _)

        1. (Let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} be (value, id)'*{(value, id)' <- (value, id)'*})

        2. Return false

  2. Case (% matches pattern _ :: _)

    1. (Let _(value, id) :: _(value, id)'*{_(value, id)' <- _(value, id)'*} be (value, id)*{(value, id) <- (value, id)*})

    2. If (((value, id)'*{(value, id)' <- (value, id)'*} matches pattern [])), then

      1. Return false

    2. Else Phantom#261

    3. (Let (value_a_h, id_a_h) :: (value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*} be (value, id)*{(value, id) <- (value, id)*})

    4. If (((value, id)'*{(value, id)' <- (value, id)'*} matches pattern _ :: _)), then

      1. (Let (value_b_h, id_b_h) :: (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*} be (value, id)'*{(value, id)' <- (value, id)'*})

      2. Return (((id_a_h = id_b_h) /\ $bin_eq(value_a_h, value_b_h)) /\ $bin_eqs_fields((value_a_t, id_a_t)*{id_a_t <- id_a_t*, value_a_t <- value_a_t*}, (value_b_t, id_b_t)*{id_b_t <- id_b_t*, value_b_t <- value_b_t*}))

    4. Else Phantom#262

;; ../../../../spec-concrete/3-numerics.watsup:298.1-298.33
def $bin_ne(value_l, value_r)

1. Return ~$bin_eq(value_l, value_r)

;; ../../../../spec-concrete/3-numerics.watsup:304.1-304.36
def $bin_band(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $band(i_l, i_r)))

            2. Return ((FBitV w i') as value)

          2. Else Phantom#263

        2. Else Phantom#264

      2. Else Phantom#265

    2. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $band(i_l', i_r')))

            4. Return ((FIntV w i') as value)

          2. Else Phantom#266

        2. Else Phantom#267

      2. Else Phantom#268

  2. Else Phantom#269

1. Else Phantom#270

;; ../../../../spec-concrete/3-numerics.watsup:316.1-316.36
def $bin_bxor(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bxor(i_l, i_r)))

            2. Return ((FBitV w i') as value)

          2. Else Phantom#271

        2. Else Phantom#272

      2. Else Phantom#273

    2. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bxor(i_l', i_r')))

            4. Return ((FIntV w i') as value)

          2. Else Phantom#274

        2. Else Phantom#275

      2. Else Phantom#276

  2. Else Phantom#277

1. Else Phantom#278

;; ../../../../spec-concrete/3-numerics.watsup:328.1-328.35
def $bin_bor(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FBitV%%`)), then

          1. (Let (FBitV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i' be $to_bitstr((w as int), $bor(i_l, i_r)))

            2. Return ((FBitV w i') as value)

          2. Else Phantom#279

        2. Else Phantom#280

      2. Else Phantom#281

    2. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. If ((numberValue' matches pattern `FIntV%%`)), then

          1. (Let (FIntV w' i_r) be numberValue')

          2. If ((w = w')), then

            1. (Let i_l' be $to_int((w as int), i_l))

            2. (Let i_r' be $to_int((w as int), i_r))

            3. (Let i' be $to_bitstr((w as int), $bor(i_l', i_r')))

            4. Return ((FIntV w i') as value)

          2. Else Phantom#282

        2. Else Phantom#283

      2. Else Phantom#284

  2. Else Phantom#285

1. Else Phantom#286

;; ../../../../spec-concrete/3-numerics.watsup:340.1-340.38
def $bin_concat(value, value')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. Case analysis on numberValue

    1. Case (% matches pattern `FBitV%%`)

      1. (Let (FBitV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((FBitV w i'') as value)

          2. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_l' be $shl(i_l, (w_r as int)))

            3. (Let i_l'' be (i_l' + i_r))

            4. (Let w be (w_l + w_r))

            5. (Let i'' be $to_bitstr((w as int), i_l''))

            6. Return ((FBitV w i'') as value)

        2. Else Phantom#287

      2. Else Phantom#288

    2. Case (% matches pattern `FIntV%%`)

      1. (Let (FIntV w_l i_l) be numberValue)

      2. If ((value' has type numberValue)), then

        1. (Let numberValue' be (value' as numberValue))

        2. Case analysis on numberValue'

          1. Case (% matches pattern `FBitV%%`)

            1. (Let (FBitV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((FIntV w i''') as value)

          2. Case (% matches pattern `FIntV%%`)

            1. (Let (FIntV w_r i_r) be numberValue')

            2. (Let i_l' be $to_int((w_l as int), i_l))

            3. (Let i_l'' be $shl(i_l', (w_r as int)))

            4. (Let i_l''' be (i_l'' + i_r))

            5. (Let w be (w_l + w_r))

            6. (Let i''' be $to_bitstr((w as int), i_l'''))

            7. Return ((FIntV w i''') as value)

        2. Else Phantom#289

      2. Else Phantom#290

  2. Else Phantom#291

1. Else Phantom#292

;; ../../../../spec-concrete/3-numerics.watsup:368.1-368.36
def $bin_land(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `BoolV%`)), then

    1. (Let (BoolV b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `BoolV%`)), then

        1. (Let (BoolV b_r) be primitiveValue')

        2. Return ((BoolV (b_l /\ b_r)) as value)

      2. Else Phantom#293

    2. Else Phantom#294

  2. Else Phantom#295

1. Else Phantom#296

;; ../../../../spec-concrete/3-numerics.watsup:374.1-374.35
def $bin_lor(value, value')

1. If ((value has type primitiveValue)), then

  1. (Let primitiveValue be (value as primitiveValue))

  2. If ((primitiveValue matches pattern `BoolV%`)), then

    1. (Let (BoolV b_l) be primitiveValue)

    2. If ((value' has type primitiveValue)), then

      1. (Let primitiveValue' be (value' as primitiveValue))

      2. If ((primitiveValue' matches pattern `BoolV%`)), then

        1. (Let (BoolV b_r) be primitiveValue')

        2. Return ((BoolV (b_l \/ b_r)) as value)

      2. Else Phantom#297

    2. Else Phantom#298

  2. Else Phantom#299

1. Else Phantom#300

;; ../../../../spec-concrete/3-numerics.watsup:382.1-382.36
def $cast_op(typeIR, value'')

1. Case analysis on value''

  1. Case (% has type primitiveValue)

    1. (Let primitiveValue be (value'' as primitiveValue))

    2. If ((primitiveValue matches pattern `BoolV%`)), then

      1. (Let (BoolV b) be primitiveValue)

      2. Return $cast_bool(typeIR, b)

    2. Else Phantom#301

  2. Case (% has type numberValue)

    1. (Let numberValue be (value'' as numberValue))

    2. Case analysis on numberValue

      1. Case (% matches pattern `IntV%`)

        1. (Let (IntV i) be numberValue)

        2. Return $cast_arbint(typeIR, i)

      2. Case (% matches pattern `FBitV%%`)

        1. (Let (FBitV w i) be numberValue)

        2. Return $cast_fixbit(typeIR, w, i)

      3. Case (% matches pattern `FIntV%%`)

        1. (Let (FIntV w i) be numberValue)

        2. Return $cast_fixint(typeIR, w, i)

    2. Else Phantom#302

  3. Case (% has type structValue)

    1. (Let (StructV tid (value_f id_f)*{id_f <- id_f*, value_f <- value_f*}) be (value'' as structValue))

    2. Return $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

  4. Case (% has type headerValue)

    1. (Let (HeaderV tid b (value_f id_f)*{id_f <- id_f*, value_f <- value_f*}) be (value'' as headerValue))

    2. Return $cast_header(typeIR, tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

  5. Case (% has type enumValue)

    1. (Let enumValue be (value'' as enumValue))

    2. If ((enumValue matches pattern `SEnumV%%%`)), then

      1. (Let (SEnumV _tid _id value) be enumValue)

      2. Return $cast_op(typeIR, value)

    2. Else Phantom#303

  6. Case (% has type sequenceValue)

    1. (Let sequenceValue be (value'' as sequenceValue))

    2. If ((sequenceValue matches pattern `SeqV%`)), then

      1. (Let (SeqV value*{value <- value*}) be sequenceValue)

      2. Return $cast_sequence(typeIR, value*{value <- value*})

    2. Else Phantom#304

  7. Case (% has type recordValue)

    1. (Let recordValue be (value'' as recordValue))

    2. If ((recordValue matches pattern `RecordV%`)), then

      1. (Let (RecordV (value id)*{id <- id*, value <- value*}) be recordValue)

      2. Return $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})

    2. Else Phantom#305

  8. Case (% has type defaultValue)

    1. (Let defaultValue be (value'' as defaultValue))

    2. Return $default(typeIR)

  9. Case (% has type invalidHeaderValue)

    1. (Let invalidHeaderValue be (value'' as invalidHeaderValue))

    2. Return $cast_invalid(typeIR)

  10. Case (% has type setValue)

    1. (Let setValue be (value'' as setValue))

    2. Case analysis on setValue

      1. Case (% matches pattern `SingletonSetV%`)

        1. (Let (SingletonSetV value) be setValue)

        2. Return $cast_set_singleton(typeIR, value)

      2. Case (% matches pattern `MaskSetV%%`)

        1. (Let (MaskSetV value_b value_m) be setValue)

        2. Return $cast_set_mask(typeIR, value_b, value_m)

      3. Case (% matches pattern `RangeSetV%%`)

        1. (Let (RangeSetV value_l value_u) be setValue)

        2. Return $cast_set_range(typeIR, value_l, value_u)

1. Else Phantom#306

;; ../../../../spec-concrete/3-numerics.watsup:384.1-384.29
def $default(typeIR)

1. Return $default'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:385.1-385.30
def $default'(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return ((BoolV false) as value)

      2. Case (% matches pattern `ErrT`)

        1. Return ((ErrV "NoError") as value)

      3. Case (% matches pattern `StrT`)

        1. Return ((StrV "") as value)

    2. Else Phantom#307

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Return ((IntV (0 as int)) as value)

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numberTypeIR)

        2. Return ((FBitV w (0 as bits)) as value)

      3. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numberTypeIR)

        2. Return ((FIntV w (0 as bits)) as value)

      4. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numberTypeIR)

        2. Return ((VBitV w 0 (0 as bits)) as value)

  3. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return ((TupleV $default(typeIR)*{typeIR <- typeIR*}) as value)

  4. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR n_s) be (typeIR'' as headerStackTypeIR))

    2. (Let value*{value <- value*} be $repeat_<value>($default(typeIR), n_s))

    3. Return ((HeaderStackV value*{value <- value*} 0 n_s) as value)

  5. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR'' as structTypeIR))

    2. Return ((StructV tid ($default(typeIR_f) id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value)

  6. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR'' as headerTypeIR))

    2. Return ((HeaderV tid false ($default(typeIR_f) id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value)

  7. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR'' as headerUnionTypeIR))

    2. Return ((HeaderUnionV tid ($default(typeIR_f) id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) as value)

  8. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT tid id*{id <- id*}) be enumTypeIR)

        2. If ((id*{id <- id*} matches pattern _ :: _)), then

          1. (Let id_f_h :: _id*{_id <- _id*} be id*{id <- id*})

          2. Return ((EnumV tid id_f_h) as value)

        2. Else Phantom#308

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT tid typeIR (id_f value_f)*{id_f <- id_f*, value_f <- value_f*}) be enumTypeIR)

        2. (Let value_zero be $cast_arbint(typeIR, (0 as int)))

        3. (Let id?{id <- id?} be $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))

        4. If ((id?{id <- id?} matches pattern (_))), then

          1. (Let ?(id_zero) be id?{id <- id?})

          2. Return ((SEnumV tid id_zero value_zero) as value)

        4. Else Phantom#309

        5. If ((?() = $assoc_<value, id>(value_zero, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*}))), then

          1. (Let id_zero be "__UNSPECIFIED")

          2. Return ((SEnumV tid id_zero value_zero) as value)

        5. Else Phantom#310

1. Else Phantom#311

;; ../../../../spec-concrete/3-numerics.watsup:389.1-389.37
def $cast_bool(typeIR, b)

1. Return $cast_bool'($canon(typeIR), b)

;; ../../../../spec-concrete/3-numerics.watsup:390.1-390.38
def $cast_bool'(typeIR'', b')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return ((BoolV b') as value)

    2. Else Phantom#312

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `FBitT%`)), then

      1. (Let (FBitT w) be numberTypeIR)

      2. Case analysis on b'

        1. Case (% = true)

          1. Return ((FBitV w (1 as bits)) as value)

        2. Case (% = false)

          1. Return ((FBitV w (0 as bits)) as value)

    2. Else Phantom#313

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $cast_bool(typeIR, b')

    2. Else Phantom#314

1. Else Phantom#315

;; ../../../../spec-concrete/3-numerics.watsup:403.1-403.38
def $cast_arbint(typeIR, i)

1. Return $cast_arbint'($canon(typeIR), i)

;; ../../../../spec-concrete/3-numerics.watsup:404.1-404.39
def $cast_arbint'(typeIR'', i)

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return ((BoolV (i = (0 as int))) as value)

    2. Else Phantom#316

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Return ((IntV i) as value)

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numberTypeIR)

        2. Return ((FIntV w $to_bitstr((w as int), i)) as value)

      3. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numberTypeIR)

        2. Return ((FBitV w $to_bitstr((w as int), i)) as value)

    2. Else Phantom#317

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $cast_arbint(typeIR, i)

    2. Else Phantom#318

  4. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR'' as setTypeIR))

    2. Return ((SingletonSetV $cast_arbint(typeIR, i)) as value)

1. Else Phantom#319

;; ../../../../spec-concrete/3-numerics.watsup:419.1-419.43
def $cast_fixbit(typeIR, w, i)

1. Return $cast_fixbit'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:420.1-420.44
def $cast_fixbit'(typeIR'', w', i)

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return ((BoolV (i = (1 as int))) as value)

    2. Else Phantom#320

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Return ((IntV i) as value)

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((FBitV w_to i') as value)

      3. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), i))

        3. Return ((FIntV w_to i') as value)

    2. Else Phantom#321

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $cast_fixbit(typeIR, w', i)

    2. Else Phantom#322

  4. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR'' as setTypeIR))

    2. Return ((SingletonSetV $cast_fixbit(typeIR, w', i)) as value)

1. Else Phantom#323

;; ../../../../spec-concrete/3-numerics.watsup:437.1-437.43
def $cast_fixint(typeIR, w, i)

1. Return $cast_fixint'($canon(typeIR), w, i)

;; ../../../../spec-concrete/3-numerics.watsup:438.1-438.44
def $cast_fixint'(typeIR'', w', i)

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Return ((IntV $to_int((w' as int), i)) as value)

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w_to) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((FBitV w_to i') as value)

      3. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w_to) be numberTypeIR)

        2. (Let i' be $to_bitstr((w_to as int), $to_int((w' as int), i)))

        3. Return ((FIntV w_to i') as value)

    2. Else Phantom#324

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $cast_fixint(typeIR, w', i)

    2. Else Phantom#325

  3. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR'' as setTypeIR))

    2. Return ((SingletonSetV $cast_fixint(typeIR, w', i)) as value)

1. Else Phantom#326

;; ../../../../spec-concrete/3-numerics.watsup:454.1-454.52
def $cast_struct(typeIR, tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

1. Return $cast_struct'($canon(typeIR), tid, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:455.1-455.53
def $cast_struct'(typeIR, tid', (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

1. If ((typeIR has type structTypeIR)), then

  1. (Let (StructT tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as structTypeIR))

  2. If ((tid = tid')), then

    1. Return ((StructV tid (value_f id_f)*{id_f <- id_f*, value_f <- value_f*}) as value)

  2. Else Phantom#327

1. Else Phantom#328

;; ../../../../spec-concrete/3-numerics.watsup:468.1-468.58
def $cast_header(typeIR, tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

1. Return $cast_header'($canon(typeIR), tid, b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

;; ../../../../spec-concrete/3-numerics.watsup:469.1-469.59
def $cast_header'(typeIR, tid', b, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

1. If ((typeIR has type headerTypeIR)), then

  1. (Let (HeaderT tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerTypeIR))

  2. If ((tid = tid')), then

    1. Return ((HeaderV tid b (value_f id_f)*{id_f <- id_f*, value_f <- value_f*}) as value)

  2. Else Phantom#329

1. Else Phantom#330

;; ../../../../spec-concrete/3-numerics.watsup:486.1-486.43
def $cast_sequence(typeIR, value*{value <- value*})

1. Return $cast_sequence'($canon(typeIR), value*{value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:487.1-487.44
def $cast_sequence'(typeIR'', value*{value <- value*})

1. Case analysis on typeIR''

  1. Case (% has type listTypeIR)

    1. (Let (ListT typeIR) be (typeIR'' as listTypeIR))

    2. Return ((ListV $cast_op(typeIR, value)*{value <- value*}) as value)

  2. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return ((TupleV $cast_op(typeIR, value)*{typeIR <- typeIR*, value <- value*}) as value)

  3. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR n_s) be (typeIR'' as headerStackTypeIR))

    2. (Let value_cast be $cast_op(typeIR, value))*{value <- value*, value_cast <- value_cast*}

    3. (Let n_idx be |value*{value <- value*}|)

    4. Return ((HeaderStackV value_cast*{value_cast <- value_cast*} n_idx n_s) as value)

  4. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR'' as structTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

    3. Return ((StructV tid (value_cast id_f)*{id_f <- id_f*, value_cast <- value_cast*}) as value)

  5. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR'' as headerTypeIR))

    2. (Let value_cast be $cast_op(typeIR_f, value))*{typeIR_f <- typeIR_f*, value <- value*, value_cast <- value_cast*}

    3. Return ((HeaderV tid true (value_cast id_f)*{id_f <- id_f*, value_cast <- value_cast*}) as value)

1. Else Phantom#331

;; ../../../../spec-concrete/3-numerics.watsup:517.1-517.47
def $cast_record(typeIR, (value, id)*{id <- id*, value <- value*})

1. Return $cast_record'($canon(typeIR), (value, id)*{id <- id*, value <- value*})

;; ../../../../spec-concrete/3-numerics.watsup:518.1-518.48
def $cast_record'(typeIR, (value_f, id_f)*{id_f <- id_f*, value_f <- value_f*})

1. Case analysis on typeIR

  1. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_t_f id_t_f)*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*}) be (typeIR as structTypeIR))

    2. (Let value?{value <- value?} be $find_map<id, value>(({ (id_f -> value_f)*{id_f <- id_f*, value_f <- value_f*} }), id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}

    3. If ((value?{value <- value?} matches pattern (_)))*{value? <- value?*}, then

      1. (Let ?(value_f') be value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

      3. Return ((StructV tid (value_f_cast id_f)*{id_f <- id_f*, value_f_cast <- value_f_cast*}) as value)

    3. Else Phantom#332

  2. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_t_f id_t_f)*{id_t_f <- id_t_f*, typeIR_t_f <- typeIR_t_f*}) be (typeIR as headerTypeIR))

    2. (Let value?{value <- value?} be $find_map<id, value>(({ (id_f -> value_f)*{id_f <- id_f*, value_f <- value_f*} }), id_t_f))*{id_t_f <- id_t_f*, value? <- value?*}

    3. If ((value?{value <- value?} matches pattern (_)))*{value? <- value?*}, then

      1. (Let ?(value_f') be value?{value <- value?})*{value? <- value?*, value_f' <- value_f'*}

      2. (Let value_f_cast be $cast_op(typeIR_t_f, value_f'))*{typeIR_t_f <- typeIR_t_f*, value_f' <- value_f'*, value_f_cast <- value_f_cast*}

      3. Return ((HeaderV tid true (value_f_cast id_f)*{id_f <- id_f*, value_f_cast <- value_f_cast*}) as value)

    3. Else Phantom#333

1. Else Phantom#334

;; ../../../../spec-concrete/3-numerics.watsup:550.1-550.34
def $cast_invalid(typeIR)

1. Return $cast_invalid'($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:551.1-551.35
def $cast_invalid'(typeIR)

1. Case analysis on typeIR

  1. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerTypeIR))

    2. Return $default(typeIR)

  2. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerUnionTypeIR))

    2. Return $default(typeIR)

1. Else Phantom#335

;; ../../../../spec-concrete/3-numerics.watsup:565.1-565.47
def $cast_set_singleton(typeIR, value)

1. Return $cast_set_singleton'($canon(typeIR), value)

;; ../../../../spec-concrete/3-numerics.watsup:566.1-566.48
def $cast_set_singleton'(typeIR', value)

1. If ((typeIR' has type setTypeIR)), then

  1. (Let (SetT typeIR) be (typeIR' as setTypeIR))

  2. Return ((SingletonSetV $cast_op(typeIR, value)) as value)

1. Else Phantom#336

;; ../../../../spec-concrete/3-numerics.watsup:574.1-574.49
def $cast_set_mask(typeIR, value_b, value_m)

1. Return $cast_set_mask'($canon(typeIR), value_b, value_m)

;; ../../../../spec-concrete/3-numerics.watsup:575.1-575.50
def $cast_set_mask'(typeIR', value_b, value_m)

1. If ((typeIR' has type setTypeIR)), then

  1. (Let (SetT typeIR) be (typeIR' as setTypeIR))

  2. (Let value_b_cast be $cast_op(typeIR, value_b))

  3. (Let value_m_cast be $cast_op(typeIR, value_m))

  4. Return ((MaskSetV value_b_cast value_m_cast) as value)

1. Else Phantom#337

;; ../../../../spec-concrete/3-numerics.watsup:585.1-585.50
def $cast_set_range(typeIR, value_l, value_u)

1. Return $cast_set_range'($canon(typeIR), value_l, value_u)

;; ../../../../spec-concrete/3-numerics.watsup:586.1-586.51
def $cast_set_range'(typeIR', value_l, value_u)

1. If ((typeIR' has type setTypeIR)), then

  1. (Let (SetT typeIR) be (typeIR' as setTypeIR))

  2. (Let value_l_cast be $cast_op(typeIR, value_l))

  3. (Let value_u_cast be $cast_op(typeIR, value_u))

  4. Return ((RangeSetV value_l_cast value_u_cast) as value)

1. Else Phantom#338

;; ../../../../spec-concrete/3-numerics.watsup:650.1-650.44
def $bitacc_op(value_b, value_h, value_l)

1. (Let int?{int <- int?} be $to_number(value_b))

2. If ((int?{int <- int?} matches pattern (_))), then

  1. (Let ?(i_b) be int?{int <- int?})

  2. (Let int'?{int' <- int'?} be $to_number(value_h))

  3. If ((int'?{int' <- int'?} matches pattern (_))), then

    1. (Let ?(i_h) be int'?{int' <- int'?})

    2. (Let int''?{int'' <- int''?} be $to_number(value_l))

    3. If ((int''?{int'' <- int''?} matches pattern (_))), then

      1. (Let ?(i_l) be int''?{int'' <- int''?})

      2. (Let int''' be ((i_h + (1 as int)) - i_l))

      3. If ((int''' has type nat)), then

        1. (Let w be (int''' as nat))

        2. (Let i be $bitacc(i_b, i_h, i_l))

        3. Return ((FBitV w i) as value)

      3. Else Phantom#339

    3. Else Phantom#340

  3. Else Phantom#341

2. Else Phantom#342

;; ../../../../spec-concrete/3-numerics.watsup:663.1-663.32
def $sizeof(typeIR, text)

1. Case analysis on text

  1. Case (% = "minSizeInBits")

    1. Return $sizeof_minSizeInBits(typeIR)

  2. Case (% = "minSizeInBytes")

    1. Return $sizeof_minSizeInBytes(typeIR)

  3. Case (% = "maxSizeInBits")

    1. Return $sizeof_maxSizeInBits(typeIR)

  4. Case (% = "maxSizeInBytes")

    1. Return $sizeof_maxSizeInBytes(typeIR)

1. Else Phantom#343

;; ../../../../spec-concrete/3-numerics.watsup:665.1-665.42
def $sizeof_minSizeInBits(typeIR)

1. Return ((IntV ($sizeof_minSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:666.1-666.41
def $sizeof_minSizeInBits'(typeIR)

1. Return $sizeof_minSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:667.1-667.42
def $sizeof_minSizeInBits''(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return 1

    2. Else Phantom#344

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _nat) be numberTypeIR)

        2. Return 0

    2. Else Phantom#345

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR)

    2. Else Phantom#346

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. Return $sizeof_minSizeInBits'(typeIR)

    2. Else Phantom#347

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR n_size) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_minSizeInBits'(typeIR) * n_size)

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. Return $min($sizeof_minSizeInBits'(typeIR)*{typeIR <- typeIR*})

1. Else Phantom#348

;; ../../../../spec-concrete/3-numerics.watsup:669.1-669.43
def $sizeof_minSizeInBytes(typeIR)

1. (Let n_size be $sizeof_minSizeInBits'(typeIR))

2. Return ((IntV ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:671.1-671.42
def $sizeof_maxSizeInBits(typeIR)

1. Return ((IntV ($sizeof_maxSizeInBits'(typeIR) as int)) as value)

;; ../../../../spec-concrete/3-numerics.watsup:672.1-672.41
def $sizeof_maxSizeInBits'(typeIR)

1. Return $sizeof_maxSizeInBits''($canon(typeIR))

;; ../../../../spec-concrete/3-numerics.watsup:673.1-673.42
def $sizeof_maxSizeInBits''(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return 1

    2. Else Phantom#349

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT w) be numberTypeIR)

        2. Return w

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT w) be numberTypeIR)

        2. Return w

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT w) be numberTypeIR)

        2. Return w

    2. Else Phantom#350

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR)

    2. Else Phantom#351

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. Return $sizeof_maxSizeInBits'(typeIR)

    2. Else Phantom#352

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR n_size) be (typeIR'' as headerStackTypeIR))

    2. Return ($sizeof_maxSizeInBits'(typeIR) * n_size)

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerTypeIR))

    2. Return $sum($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. Return $max($sizeof_maxSizeInBits'(typeIR)*{typeIR <- typeIR*})

1. Else Phantom#353

;; ../../../../spec-concrete/3-numerics.watsup:675.1-675.43
def $sizeof_maxSizeInBytes(typeIR)

1. (Let n_size be $sizeof_maxSizeInBits'(typeIR))

2. Return ((IntV ((n_size / 8) as int)) as value)

;; ../../../../spec-concrete/4-ir-syntax.watsup:8.3-8.47
syntax parameterIR = 
   | `%%%%`(direction, typeIR, name, constantInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:14.33-14.44
syntax constructorParameterIR = parameterIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:22.28-22.50
syntax namedExpressionIR = 
   | `%%`(name, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:32.30-32.47
syntax literalExpressionIR = literalExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:38.32-38.51
syntax referenceExpressionIR = referenceExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:44.30-44.38
syntax defaultExpressionIR = 
   | `DefaultE`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:51.3-51.29
syntax unaryExpressionIR = 
   | `UnE%%`(unop, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:54.3-54.49
syntax binaryExpressionIR = 
   | `BinE%%%`(typedExpressionIR, binop, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:57.3-57.62
syntax ternaryExpressionIR = 
   | `TernE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:63.27-63.57
syntax castExpressionIR = 
   | `CastE%%`(typeIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:70.1-74.38
syntax dataExpressionIR = 
   | `InvalidE`()
   | `SeqE%`(typedExpressionIR*)
   | `SeqDefaultE%`(typedExpressionIR*)
   | `RecordE%`(namedExpressionIR*)
   | `RecordDefaultE%`(namedExpressionIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:80.34-80.55
syntax errorAccessExpressionIR = errorAccessExpression

;; ../../../../spec-concrete/4-ir-syntax.watsup:83.1-84.36
syntax memberAccessExpressionIR = 
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:87.1-88.66
syntax indexAccessExpressionIR = 
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:91.1-93.28
syntax accessExpressionIR = 
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:105.1-106.51
syntax callExpressionIR = 
   | `CallE%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstE%%%`(prefixedName, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:113.1-122.21
syntax expressionIR = 
   | `BoolE%`(bool)
   | `NumE%`(number)
   | `StrE%`(text)
   | `NameE%`(prefixedName)
   | `DefaultE`()
   | `UnE%%`(unop, typedExpressionIR)
   | `BinE%%%`(typedExpressionIR, binop, typedExpressionIR)
   | `TernE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)
   | `CastE%%`(typeIR, typedExpressionIR)
   | `InvalidE`()
   | `SeqE%`(typedExpressionIR*)
   | `SeqDefaultE%`(typedExpressionIR*)
   | `RecordE%`(namedExpressionIR*)
   | `RecordDefaultE%`(namedExpressionIR*)
   | `ErrAccE%`(name)
   | `TypeAccE%%`(prefixedName, name)
   | `ExprAccE%%`(typedExpressionIR, name)
   | `ArrAccE%%`(typedExpressionIR, typedExpressionIR)
   | `BitAccE%%%`(typedExpressionIR, typedExpressionIR, typedExpressionIR)
   | `CallE%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstE%%%`(prefixedName, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:124.27-124.42
syntax expressionNoteIR = 
   | `(%%)`(typeIR, ctk)

;; ../../../../spec-concrete/4-ir-syntax.watsup:126.28-126.57
syntax typedExpressionIR = 
   | `%%`(expressionIR, expressionNoteIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:129.1-131.28
syntax routineTargetIR = 
   | `FuncT%`(prefixedName)
   | `MethodT%%`(typedExpressionIR, name)
   | `TypeT%%`(prefixedName, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:138.1-142.9
syntax keysetExpressionIR = 
   | `ExprK%`(typedExpressionIR)
   | `MaskK%%`(typedExpressionIR, typedExpressionIR)
   | `RangeK%%`(typedExpressionIR, typedExpressionIR)
   | `DefaultK`()
   | `AnyK`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:148.25-148.31
syntax typeArgumentIR = typeIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:155.1-158.9
syntax argumentIR = 
   | `ExprA%`(typedExpressionIR)
   | `NameA%%`(name, typedExpressionIR)
   | `NameAnyA%`(name)
   | `AnyA`()

;; ../../../../spec-concrete/4-ir-syntax.watsup:167.1-170.62
syntax lvalueIR = 
   | `NameL%`(prefixedName)
   | `LvalueAccL%%`(typedLvalueIR, name)
   | `ArrAccL%%`(typedLvalueIR, typedExpressionIR)
   | `BitAccL%%%`(typedLvalueIR, typedExpressionIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:172.23-172.34
syntax lvalueNoteIR = 
   | `(%)`(typeIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:174.24-174.45
syntax typedLvalueIR = 
   | `%%`(lvalueIR, lvalueNoteIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:184.27-184.41
syntax emptyStatementIR = emptyStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:191.3-191.42
syntax assignmentStatementIR = 
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:198.3-198.52
syntax callStatementIR = 
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:205.3-205.33
syntax directApplicationStatementIR = 
   | `InstS%%`(prefixedName, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:212.3-212.29
syntax returnStatementIR = 
   | `ReturnS%`(typedExpressionIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:218.26-218.39
syntax exitStatementIR = exitStatement

;; ../../../../spec-concrete/4-ir-syntax.watsup:227.3-227.34
syntax blockStatementIR = 
   | `BlockS%`(blockElementStatementIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:236.3-236.49
syntax conditionalStatementIR = 
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:243.1-244.28
syntax switchLabelIR = 
   | `DefaultL`()
   | `ExprL%`(typedExpressionIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:247.1-248.42
syntax switchCaseIR = 
   | `FallC%`(switchLabelIR)
   | `MatchC%%`(switchLabelIR, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:251.3-251.42
syntax switchStatementIR = 
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:258.1-266.22
syntax statementIR = 
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ReturnS%`(typedExpressionIR?)
   | `ExitS`()
   | `BlockS%`(blockElementStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:276.32-276.37
syntax constantInitializerIR = value

;; ../../../../spec-concrete/4-ir-syntax.watsup:279.3-279.43
syntax constantDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:281.24-281.41
syntax initializerIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:284.3-284.34
syntax variableDeclarationIR = 
   | `VarD%%%`(typeIR, name, initializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:287.1-289.16
syntax blockElementStatementIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ReturnS%`(typedExpressionIR?)
   | `ExitS`()
   | `BlockS%`(blockElementStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)
   | `SwitchS%%`(typedExpressionIR, switchCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:296.3-297.68
syntax functionDeclarationIR = 
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:304.3-304.45
syntax actionDeclarationIR = 
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:313.3-313.82
syntax instantiationIR = 
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:316.1-317.20
syntax objectDeclarationIR = 
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:319.30-319.50
syntax objectInitializerIR = objectDeclarationIR*

;; ../../../../spec-concrete/4-ir-syntax.watsup:325.29-325.45
syntax errorDeclarationIR = errorDeclaration

;; ../../../../spec-concrete/4-ir-syntax.watsup:331.33-331.53
syntax matchKindDeclarationIR = matchKindDeclaration

;; ../../../../spec-concrete/4-ir-syntax.watsup:342.1-343.42
syntax enumTypeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:349.22-349.33
syntax typeFieldIR = 
   | `%%`(typeIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:352.3-352.58
syntax structTypeDeclarationIR = 
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:355.3-355.58
syntax headerTypeDeclarationIR = 
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:358.3-358.63
syntax headerUnionTypeDeclarationIR = 
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:361.1-364.33
syntax derivedTypeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:371.1-372.38
syntax typedefTypeIR = 
   | `PlainT%`(typeIR)
   | `DerivedT%`(derivedTypeDeclarationIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:375.1-376.25
syntax typedefDeclarationIR = 
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:383.3-384.57
syntax externFunctionDeclarationIR = 
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:387.1-389.75
syntax methodPrototypeIR = 
   | `ConsM%%%`(name, typeParameter*, constructorParameterIR*)
   | `MethodM%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `AbstractMethodM%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:392.3-392.55
syntax externObjectDeclarationIR = 
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:395.1-396.30
syntax externDeclarationIR = 
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:406.23-406.47
syntax selectCaseIR = 
   | `%%`(keysetExpressionIR*, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:413.1-414.45
syntax stateExpressionIR = 
   | `NameE%`(name)
   | `SelectE%%`(typedExpressionIR*, selectCaseIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:417.3-417.28
syntax transitionStatementIR = 
   | `TransS%`(stateExpressionIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:424.3-424.42
syntax valueSetDeclarationIR = 
   | `ValueSetD%%%`(typeIR, typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:431.3-431.62
syntax parserTypeDeclarationIR = 
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:440.3-440.34
syntax parserBlockStatementIR = 
   | `ParserBlockS%`(parserStatementIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:443.1-450.27
syntax parserStatementIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `EmptyS`()
   | `AssignS%%`(typedLvalueIR, typedExpressionIR)
   | `CallS%%%`(routineTargetIR, typeArgumentIR*, argumentIR*)
   | `InstS%%`(prefixedName, argumentIR*)
   | `ParserBlockS%`(parserStatementIR*)
   | `IfS%%%`(typedExpressionIR, statementIR, statementIR?)

;; ../../../../spec-concrete/4-ir-syntax.watsup:453.3-453.48
syntax parserStateIR = 
   | `%%%`(name, parserStatementIR*, transitionStatementIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:456.1-459.26
syntax parserLocalDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `ValueSetD%%%`(typeIR, typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:462.3-464.51
syntax parserDeclarationIR = 
   | `ParserD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, parserLocalDeclarationIR*, parserStateIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:478.21-478.43
syntax tableKeyIR = 
   | `%%`(typedExpressionIR, name)

;; ../../../../spec-concrete/4-ir-syntax.watsup:484.33-484.57
syntax tableActionReferenceIR = 
   | `%%`(prefixedName, argumentIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:486.24-486.46
syntax tableActionIR = tableActionReferenceIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:492.31-492.48
syntax tableEntryPriorityIR = typedExpressionIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:495.3-496.52
syntax tableEntryIR = 
   | `%%%%`(const?, tableEntryPriorityIR?, keysetExpressionIR*, tableActionReferenceIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:503.1-508.51
syntax tablePropertyIR = 
   | `KeyP%`(tableKeyIR*)
   | `ActionP%`(tableActionIR*)
   | `DefaultActionP%%`(const?, tableActionIR)
   | `EntryP%%`(const?, tableEntryIR*)
   | `CustomP%%%`(const?, name, initializerIR)
   | `CustomConstP%%%`(const?, name, constantInitializerIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:511.3-511.38
syntax tableDeclarationIR = 
   | `TableD%%%`(typeIR, name, tablePropertyIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:518.3-518.63
syntax controlTypeDeclarationIR = 
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:524.24-524.40
syntax controlBodyIR = blockStatementIR

;; ../../../../spec-concrete/4-ir-syntax.watsup:527.1-531.23
syntax controlLocalDeclarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `VarD%%%`(typeIR, name, initializerIR?)
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)
   | `TableD%%%`(typeIR, name, tablePropertyIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:534.3-536.52
syntax controlDeclarationIR = 
   | `ControlD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, controlLocalDeclarationIR*, controlBodyIR)

;; ../../../../spec-concrete/4-ir-syntax.watsup:543.3-543.74
syntax packageTypeDeclarationIR = 
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:550.1-554.29
syntax typeDeclarationIR = 
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:561.1-570.22
syntax declarationIR = 
   | `ConstD%%%`(typeIR, name, constantInitializerIR)
   | `InstD%%%%%%`(typeIR, prefixedName, typeArgumentIR*, argumentIR*, name, objectInitializerIR?)
   | `FuncD%%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*, blockStatementIR)
   | `ActionD%%%`(name, parameterIR*, blockStatementIR)
   | `ErrD%`(name*)
   | `MatchKindD%`(name*)
   | `ExternFuncD%%%%%`(typeIR, name, typeParameter*, typeParameter*, parameterIR*)
   | `ExternObjectD%%%`(name, typeParameter*, methodPrototypeIR*)
   | `ParserD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, parserLocalDeclarationIR*, parserStateIR*)
   | `ControlD%%%%%%`(name, typeParameter*, parameterIR*, constructorParameterIR*, controlLocalDeclarationIR*, controlBodyIR)
   | `EnumD%%`(name, name*)
   | `SEnumD%%%`(typeIR, name, namedExpressionIR*)
   | `StructD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `HeaderUnionD%%%%`(name, typeParameter*, typeParameter*, typeFieldIR*)
   | `TypeDefD%%`(typedefTypeIR, name)
   | `NewTypeD%%`(typeIR, name)
   | `ParserTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `ControlTypeD%%%%`(name, typeParameter*, typeParameter*, parameterIR*)
   | `PackageTypeD%%%%`(name, typeParameter*, typeParameter*, constructorParameterIR*)

;; ../../../../spec-concrete/4-ir-syntax.watsup:576.22-576.36
syntax p4programIR = declarationIR*

;; ../../../../spec-concrete/5.0-flow.watsup:5.15-5.25
syntax flow = 
   | `CONT`()
   | `RET`()

;; ../../../../spec-concrete/5.0-flow.watsup:9.1-9.34
def $join_flow(flow'', flow''')

1. If ((flow'' matches pattern `RET`)), then

  1. If ((flow''' matches pattern `RET`)), then

    1. Return (RET)

2. Otherwise

  1. Return (CONT)

;; ../../../../spec-concrete/5.01-env.watsup:5.20-5.47
syntax varTypeIR = 
   | `%%%%`(direction, typeIR, ctk, value?)

;; ../../../../spec-concrete/5.01-env.watsup:12.16-12.34
syntax frame = map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:14.1-14.27
def $empty_frame

1. Return $empty_map<id, varTypeIR>

;; ../../../../spec-concrete/5.01-env.watsup:18.16-18.35
syntax tdenv = map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:20.1-20.27
def $empty_tdenv

1. Return $empty_map<tid, typeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:24.16-24.42
syntax rdenv = map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:26.1-26.27
def $empty_rdenv

1. Return $empty_map<rid, routineTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:30.16-30.46
syntax cdenv = map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:32.1-32.27
def $empty_cdenv

1. Return $empty_map<cid, constructorTypeDefIR>

;; ../../../../spec-concrete/5.01-env.watsup:39.1-39.39
def $check_routine_name(id_l, id_r)

1. Return (id_l = id_r)

;; ../../../../spec-concrete/5.01-env.watsup:42.1-42.37
def $check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*})

1. Return (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| = |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:45.1-45.42
def $check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*})

1. Return (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:48.1-48.42
def $check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param*{id_param <- id_param*})

1. Return (|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| < |id_param*{id_param <- id_param*}|)

;; ../../../../spec-concrete/5.01-env.watsup:51.1-51.53
def $get_missing_default_parameters(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*})

1. Case analysis on pid*{pid <- pid*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let (id_param_h bool) :: pid_t*{pid_t <- pid_t*} be pid*{pid <- pid*})

    2. Case analysis on bool

      1. Case (% = true)

        1. Case analysis on $in_set<id>(id_param_h, ({ id_arg*{id_arg <- id_arg*} }))

          1. Case false

            1. Return id_param_h :: $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})

          2. Case true

            1. Return $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})

      2. Case (% = false)

        1. Return $get_missing_default_parameters(pid_t*{pid_t <- pid_t*}, id_arg*{id_arg <- id_arg*})

;; ../../../../spec-concrete/5.01-env.watsup:73.1-73.61
def $find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*}, pid'*{pid' <- pid'*})

1. (Let (id_param bool_param) be pid')*{pid' <- pid'*, bool_param <- bool_param*, id_param <- id_param*}

2. If ($eq_set<id>(({ id_arg*{id_arg <- id_arg*} }), ({ id_param*{id_param <- id_param*} }))), then

  1. Return ?((rid, V, []))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:82.1-82.69
def $find_match_named_default<V>(rid, V, id_arg*{id_arg <- id_arg*}, pid*{pid <- pid*})

1. (Let id_default*{id_default <- id_default*} be $get_missing_default_parameters(pid*{pid <- pid*}, id_arg*{id_arg <- id_arg*}))

2. If (($find_match_named<V>(rid, V, id_arg*{id_arg <- id_arg*} ++ id_default*{id_default <- id_default*}, pid*{pid <- pid*}) =/= ?())), then

  1. Return ?((rid, V, id_default*{id_default <- id_default*}))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:96.1-96.74
def $find_match_unnamed_default<V>(rid, V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, pid*{pid <- pid*})

1. (Let (_pid*{_pid <- _pid*}, (id_default bool)*{bool <- bool*, id_default <- id_default*}) be $partition_<pid>(pid*{pid <- pid*}, |id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}|))

2. If ((bool = true))*{bool <- bool*}, then

  1. Return ?((rid, V, id_default*{id_default <- id_default*}))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:105.1-105.64
def $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg''*{id_arg'' <- id_arg''*}, rid', V)

1. (Let (id_r' pid_r'*{pid_r' <- pid_r'*}) be rid')

2. If (~$check_routine_name(id_r, id_r')), then

  1. Return ?()

3. (Let (id_r' (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}) be rid')

4. If ($check_routine_name(id_r, id_r')), then

  1. If ($check_arity_more(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})), then

    1. Return ?()

5. If ((|id_arg''*{id_arg'' <- id_arg''*}| > 0)), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})), then

      1. Return $find_match_named<V>((id_r' (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg''*{id_arg'' <- id_arg''*}, (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})

    2. If ($check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})), then

      1. Return $find_match_named_default<V>((id_r' (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg''*{id_arg'' <- id_arg''*}, (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})

6. If ((id_arg''*{id_arg'' <- id_arg''*} matches pattern [])), then

  1. If ($check_routine_name(id_r, id_r')), then

    1. If ($check_arity(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})), then

      1. Return ?(((id_r' (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, []))

    2. If ($check_arity_less(id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_param'*{id_param' <- id_param'*})), then

      1. Return $find_match_unnamed_default<V>((id_r' (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*}), V, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, (id_param' bool_param')*{bool_param' <- bool_param'*, id_param' <- id_param'*})

7. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:171.1-171.67
def $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid''*{rid'' <- rid''*}, V''*{V'' <- V''*})

1. Case analysis on rid''*{rid'' <- rid''*}

  1. Case (% matches pattern [])

    1. If ((V''*{V'' <- V''*} matches pattern [])), then

      1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let rid_h :: rid_t*{rid_t <- rid_t*} be rid''*{rid'' <- rid''*})

    2. If ((V''*{V'' <- V''*} matches pattern _ :: _)), then

      1. (Let V_h :: V_t*{V_t <- V_t*} be V''*{V'' <- V''*})

      2. If (($find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h) = ?())), then

        1. Return $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})

      3. (Let (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} be $find_matching<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_h, V_h))

      4. If (((rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?} matches pattern (_))), then

        1. (Let ?((rid, V, id_default*{id_default <- id_default*})) be (rid, V, id*)?{(rid, V, id*) <- (rid, V, id*)?})

        2. Return (rid, V, id_default*{id_default <- id_default*}) :: $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid_t*{rid_t <- rid_t*}, V_t*{V_t <- V_t*})

2. Otherwise

  1. Return []

;; ../../../../spec-concrete/5.01-env.watsup:199.1-199.66
def $find_overloaded<V>(({ (rid -> V)*{V <- V*, rid <- rid*} }), id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})

1. If ((|id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}| > 0)), then

  1. (Let id?{id <- id?} be id_arg?{id_arg <- id_arg?})*{id? <- id?*, id_arg? <- id_arg?*}

  2. If ((id?{id <- id?} matches pattern (_)))*{id? <- id?*}, then

    1. (Let ?(id_arg') be id?{id <- id?})*{id? <- id?*, id_arg' <- id_arg'*}

    2. If (($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}) = [])), then

      1. Return ?()

    3. (Let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} be $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, id_arg'*{id_arg' <- id_arg'*}, rid*{rid <- rid*}, V*{V <- V*}))

    4. If (((rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches pattern [ _/1 ])), then

      1. (Let [(rid', V', id_default*{id_default <- id_default*})] be (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*})

      2. Return ?((rid', V', id_default*{id_default <- id_default*}))

2. If ((id_arg?{id_arg <- id_arg?} = ?()))*{id_arg? <- id_arg?*}, then

  1. If (($find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}) = [])), then

    1. Return ?()

  2. (Let (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} be $find_matchings<V>(id_r, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}, [], rid*{rid <- rid*}, V*{V <- V*}))

  3. If (((rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*} matches pattern [ _/1 ])), then

    1. (Let [(rid', V', id_default*{id_default <- id_default*})] be (rid, V, id*)*{(rid, V, id*) <- (rid, V, id*)*})

    2. Return ?((rid', V', id_default*{id_default <- id_default*}))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:242.1-242.57
def $find_non_overloaded<V>(({ (rid -> V)*{V <- V*, rid <- rid*} }), id)

1. (Let (rid, V)*{(rid, V) <- (rid, V)*} be $find_non_overloadeds<V>(({ (rid -> V)*{V <- V*, rid <- rid*} }), id))

2. If (((rid, V)*{(rid, V) <- (rid, V)*} matches pattern [ _/1 ])), then

  1. (Let [(rid', V')] be (rid, V)*{(rid, V) <- (rid, V)*})

  2. Return ?((rid', V'))

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.01-env.watsup:243.1-243.58
def $find_non_overloadeds<V>(set<pair<rid, V>>', id)

1. If ((set<pair<rid, V>>' = ({ [] }))), then

  1. Return []

1. Else Phantom#354

2. (Let ({ pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} }) be set<pair<rid, V>>')

3. If ((pair<rid, V>*{pair<rid, V> <- pair<rid, V>*} matches pattern _ :: _)), then

  1. (Let (rid_h -> V_h) :: (rid_t -> V_t)*{V_t <- V_t*, rid_t <- rid_t*} be pair<rid, V>*{pair<rid, V> <- pair<rid, V>*})

  2. (Let (id' _pid*{_pid <- _pid*}) be rid_h)

  3. Case analysis on id'

    1. Case (% = id)

      1. (Let (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*} be $find_non_overloadeds<V>(({ (rid_t -> V_t)*{V_t <- V_t*, rid_t <- rid_t*} }), id))

      2. Return (rid_h, V_h) :: (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*}

    2. Case (% =/= id)

      1. (Let (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*} be $find_non_overloadeds<V>(({ (rid_t -> V_t)*{V_t <- V_t*, rid_t <- rid_t*} }), id))

      2. Return (rid_t_found, V_t_found)*{V_t_found <- V_t_found*, rid_t_found <- rid_t_found*}

3. Else Phantom#355

;; ../../../../spec-concrete/5.02.1-context.watsup:5.17-5.39
syntax cursor = 
   | `GLOBAL`()
   | `BLOCK`()
   | `LOCAL`()

;; ../../../../spec-concrete/5.02.1-context.watsup:16.3-19.18
syntax globalTypingLayer = {`CDENV%`(cdenv), `TDENV%`(tdenv), `RDENV%`(rdenv), `FRAME%`(frame)}

;; ../../../../spec-concrete/5.02.1-context.watsup:24.1-28.12
syntax blockKind = 
   | `EMPTY`()
   | `EXTERN`()
   | `PARSER`()
   | `CONTROL`()
   | `PACKAGE`()

;; ../../../../spec-concrete/5.02.1-context.watsup:30.1-30.43
def $is_extern_blockKind(blockKind)

1. Return (blockKind = (EXTERN))

;; ../../../../spec-concrete/5.02.1-context.watsup:33.1-33.43
def $is_parser_blockKind(blockKind)

1. Return (blockKind = (PARSER))

;; ../../../../spec-concrete/5.02.1-context.watsup:36.1-36.44
def $is_control_blockKind(blockKind)

1. Return (blockKind = (CONTROL))

;; ../../../../spec-concrete/5.02.1-context.watsup:39.1-39.44
def $is_package_blockKind(blockKind)

1. Return (blockKind = (PACKAGE))

;; ../../../../spec-concrete/5.02.1-context.watsup:43.3-47.18
syntax blockTypingLayer = {`ID%`(id), `KIND%`(blockKind), `TDENV%`(tdenv), `RDENV%`(rdenv), `FRAME%`(frame)}

;; ../../../../spec-concrete/5.02.1-context.watsup:52.1-60.21
syntax localKind = 
   | `EMPTY`()
   | `FUNC%`(typeIR)
   | `EXTERNFUNC%`(typeIR)
   | `ACTION`()
   | `EXTERNMETHOD%`(typeIR)
   | `EXTERNABSTRACTMETHOD%`(typeIR)
   | `PARSERSTATE`()
   | `CONTROLAPPLYMETHOD`()
   | `TABLEAPPLYMETHOD`()

;; ../../../../spec-concrete/5.02.1-context.watsup:62.1-62.45
def $is_function_localKind(localKind')

1. If ((localKind' matches pattern `FUNC%`)), then

  1. (Let (FUNC _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:67.1-67.52
def $is_extern_function_localKind(localKind')

1. If ((localKind' matches pattern `EXTERNFUNC%`)), then

  1. (Let (EXTERNFUNC _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:72.1-72.43
def $is_action_localKind(localKind')

1. If ((localKind' matches pattern `ACTION`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:77.1-77.50
def $is_extern_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERNMETHOD%`)), then

  1. (Let (EXTERNMETHOD _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:82.1-82.59
def $is_extern_abstract_method_localKind(localKind')

1. If ((localKind' matches pattern `EXTERNABSTRACTMETHOD%`)), then

  1. (Let (EXTERNABSTRACTMETHOD _typeIR) be localKind')

  2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:87.1-87.49
def $is_parser_state_localKind(localKind')

1. If ((localKind' matches pattern `PARSERSTATE`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:92.1-92.57
def $is_control_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `CONTROLAPPLYMETHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:97.1-97.55
def $is_table_apply_method_localKind(localKind')

1. If ((localKind' matches pattern `TABLEAPPLYMETHOD`)), then

  1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.02.1-context.watsup:103.3-106.20
syntax localTypingLayer = {`ID%`(id), `KIND%`(localKind), `TDENV%`(tdenv), `FRAMES%`(frame*)}

;; ../../../../spec-concrete/5.02.1-context.watsup:113.3-115.29
syntax typingContext = {`GLOBAL%`(globalTypingLayer), `BLOCK%`(blockTypingLayer), `LOCAL%`(localTypingLayer)}

;; ../../../../spec-concrete/5.02.1-context.watsup:123.1-123.41
def $empty_typingContext

1. (Let globalTypingLayer be {CDENV $empty_cdenv, TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame})

2. (Let blockTypingLayer be {ID "", KIND (EMPTY), TDENV $empty_tdenv, RDENV $empty_rdenv, FRAME $empty_frame})

3. (Let localTypingLayer be {ID "", KIND (EMPTY), TDENV $empty_tdenv, FRAMES [$empty_frame]})

4. (Let TC be {GLOBAL globalTypingLayer, BLOCK blockTypingLayer, LOCAL localTypingLayer})

5. Return TC

;; ../../../../spec-concrete/5.02.1-context.watsup:151.1-151.42
def $bound(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return ({ [] })

  2. Case (% matches pattern `BLOCK`)

    1. Return $dom_map<tid, typeDefIR>(TC.BLOCK.TDENV)

  3. Case (% matches pattern `LOCAL`)

    1. (Let bound_block be $bound((BLOCK), TC))

    2. (Let bound_local be $dom_map<tid, typeDefIR>(TC.LOCAL.TDENV))

    3. Return $union_set<tid>(bound_block, bound_local)

;; ../../../../spec-concrete/5.02.1-context.watsup:163.1-163.42
def $enter(TC)

1. Return TC[LOCAL.FRAMES = $empty_frame :: TC.LOCAL.FRAMES]

;; ../../../../spec-concrete/5.02.1-context.watsup:167.1-167.41
def $exit(TC)

1. (Let frame*{frame <- frame*} be TC.LOCAL.FRAMES)

2. If ((frame*{frame <- frame*} matches pattern _ :: _)), then

  1. (Let frame_h :: frame_t*{frame_t <- frame_t*} be frame*{frame <- frame*})

  2. Return TC[LOCAL.FRAMES = frame_t*{frame_t <- frame_t*}]

2. Else Phantom#356

;; ../../../../spec-concrete/5.02.1-context.watsup:178.1-178.67
def $add_var(cursor, TC, id, varTypeIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let frame be TC.GLOBAL.FRAME)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. (Let (_direction typeIR _ctk _value?{_value <- _value?}) be varTypeIR)

      2. If (((id = "main") => $is_package_object_typeIR($canon(typeIR)))), then

        1. (Let frame_update be $add_map<id, varTypeIR>(frame, id, varTypeIR))

        2. (Let TC' be TC[GLOBAL.FRAME = frame_update])

        3. Return TC'

      2. Else Phantom#357

    2. Else Phantom#358

  2. Case (% matches pattern `BLOCK`)

    1. (Let frame be TC.BLOCK.FRAME)

    2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame))), then

      1. If ((id =/= "main")), then

        1. (Let frame_update be $add_map<id, varTypeIR>(TC.BLOCK.FRAME, id, varTypeIR))

        2. (Let TC' be TC[BLOCK.FRAME = frame_update])

        3. Return TC'

      1. Else Phantom#359

    2. Else Phantom#360

  3. Case (% matches pattern `LOCAL`)

    1. (Let frame'*{frame' <- frame'*} be TC.LOCAL.FRAMES)

    2. If ((frame'*{frame' <- frame'*} matches pattern _ :: _)), then

      1. (Let frame_h :: frame_t*{frame_t <- frame_t*} be frame'*{frame' <- frame'*})

      2. If (~$in_set<id>(id, $dom_map<id, varTypeIR>(frame_h))), then

        1. If ((id =/= "main")), then

          1. (Let frame_h_update be $add_map<id, varTypeIR>(frame_h, id, varTypeIR))

          2. (Let frame*{frame <- frame*} be frame_h_update :: frame_t*{frame_t <- frame_t*})

          3. (Let TC' be TC[LOCAL.FRAMES = frame*{frame <- frame*}])

          4. Return TC'

        1. Else Phantom#361

      2. Else Phantom#362

    2. Else Phantom#363

;; ../../../../spec-concrete/5.02.1-context.watsup:179.1-179.70
def $add_vars(p, TC, id*{id <- id*}, varTypeIR*{varTypeIR <- varTypeIR*})

1. Case analysis on id*{id <- id*}

  1. Case (% matches pattern [])

    1. If ((varTypeIR*{varTypeIR <- varTypeIR*} matches pattern [])), then

      1. Return TC

    1. Else Phantom#364

  2. Case (% matches pattern _ :: _)

    1. (Let id_h :: id_t*{id_t <- id_t*} be id*{id <- id*})

    2. If ((varTypeIR*{varTypeIR <- varTypeIR*} matches pattern _ :: _)), then

      1. (Let varTypeIR_h :: varTypeIR_t*{varTypeIR_t <- varTypeIR_t*} be varTypeIR*{varTypeIR <- varTypeIR*})

      2. (Let TC' be $add_var(p, TC, id_h, varTypeIR_h))

      3. (Let TC'' be $add_vars(p, TC', id_t*{id_t <- id_t*}, varTypeIR_t*{varTypeIR_t <- varTypeIR_t*}))

      4. Return TC''

    2. Else Phantom#365

;; ../../../../spec-concrete/5.02.1-context.watsup:209.1-209.75
def $add_parameter(cursor, TC, (direction typeIR id value?{value <- value?}))

1. Case analysis on direction

  1. Case (% matches pattern `NO`)

    1. (Let varTypeIR be ((NO) typeIR (CTK) value?{value <- value?}))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern `IN`)

    1. (Let varTypeIR be (direction typeIR (DYN) value?{value <- value?}))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  3. Case (% matches pattern `OUT`)

    1. (Let varTypeIR be (direction typeIR (DYN) value?{value <- value?}))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

  4. Case (% matches pattern `INOUT`)

    1. (Let varTypeIR be (direction typeIR (DYN) value?{value <- value?}))

    2. (Let TC' be $add_var(cursor, TC, id, varTypeIR))

    3. Return TC'

;; ../../../../spec-concrete/5.02.1-context.watsup:210.1-210.77
def $add_parameters(cursor, TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

1. Case analysis on parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} be parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

    2. (Let TC' be $add_parameter(cursor, TC, parameterTypeIR_h))

    3. (Let TC'' be $add_parameters(cursor, TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}))

    4. Return TC''

;; ../../../../spec-concrete/5.02.1-context.watsup:227.1-227.78
def $add_constructorParameter(TC, (direction typeIR id value''?{value'' <- value''?}))

1. Case analysis on value''?{value'' <- value''?}

  1. Case (% matches pattern ())

    1. (Let varTypeIR be (direction typeIR (CTK) ?()))

    2. (Let TC' be $add_var((BLOCK), TC, id, varTypeIR))

    3. Return TC'

  2. Case (% matches pattern (_))

    1. (Let ?(value) be value''?{value'' <- value''?})

    2. (Let varTypeIR be (direction typeIR (CTK) ?(value)))

    3. (Let TC' be $add_var((BLOCK), TC, id, varTypeIR))

    4. Return TC'

;; ../../../../spec-concrete/5.02.1-context.watsup:228.1-228.80
def $add_constructorParameters(TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

1. Case analysis on parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

  1. Case (% matches pattern [])

    1. Return TC

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} be parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

    2. (Let TC' be $add_constructorParameter(TC, parameterTypeIR_h))

    3. (Let TC'' be $add_constructorParameters(TC', parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}))

    4. Return TC''

;; ../../../../spec-concrete/5.02.1-context.watsup:244.1-244.69
def $add_type(cursor, TC, tid, typeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let tdenv be TC.GLOBAL.TDENV)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[GLOBAL.TDENV = tdenv_update])

      3. Return TC'

    2. Else Phantom#366

  2. Case (% matches pattern `BLOCK`)

    1. (Let tdenv be TC.BLOCK.TDENV)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[BLOCK.TDENV = tdenv_update])

      3. Return TC'

    2. Else Phantom#367

  3. Case (% matches pattern `LOCAL`)

    1. (Let tdenv be TC.LOCAL.TDENV)

    2. If (~$in_set<tid>(tid, $dom_map<tid, typeDefIR>(tdenv))), then

      1. (Let tdenv_update be $add_map<tid, typeDefIR>(tdenv, tid, typeDefIR))

      2. (Let TC' be TC[LOCAL.TDENV = tdenv_update])

      3. Return TC'

    2. Else Phantom#368

;; ../../../../spec-concrete/5.02.1-context.watsup:264.1-264.72
def $add_types(p, TC, tid*{tid <- tid*}, typeDefIR*{typeDefIR <- typeDefIR*})

1. Case analysis on tid*{tid <- tid*}

  1. Case (% matches pattern [])

    1. If ((typeDefIR*{typeDefIR <- typeDefIR*} matches pattern [])), then

      1. Return TC

    1. Else Phantom#369

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t*{tid_t <- tid_t*} be tid*{tid <- tid*})

    2. If ((typeDefIR*{typeDefIR <- typeDefIR*} matches pattern _ :: _)), then

      1. (Let typeDefIR_h :: typeDefIR_t*{typeDefIR_t <- typeDefIR_t*} be typeDefIR*{typeDefIR <- typeDefIR*})

      2. (Let TC' be $add_type(p, TC, tid_h, typeDefIR_h))

      3. (Let TC'' be $add_types(p, TC', tid_t*{tid_t <- tid_t*}, typeDefIR_t*{typeDefIR_t <- typeDefIR_t*}))

      4. Return TC''

    2. Else Phantom#370

;; ../../../../spec-concrete/5.02.1-context.watsup:272.1-272.88
def $add_routine_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.GLOBAL.RDENV)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[GLOBAL.RDENV = rdenv_update])

      3. Return TC'

    2. Else Phantom#371

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.BLOCK.RDENV)

    2. If (~$in_set<rid>(rid, $dom_map<rid, routineTypeDefIR>(rdenv))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[BLOCK.RDENV = rdenv_update])

      3. Return TC'

    2. Else Phantom#372

1. Else Phantom#373

;; ../../../../spec-concrete/5.02.1-context.watsup:287.1-287.92
def $add_routine_non_overload(cursor, TC, rid, routineTypeDefIR)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. (Let rdenv be TC.GLOBAL.RDENV)

    2. (Let (id _pid*{_pid <- _pid*}) be rid)

    3. (Let ({ (id_k _pid'*{_pid' <- _pid'*})*{_pid'* <- _pid'**, id_k <- id_k*} }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k*{id_k <- id_k*} }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[GLOBAL.RDENV = rdenv_update])

      3. Return TC'

    4. Else Phantom#374

  2. Case (% matches pattern `BLOCK`)

    1. (Let rdenv be TC.BLOCK.RDENV)

    2. (Let (id _pid*{_pid <- _pid*}) be rid)

    3. (Let ({ (id_k _pid'*{_pid' <- _pid'*})*{_pid'* <- _pid'**, id_k <- id_k*} }) be $dom_map<rid, routineTypeDefIR>(rdenv))

    4. If (~$in_set<id>(id, ({ id_k*{id_k <- id_k*} }))), then

      1. (Let rdenv_update be $add_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

      2. (Let TC' be TC[BLOCK.RDENV = rdenv_update])

      3. Return TC'

    4. Else Phantom#375

1. Else Phantom#376

;; ../../../../spec-concrete/5.02.1-context.watsup:308.1-308.79
def $add_constructor(TC, cid, constructorTypeDefIR)

1. (Let cdenv be TC.GLOBAL.CDENV)

2. If (~$in_set<cid>(cid, $dom_map<cid, constructorTypeDefIR>(cdenv))), then

  1. (Let cdenv_update be $add_map<cid, constructorTypeDefIR>(cdenv, cid, constructorTypeDefIR))

  2. (Let TC' be TC[GLOBAL.CDENV = cdenv_update])

  3. Return TC'

2. Else Phantom#377

;; ../../../../spec-concrete/5.02.1-context.watsup:309.1-309.82
def $add_constructors(TC, cid*{cid <- cid*}, constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*})

1. Case analysis on cid*{cid <- cid*}

  1. Case (% matches pattern [])

    1. If ((constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*} matches pattern [])), then

      1. Return TC

    1. Else Phantom#378

  2. Case (% matches pattern _ :: _)

    1. (Let cid_h :: cid_t*{cid_t <- cid_t*} be cid*{cid <- cid*})

    2. If ((constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*} matches pattern _ :: _)), then

      1. (Let constructorTypeDefIR_h :: constructorTypeDefIR_t*{constructorTypeDefIR_t <- constructorTypeDefIR_t*} be constructorTypeDefIR*{constructorTypeDefIR <- constructorTypeDefIR*})

      2. (Let TC' be $add_constructor(TC, cid_h, constructorTypeDefIR_h))

      3. (Let TC'' be $add_constructors(TC', cid_t*{cid_t <- cid_t*}, constructorTypeDefIR_t*{constructorTypeDefIR_t <- constructorTypeDefIR_t*}))

      4. Return TC''

    2. Else Phantom#379

;; ../../../../spec-concrete/5.02.1-context.watsup:334.1-334.64
def $find_var(p', TC, prefixedName)

1. If ((prefixedName matches pattern `TOP%`)), then

  1. (Let (TOP id) be prefixedName)

  2. (Let frame be TC.GLOBAL.FRAME)

  3. Return $find_map<id, varTypeIR>(frame, id)

1. Else Phantom#380

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame be TC.GLOBAL.FRAME)

      3. Return $find_map<id, varTypeIR>(frame, id)

    1. Else Phantom#381

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame be TC.BLOCK.FRAME)

      3. (Let varTypeIR'?{varTypeIR' <- varTypeIR'?} be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR'?{varTypeIR' <- varTypeIR'?} matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?{varTypeIR' <- varTypeIR'?})

        2. Return ?(varTypeIR)

      4. Else Phantom#382

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_var((GLOBAL), TC, (CURRENT id))

      5. Else Phantom#383

    1. Else Phantom#384

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame*{frame <- frame*} be TC.LOCAL.FRAMES)

      3. (Let varTypeIR'?{varTypeIR' <- varTypeIR'?} be $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

      4. If ((varTypeIR'?{varTypeIR' <- varTypeIR'?} matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?{varTypeIR' <- varTypeIR'?})

        2. Return ?(varTypeIR)

      4. Else Phantom#385

      5. If ((?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))), then

        1. Return $find_var((BLOCK), TC, (CURRENT id))

      5. Else Phantom#386

    1. Else Phantom#387

;; ../../../../spec-concrete/5.02.1-context.watsup:355.1-355.62
def $find_value(p', TC, prefixedName)

1. If ((prefixedName matches pattern `TOP%`)), then

  1. (Let (TOP id) be prefixedName)

  2. (Let frame be TC.GLOBAL.FRAME)

  3. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_map<id, varTypeIR>(frame, id))

  4. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

    1. (Let ?((_direction _typeIR _ctk value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

    2. Return value?{value <- value?}

  4. Else Phantom#388

  5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

    1. Return ?()

  5. Else Phantom#389

1. Else Phantom#390

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame be TC.GLOBAL.FRAME)

      3. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

        2. Return value?{value <- value?}

      4. Else Phantom#391

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return ?()

      5. Else Phantom#392

    1. Else Phantom#393

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame be TC.BLOCK.FRAME)

      3. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_map<id, varTypeIR>(frame, id))

      4. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

        2. Return value?{value <- value?}

      4. Else Phantom#394

      5. If ((?() = $find_map<id, varTypeIR>(frame, id))), then

        1. Return $find_value((GLOBAL), TC, (CURRENT id))

      5. Else Phantom#395

    1. Else Phantom#396

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let frame*{frame <- frame*} be TC.LOCAL.FRAMES)

      3. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))

      4. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

        1. (Let ?((_direction _typeIR _ctk value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

        2. Return value?{value <- value?}

      4. Else Phantom#397

      5. If ((?() = $find_maps<id, varTypeIR>(frame*{frame <- frame*}, id))), then

        1. Return $find_value((BLOCK), TC, (CURRENT id))

      5. Else Phantom#398

    1. Else Phantom#399

;; ../../../../spec-concrete/5.02.1-context.watsup:384.1-384.65
def $find_type(p', TC, prefixedName)

1. If ((prefixedName matches pattern `TOP%`)), then

  1. (Let (TOP tid) be prefixedName)

  2. (Let tdenv be TC.GLOBAL.TDENV)

  3. Return $find_map<tid, typeDefIR>(tdenv, tid)

1. Else Phantom#400

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT tid) be prefixedName)

      2. (Let tdenv be TC.GLOBAL.TDENV)

      3. Return $find_map<tid, typeDefIR>(tdenv, tid)

    1. Else Phantom#401

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT tid) be prefixedName)

      2. (Let tdenv be TC.BLOCK.TDENV)

      3. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_map<tid, typeDefIR>(tdenv, tid))

      4. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

        2. Return ?(typeDefIR)

      4. Else Phantom#402

      5. If ((?() = $find_map<tid, typeDefIR>(tdenv, tid))), then

        1. Return $find_type((GLOBAL), TC, (CURRENT tid))

      5. Else Phantom#403

    1. Else Phantom#404

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT tid) be prefixedName)

      2. (Let tdenv*{tdenv <- tdenv*} be [TC.LOCAL.TDENV])

      3. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))

      4. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

        2. Return ?(typeDefIR)

      4. Else Phantom#405

      5. If ((?() = $find_maps<tid, typeDefIR>(tdenv*{tdenv <- tdenv*}, tid))), then

        1. Return $find_type((BLOCK), TC, (CURRENT tid))

      5. Else Phantom#406

    1. Else Phantom#407

;; ../../../../spec-concrete/5.02.1-context.watsup:407.1-407.41
def $ids_arguments(argumentIR*{argumentIR <- argumentIR*})

1. Return $id_argument(argumentIR)*{argumentIR <- argumentIR*}

;; ../../../../spec-concrete/5.02.1-context.watsup:408.1-408.35
def $id_argument(argumentIR)

1. Case analysis on argumentIR

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA _typedExpressionIR) be argumentIR)

    2. Return ?()

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA name _typedExpressionIR) be argumentIR)

    2. Return ?(name)

  3. Case (% matches pattern `NameAnyA%`)

    1. (Let (NameAnyA name) be argumentIR)

    2. Return ?(name)

  4. Case (% matches pattern `AnyA`)

    1. Return ?()

;; ../../../../spec-concrete/5.02.1-context.watsup:416.1-417.34
def $find_routine_overloaded(p', TC, prefixedName, argumentIR*{argumentIR <- argumentIR*})

1. If ((prefixedName matches pattern `TOP%`)), then

  1. (Let (TOP id) be prefixedName)

  2. (Let rdenv be TC.GLOBAL.RDENV)

  3. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR*{argumentIR <- argumentIR*}))

  4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})

1. Else Phantom#408

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let rdenv be TC.GLOBAL.RDENV)

      3. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR*{argumentIR <- argumentIR*}))

      4. Return $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})

    1. Else Phantom#409

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let rdenv be TC.BLOCK.RDENV)

      3. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR*{argumentIR <- argumentIR*}))

      4. (Let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} be $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

      5. If (((rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) be (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?})

        2. Return ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*}))

      5. Else Phantom#410

      6. If ((?() = $find_overloaded<routineTypeDefIR>(rdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))), then

        1. Return $find_routine_overloaded((GLOBAL), TC, (CURRENT id), argumentIR*{argumentIR <- argumentIR*})

      6. Else Phantom#411

    1. Else Phantom#412

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. Return $find_routine_overloaded((BLOCK), TC, (CURRENT id), argumentIR*{argumentIR <- argumentIR*})

    1. Else Phantom#413

;; ../../../../spec-concrete/5.02.1-context.watsup:442.1-443.29
def $find_routine_non_overloaded(p', TC, prefixedName)

1. If ((prefixedName matches pattern `TOP%`)), then

  1. (Let (TOP id) be prefixedName)

  2. Return $find_non_overloaded<routineTypeDefIR>(TC.GLOBAL.RDENV, id)

1. Else Phantom#414

2. Case analysis on p'

  1. Case (% matches pattern `GLOBAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. Return $find_non_overloaded<routineTypeDefIR>(TC.GLOBAL.RDENV, id)

    1. Else Phantom#415

  2. Case (% matches pattern `BLOCK`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. (Let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} be $find_non_overloaded<routineTypeDefIR>(TC.BLOCK.RDENV, id))

      3. If (((rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR)) be (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?})

        2. Return ?((rid, routineTypeDefIR))

      3. Else Phantom#416

      4. If ((?() = $find_non_overloaded<routineTypeDefIR>(TC.BLOCK.RDENV, id))), then

        1. Return $find_routine_non_overloaded((GLOBAL), TC, (CURRENT id))

      4. Else Phantom#417

    1. Else Phantom#418

  3. Case (% matches pattern `LOCAL`)

    1. If ((prefixedName matches pattern `CURRENT%`)), then

      1. (Let (CURRENT id) be prefixedName)

      2. Return $find_routine_non_overloaded((BLOCK), TC, (CURRENT id))

    1. Else Phantom#419

;; ../../../../spec-concrete/5.02.1-context.watsup:461.1-462.38
def $find_constructor_overloaded(TC, prefixedName, argumentIR*{argumentIR <- argumentIR*})

1. Case analysis on prefixedName

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be prefixedName)

    2. (Let cdenv be TC.GLOBAL.CDENV)

    3. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR*{argumentIR <- argumentIR*}))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be prefixedName)

    2. (Let cdenv be TC.GLOBAL.CDENV)

    3. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR*{argumentIR <- argumentIR*}))

    4. Return $find_overloaded<constructorTypeDefIR>(cdenv, id, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*})

;; ../../../../spec-concrete/5.02.1-context.watsup:473.1-474.33
def $find_constructors_non_overloaded(TC, prefixedName)

1. Case analysis on prefixedName

  1. Case (% matches pattern `TOP%`)

    1. (Let (TOP id) be prefixedName)

    2. (Let cdenv be TC.GLOBAL.CDENV)

    3. Return $find_non_overloadeds<constructorTypeDefIR>(cdenv, id)

  2. Case (% matches pattern `CURRENT%`)

    1. (Let (CURRENT id) be prefixedName)

    2. (Let cdenv be TC.GLOBAL.CDENV)

    3. Return $find_non_overloadeds<constructorTypeDefIR>(cdenv, id)

;; ../../../../spec-concrete/5.02.1-context.watsup:485.1-485.47
def $find_return_type(TC)

1. (Let localKind be TC.LOCAL.KIND)

2. Case analysis on localKind

  1. Case (% matches pattern `FUNC%`)

    1. (Let (FUNC typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  2. Case (% matches pattern `EXTERNFUNC%`)

    1. (Let (EXTERNFUNC typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  3. Case (% matches pattern `EXTERNMETHOD%`)

    1. (Let (EXTERNMETHOD typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

  4. Case (% matches pattern `EXTERNABSTRACTMETHOD%`)

    1. (Let (EXTERNABSTRACTMETHOD typeIR_ret) be localKind)

    2. Return ?(typeIR_ret)

3. If (((ACTION) = TC.LOCAL.KIND)), then

  1. Return ?(((VoidT) as typeIR))

4. If (((CONTROLAPPLYMETHOD) = TC.LOCAL.KIND)), then

  1. Return ?(((VoidT) as typeIR))

5. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.02.2-table-context.watsup:5.19-5.31
syntax matchKey = (typeIR, id)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:7.22-7.67
syntax matchAction = (prefixedName, parameterTypeIR*, argumentIR*)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:10.3-13.24
syntax matchPriority = {`VALUES%`(nat*), `INIT%`(bool), `DELTA%`(nat), `LARGEST_WINS%`(bool)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:16.3-17.17
syntax matchEntry = {`SIZE%`(nat), `CONST%`(bool)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:21.1-27.11
syntax matchMode = 
   | `NOPRI`()
   | `NOPRILPM%`(nat)
   | `PRI`()
   | `PRILPM`()

;; ../../../../spec-concrete/5.02.2-table-context.watsup:30.3-34.21
syntax tableContext = {`KEYS%`(matchKey*), `ACTIONS%`(matchAction*), `PRIORITIES%`(matchPriority), `ENTRIES%`(matchEntry), `MODE%`(matchMode)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:44.1-46.10
syntax tableEntryState = 
   | `LPM%`(nat)
   | `NOLPM`()

;; ../../../../spec-concrete/5.02.2-table-context.watsup:54.1-54.38
def $empty_tableContext

1. (Let matchPriority be {VALUES [], INIT false, DELTA 1, LARGEST_WINS true})

2. (Let matchEntry be {SIZE 0, CONST true})

3. Return {KEYS [], ACTIONS [], PRIORITIES matchPriority, ENTRIES matchEntry, MODE (NOPRI)}

;; ../../../../spec-concrete/5.02.2-table-context.watsup:76.1-76.54
def $add_key(TBLC, id, typeIR)

1. (Let matchKey be (typeIR, id))

2. Return TBLC[KEYS = TBLC.KEYS ++ [matchKey]]

;; ../../../../spec-concrete/5.02.2-table-context.watsup:84.1-84.90
def $add_action(TBLC, prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*})

1. (Let matchAction be (prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}))

2. Return TBLC[ACTIONS = TBLC.ACTIONS ++ [matchAction]]

;; ../../../../spec-concrete/5.02.2-table-context.watsup:92.1-92.58
def $add_table_priority(TBLC, n)

1. Return TBLC[PRIORITIES.VALUES = TBLC.PRIORITIES.VALUES ++ [n]]

;; ../../../../spec-concrete/5.02.2-table-context.watsup:103.1-103.58
def $update_mode(TBLC, id, typeIR)

1. Return $update_mode'(TBLC, id, $canon(typeIR))

;; ../../../../spec-concrete/5.02.2-table-context.watsup:104.1-104.59
def $update_mode'(TBLC, text', typeIR'')

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on typeIR''

      1. Case (% has type numberTypeIR)

        1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

        2. Case analysis on numberTypeIR

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT n) be numberTypeIR)

            2. If ((TBLC.MODE matches pattern `NOPRI`)), then

              1. Return TBLC[MODE = (NOPRILPM n)]

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT n) be numberTypeIR)

            2. If ((TBLC.MODE matches pattern `NOPRI`)), then

              1. Return TBLC[MODE = (NOPRILPM n)]

          3. Case (% matches pattern `VBitT%`)

            1. (Let (VBitT n) be numberTypeIR)

            2. If ((TBLC.MODE matches pattern `NOPRI`)), then

              1. Return TBLC[MODE = (NOPRILPM n)]

      2. Case (% has type aliasTypeIR)

        1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

        2. If ((aliasTypeIR matches pattern `NewT%%`)), then

          1. (Let (NewT _tid typeIR) be aliasTypeIR)

          2. Return $update_mode(TBLC, "lpm", typeIR)

    2. If ((TBLC.MODE matches pattern `PRI`)), then

      1. Return TBLC[MODE = (PRILPM)]

  2. Case (% = "range")

    1. If ((TBLC.MODE matches pattern `NOPRI`)), then

      1. Return TBLC[MODE = (PRI)]

    2. (Let matchMode be TBLC.MODE)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be matchMode)

      2. Return TBLC[MODE = (PRILPM)]

  3. Case (% = "ternary")

    1. If ((TBLC.MODE matches pattern `NOPRI`)), then

      1. Return TBLC[MODE = (PRI)]

    2. (Let matchMode be TBLC.MODE)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be matchMode)

      2. Return TBLC[MODE = (PRILPM)]

  4. Case (% = "optional")

    1. If ((TBLC.MODE matches pattern `NOPRI`)), then

      1. Return TBLC[MODE = (PRI)]

    2. (Let matchMode be TBLC.MODE)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM _nat) be matchMode)

      2. Return TBLC[MODE = (PRILPM)]

2. Otherwise

  1. Return TBLC

;; ../../../../spec-concrete/5.02.2-table-context.watsup:138.1-138.80
def $find_action(TBLC, prefixedName)

1. Return $find_action'(TBLC.ACTIONS, prefixedName)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:139.1-139.81
def $find_action'(matchAction*{matchAction <- matchAction*}, prefixedName)

1. Case analysis on matchAction*{matchAction <- matchAction*}

  1. Case (% matches pattern [])

    1. Return ?()

  2. Case (% matches pattern _ :: _)

    1. (Let matchAction_h :: matchAction_t*{matchAction_t <- matchAction_t*} be matchAction*{matchAction <- matchAction*})

    2. (Let (prefixedName', parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}) be matchAction_h)

    3. Case analysis on prefixedName'

      1. Case (% = prefixedName)

        1. Return ?((parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}))

      2. Case (% =/= prefixedName)

        1. Return $find_action'(matchAction_t*{matchAction_t <- matchAction_t*}, prefixedName)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:156.1-156.50
def $find_table_priority_last(TBLC)

1. (Let n*{n <- n*} be TBLC.PRIORITIES.VALUES)

2. If ((|n*{n <- n*}| > 0)), then

  1. (Let int be (|n*{n <- n*}| - 1))

  2. If ((int has type nat)), then

    1. (Let n' be (int as nat))

    2. Return n*{n <- n*}[n']

  2. Else Phantom#420

2. Else Phantom#421

;; ../../../../spec-concrete/5.02.2-table-context.watsup:167.1-167.78
def $join_tableEntryState(tableEntryState, tableEntryState')

1. Case analysis on tableEntryState

  1. Case (% matches pattern `NOLPM`)

    1. Case analysis on tableEntryState'

      1. Case (% matches pattern `LPM%`)

        1. (Let (LPM n) be tableEntryState')

        2. Return (LPM n)

      2. Case (% matches pattern `NOLPM`)

        1. Return (NOLPM)

  2. Case (% matches pattern `LPM%`)

    1. (Let (LPM n) be tableEntryState)

    2. If ((tableEntryState' matches pattern `NOLPM`)), then

      1. Return (LPM n)

    2. Else Phantom#422

;; ../../../../spec-concrete/5.02.2-table-context.watsup:173.1-173.40
def $tableEntry_lpm_prefix(value)

1. Return $tableEntry_lpm_prefix'(value, 0)

;; ../../../../spec-concrete/5.02.2-table-context.watsup:174.1-174.46
def $tableEntry_lpm_prefix'(value, n_prefix')

1. If ((value has type numberValue)), then

  1. (Let numberValue be (value as numberValue))

  2. If ((numberValue matches pattern `FBitV%%`)), then

    1. (Let (FBitV nat _bits) be numberValue)

    2. If ((nat = 0)), then

      1. Return n_prefix'

    2. Else Phantom#423

    3. If ((_bits has type nat)), then

      1. (Let n be (_bits as nat))

      2. If ((nat =/= 0)), then

        1. (Let int be (nat - 1))

        2. If ((int has type nat)), then

          1. (Let w' be (int as nat))

          2. If (((n \ 2) =/= 0)), then

            1. (Let int' be ((n - 1) / (2 as int)))

            2. If ((int' has type nat)), then

              1. (Let n' be (int' as nat))

              2. (Let value' be ((FBitV w' (n' as bits)) as value))

              3. Return $tableEntry_lpm_prefix'(value', (n_prefix' + 1))

            2. Else Phantom#424

          2. Else Phantom#425

        2. Else Phantom#426

      2. Else Phantom#427

      3. If ((n_prefix' = 0)), then

        1. If ((nat =/= 0)), then

          1. (Let int be (nat - 1))

          2. If ((int has type nat)), then

            1. (Let w' be (int as nat))

            2. If (((n \ 2) = 0)), then

              1. (Let value' be ((FBitV w' ((n / 2) as bits)) as value))

              2. Return $tableEntry_lpm_prefix'(value', 0)

            2. Else Phantom#428

          2. Else Phantom#429

        1. Else Phantom#430

      3. Else Phantom#431

    3. Else Phantom#432

  2. Else Phantom#433

1. Else Phantom#434

;; ../../../../spec-concrete/5.03-wellformed.watsup:5.1-7.20
relation Type_wf: bound, typeIR'''

1. Case analysis on typeIR'''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR''' as baseTypeIR))

    2. The relation holds

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR''' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `NameT%`)

        1. (Let (NameT tid) be namedTypeIR)

        2. If ($in_set<tid>(tid, bound)), then

          1. The relation holds

        2. Else Phantom#435

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT polyTypeDefIR typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

        2. (Let typeIR be $specialize_typeDef((polyTypeDefIR as typeDefIR), typeIR_arg*{typeIR_arg <- typeIR_arg*}))

        3. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

        3. Else Phantom#436

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `DefT%%`)

        1. (Let (DefT _tid typeIR) be aliasTypeIR)

        2. If ($nestable_typedef(typeIR)), then

          1. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

          1. Else Phantom#437

        2. Else Phantom#438

      2. Case (% matches pattern `NewT%%`)

        1. (Let (NewT _tid typeIR) be aliasTypeIR)

        2. If ($nestable_new(typeIR)), then

          1. If ((Type_wf: bound |- typeIR holds)), then

            1. The relation holds

          1. Else Phantom#439

        2. Else Phantom#440

  4. Case (% has type listTypeIR)

    1. (Let (ListT typeIR) be (typeIR''' as listTypeIR))

    2. If ($nestable_list(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

      1. Else Phantom#441

    2. Else Phantom#442

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR''' as tupleTypeIR))

    2. If ($nestable_tuple(typeIR))*{typeIR <- typeIR*}, then

      1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

        1. The relation holds

      1. Else Phantom#443

    2. Else Phantom#444

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR _nat) be (typeIR''' as headerStackTypeIR))

    2. If ($nestable_headerstack(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

      1. Else Phantom#445

    2. Else Phantom#446

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR id)*{id <- id*, typeIR <- typeIR*}) be (typeIR''' as structTypeIR))

    2. If ($distinct_<id>(id*{id <- id*})), then

      1. If ($nestable_struct(typeIR))*{typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

          1. The relation holds

        1. Else Phantom#447

      1. Else Phantom#448

    2. Else Phantom#449

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid (typeIR id)*{id <- id*, typeIR <- typeIR*}) be (typeIR''' as headerTypeIR))

    2. If ($distinct_<id>(id*{id <- id*})), then

      1. If ($nestable_header(typeIR))*{typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

          1. The relation holds

        1. Else Phantom#450

      1. Else Phantom#451

    2. Else Phantom#452

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid (typeIR id)*{id <- id*, typeIR <- typeIR*}) be (typeIR''' as headerUnionTypeIR))

    2. If ($distinct_<id>(id*{id <- id*})), then

      1. If ($nestable_headerunion(typeIR))*{typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

          1. The relation holds

        1. Else Phantom#453

      1. Else Phantom#454

    2. Else Phantom#455

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid id*{id <- id*}) be enumTypeIR)

        2. If ($distinct_<id>(id*{id <- id*})), then

          1. The relation holds

        2. Else Phantom#456

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid typeIR (id _value)*{_value <- _value*, id <- id*}) be enumTypeIR)

        2. If ($distinct_<id>(id*{id <- id*})), then

          1. If ($nestable_serenum(typeIR)), then

            1. If ((Type_wf: bound |- typeIR holds)), then

              1. The relation holds

            1. Else Phantom#457

          1. Else Phantom#458

        2. Else Phantom#459

  11. Case (% has type externObjectTypeIR)

    1. (Let (ExternT _tid ({ (_rid -> routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} })) be (typeIR''' as externObjectTypeIR))

    2. If ((RoutineTypeDef_wf: bound |- routineTypeDefIR holds))*{routineTypeDefIR <- routineTypeDefIR*}, then

      1. The relation holds

    2. Else Phantom#460

  12. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR''' as parserObjectTypeIR))

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. The relation holds

    2. Else Phantom#461

  13. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR''' as controlObjectTypeIR))

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. The relation holds

    2. Else Phantom#462

  14. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT tid typeIR*{typeIR <- typeIR*}) be (typeIR''' as packageObjectTypeIR))

    2. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

      1. The relation holds

    2. Else Phantom#463

  15. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid typeIR) be (typeIR''' as tableObjectTypeIR))

    2. (Let typeIR'' be $canon(typeIR))

    3. If ((typeIR'' has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR'' as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TableStructT%%`)), then

        1. (Let (TableStructT _tid' _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be tableTypeIR)

        2. If ((Type_wf: bound |- typeIR holds)), then

          1. The relation holds

        2. Else Phantom#464

      2. Else Phantom#465

    3. Else Phantom#466

  16. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR''' as defaultTypeIR))

    2. The relation holds

  17. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

          1. The relation holds

        2. Else Phantom#467

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

        2. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

          1. The relation holds

        2. Else Phantom#468

  18. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR id)*{id <- id*, typeIR <- typeIR*}) be recordTypeIR)

        2. If ($distinct_<id>(id*{id <- id*})), then

          1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

            1. The relation holds

          1. Else Phantom#469

        2. Else Phantom#470

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR id)*{id <- id*, typeIR <- typeIR*}) be recordTypeIR)

        2. If ($distinct_<id>(id*{id <- id*})), then

          1. If ((Type_wf: bound |- typeIR holds))*{typeIR <- typeIR*}, then

            1. The relation holds

          1. Else Phantom#471

        2. Else Phantom#472

  19. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR''' as invalidHeaderTypeIR))

    2. The relation holds

  20. Case (% has type setTypeIR)

    1. (Let (SetT typeIR) be (typeIR''' as setTypeIR))

    2. If ($nestable_set(typeIR)), then

      1. If ((Type_wf: bound |- typeIR holds)), then

        1. The relation holds

      1. Else Phantom#473

    2. Else Phantom#474

  21. Case (% has type tableTypeIR)

    1. (Let tableTypeIR be (typeIR''' as tableTypeIR))

    2. Case analysis on tableTypeIR

      1. Case (% matches pattern `TableEnumT%%`)

        1. (Let (TableEnumT _tid id*{id <- id*}) be tableTypeIR)

        2. If ($distinct_<id>(id*{id <- id*})), then

          1. The relation holds

        2. Else Phantom#475

      2. Case (% matches pattern `TableStructT%%`)

        1. (Let (TableStructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be tableTypeIR)

        2. The relation holds

;; ../../../../spec-concrete/5.03-wellformed.watsup:9.1-11.20
relation TypeDef_wf: bound, typeDefIR

1. Case analysis on typeDefIR

  1. Case (% has type monoTypeDefIR)

    1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

    2. If ((Type_wf: bound |- typeIR holds)), then

      1. The relation holds

    2. Else Phantom#476

  2. Case (% has type polyTypeDefIR)

    1. (Let (PolyTD typeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) be (typeDefIR as polyTypeDefIR))

    2. If ($distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})), then

      1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })))

      2. If ((Type_wf: bound_inner |- typeIR holds)), then

        1. The relation holds

      2. Else Phantom#477

    2. Else Phantom#478

;; ../../../../spec-concrete/5.03-wellformed.watsup:13.1-15.20
relation ParameterType_wf: bound, (direction typeIR _id value''?{value'' <- value''?})

1. Case analysis on value''?{value'' <- value''?}

  1. Case (% matches pattern ())

    1. If ((Type_wf: bound |- typeIR holds)), then

      1. If (($is_extern_object_typeIR($canon(typeIR)) => (direction = (NO)))), then

        1. The relation holds

      1. Else Phantom#479

    1. Else Phantom#480

  2. Case (% matches pattern (_))

    1. (Let ?(value) be value''?{value'' <- value''?})

    2. If ((Type_wf: bound |- typeIR holds)), then

      1. Case analysis on direction

        1. Case (% matches pattern `IN`)

          1. If (($is_extern_object_typeIR($canon(typeIR)) => (direction = (NO)))), then

            1. The relation holds

          1. Else Phantom#481

        2. Case (% matches pattern `NO`)

          1. If (($is_extern_object_typeIR($canon(typeIR)) => (direction = (NO)))), then

            1. The relation holds

          1. Else Phantom#482

      1. Else Phantom#483

    2. Else Phantom#484

;; ../../../../spec-concrete/5.03-wellformed.watsup:17.1-19.20
relation ParameterTypes_wf: bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

1. (Let (_direction _typeIR id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}

2. If ($distinct_<id>(id*{id <- id*})), then

  1. If ((ParameterType_wf: bound |- parameterTypeIR holds))*{parameterTypeIR <- parameterTypeIR*}, then

    1. The relation holds

  1. Else Phantom#485

2. Else Phantom#486

;; ../../../../spec-concrete/5.03-wellformed.watsup:21.1-23.20
relation RoutineType_wf: bound, routineTypeIR

1. Case analysis on routineTypeIR

  1. Case (% matches pattern `BuiltinFuncT%%`)

    1. (Let (BuiltinFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. If ((Type_wf: bound |- typeIR_ret holds)), then

        1. The relation holds

      1. Else Phantom#487

    2. Else Phantom#488

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_function(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

        1. Else Phantom#489

      2. Else Phantom#490

    2. Else Phantom#491

  3. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($directionless_trailing(direction*{direction <- direction*})), then

        1. If ($nestable_action(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

          1. The relation holds

        1. Else Phantom#492

      2. Else Phantom#493

    2. Else Phantom#494

  4. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_externfunction(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

        1. Else Phantom#495

      2. Else Phantom#496

    2. Else Phantom#497

  5. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. If ((Type_wf: bound |- typeIR_ret holds)), then

        1. The relation holds

      1. Else Phantom#498

    2. Else Phantom#499

  6. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_externmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

        1. Else Phantom#500

      2. Else Phantom#501

    2. Else Phantom#502

  7. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_externabstractmethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. If ((Type_wf: bound |- typeIR_ret holds)), then

          1. The relation holds

        1. Else Phantom#503

      2. Else Phantom#504

    2. Else Phantom#505

  8. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_parserapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. The relation holds

      2. Else Phantom#506

    2. Else Phantom#507

  9. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((ParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

      1. (Let (direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

      2. If ($nestable_controlapplymethod(direction, typeIR))*{direction <- direction*, typeIR <- typeIR*}, then

        1. The relation holds

      2. Else Phantom#508

    2. Else Phantom#509

  10. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typeIR) be routineTypeIR)

    2. If ((typeIR has type tableTypeIR)), then

      1. (Let tableTypeIR be (typeIR as tableTypeIR))

      2. If ((tableTypeIR matches pattern `TableStructT%%`)), then

        1. (Let (TableStructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be tableTypeIR)

        2. The relation holds

      2. Else Phantom#510

    2. Else Phantom#511

;; ../../../../spec-concrete/5.03-wellformed.watsup:25.1-27.20
relation RoutineTypeDef_wf: bound, routineTypeDefIR

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

      1. The relation holds

    2. Else Phantom#512

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. If ($distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})), then

      1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })))

      2. If ((RoutineType_wf: bound_inner |- routineTypeIR holds)), then

        1. The relation holds

      2. Else Phantom#513

    2. Else Phantom#514

;; ../../../../spec-concrete/5.03-wellformed.watsup:29.1-31.20
relation ConstructorParameterType_wf: bound, (direction typeIR _id _value?{_value <- _value?})

1. If ((direction matches pattern `NO`)), then

  1. If ((Type_wf: bound |- typeIR holds)), then

    1. The relation holds

  1. Else Phantom#515

1. Else Phantom#516

;; ../../../../spec-concrete/5.03-wellformed.watsup:33.1-35.20
relation ConstructorParameterTypes_wf: bound, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

1. (Let (_direction _typeIR id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}

2. If ($distinct_<id>(id*{id <- id*})), then

  1. If ((ConstructorParameterType_wf: bound |- parameterTypeIR holds))*{parameterTypeIR <- parameterTypeIR*}, then

    1. The relation holds

  1. Else Phantom#517

2. Else Phantom#518

;; ../../../../spec-concrete/5.03-wellformed.watsup:37.1-39.20
relation ConstructorType_wf: bound, (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_object)

1. If ((ConstructorParameterTypes_wf: bound |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} holds)), then

  1. If ((Type_wf: bound |- typeIR_object holds)), then

    1. (Let typeIR' be $canon(typeIR_object))

    2. Case analysis on typeIR'

      1. Case (% has type externObjectTypeIR)

        1. (Let (ExternT _tid _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

        2. (Let (_direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

        3. If ($nestable_constructor_extern(typeIR))*{typeIR <- typeIR*}, then

          1. The relation holds

        3. Else Phantom#519

      2. Case (% has type parserObjectTypeIR)

        1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

        2. (Let (_direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

        3. If ($nestable_constructor_parser(typeIR))*{typeIR <- typeIR*}, then

          1. The relation holds

        3. Else Phantom#520

      3. Case (% has type controlObjectTypeIR)

        1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

        2. (Let (_direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

        3. If ($nestable_constructor_control(typeIR))*{typeIR <- typeIR*}, then

          1. The relation holds

        3. Else Phantom#521

      4. Case (% has type packageObjectTypeIR)

        1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

        2. (Let (_direction typeIR _id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, parameterTypeIR <- parameterTypeIR*, typeIR <- typeIR*}

        3. If ($nestable_constructor_package(typeIR))*{typeIR <- typeIR*}, then

          1. The relation holds

        3. Else Phantom#522

    2. Else Phantom#523

  1. Else Phantom#524

1. Else Phantom#525

;; ../../../../spec-concrete/5.03-wellformed.watsup:41.1-43.20
relation ConstructorTypeDef_wf: bound, (PolyTD constructorTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*})

1. (Let (ConstructorT _constructorParameterTypeIR*{_constructorParameterTypeIR <- _constructorParameterTypeIR*} typeIR_object) be constructorTypeIR)

2. If ($distinct_<tid>(tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})), then

  1. (Let bound_inner be $union_set<tid>(bound, ({ tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*} })))

  2. If ((ConstructorType_wf: bound_inner |- constructorTypeIR holds)), then

    1. The relation holds

  2. Else Phantom#526

2. Else Phantom#527

;; ../../../../spec-concrete/5.03-wellformed.watsup:90.1-90.37
def $nestable_typedef(typeIR)

1. Return $nestable'_typedef($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:91.1-91.38
def $nestable'_typedef(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

      3. Case (% matches pattern `StrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

  6. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR' as objectTypeIR))

    2. Return ~$is_table_object_typeIR((objectTypeIR as typeIR))

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:110.1-110.33
def $nestable_new(typeIR)

1. Return $nestable'_new($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:111.1-111.34
def $nestable'_new(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:129.1-129.34
def $nestable_list(typeIR)

1. Return $nestable'_list($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:130.1-130.35
def $nestable'_list(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

      3. Case (% matches pattern `MatchKindT`)

        1. Return true

      4. Case (% matches pattern `StrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type dataTypeIR)

    1. (Let dataTypeIR be (typeIR' as dataTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:149.1-149.35
def $nestable_tuple(typeIR)

1. Return $nestable'_tuple($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:150.1-150.36
def $nestable'_tuple(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT _typeIR*{_typeIR <- _typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return true

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR _nat) be (typeIR'' as headerStackTypeIR))

    2. Return true

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as structTypeIR))

    2. Return true

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as headerTypeIR))

    2. Return true

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:175.1-175.41
def $nestable_headerstack(typeIR)

1. Return $nestable'_headerstack($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:176.1-176.42
def $nestable'_headerstack(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR' as headerTypeIR))

    2. Return true

  3. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR' as headerUnionTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:190.1-190.36
def $nestable_struct(typeIR)

1. Return $nestable'_struct($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:191.1-191.37
def $nestable'_struct(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT _typeIR*{_typeIR <- _typeIR*}) be (typeIR'' as tupleTypeIR))

    2. Return true

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR _nat) be (typeIR'' as headerStackTypeIR))

    2. Return true

  7. Case (% has type structTypeIR)

    1. (Let (StructT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as structTypeIR))

    2. Return true

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as headerTypeIR))

    2. Return true

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'' as headerUnionTypeIR))

    2. Return true

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:217.1-217.36
def $nestable_header(typeIR)

1. Return $nestable'_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:218.1-218.37
def $nestable'_header(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. Return true

  6. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:219.1-219.46
def $nestable_struct_in_header(typeIR)

1. Return $nestable'_struct_in_header($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:220.1-220.47
def $nestable'_struct_in_header(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. Return true

  6. Case (% has type structTypeIR)

    1. (Let (StructT _tid (typeIR _id)*{_id <- _id*, typeIR <- typeIR*}) be (typeIR'' as structTypeIR))

    2. If ($nestable_struct_in_header(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:254.1-254.41
def $nestable_headerunion(typeIR)

1. Return $nestable'_headerunion($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:255.1-255.42
def $nestable'_headerunion(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  3. Case (% has type headerTypeIR)

    1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR' as headerTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:275.1-275.37
def $nestable_serenum(typeIR)

1. Return $nestable'_serenum($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:276.1-276.38
def $nestable'_serenum(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $nestable_new_in_serenum(typeIR)

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:277.1-277.44
def $nestable_new_in_serenum(typeIR)

1. Return $nestable_new_in_serenum'($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:278.1-278.45
def $nestable_new_in_serenum'(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:354.1-354.33
def $nestable_set(typeIR)

1. Return $nestable'_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:355.1-355.34
def $nestable'_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SeqT%`)), then

      1. (Let (SeqT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}, then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:356.1-356.42
def $nestable_tuple_in_set(typeIR)

1. Return $nestable'_tuple_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:357.1-357.43
def $nestable'_tuple_in_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_tuple_in_set(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:358.1-358.45
def $nestable_sequence_in_set(typeIR)

1. Return $nestable'_sequence_in_set($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:359.1-359.46
def $nestable'_sequence_in_set(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. If ((namedTypeIR matches pattern `NameT%`)), then

      1. (Let (NameT _tid) be namedTypeIR)

      2. Return true

  4. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid _typeIR) be aliasTypeIR)

      2. Return true

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR*{typeIR <- typeIR*}) be (typeIR'' as tupleTypeIR))

    2. If ($nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}, then

      1. Return true

  6. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR'' as sequenceTypeIR))

    2. If ((sequenceTypeIR matches pattern `SeqT%`)), then

      1. (Let (SeqT typeIR*{typeIR <- typeIR*}) be sequenceTypeIR)

      2. If ($nestable_sequence_in_set(typeIR))*{typeIR <- typeIR*}, then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.03-wellformed.watsup:445.1-445.49
def $nestable_function(direction, typeIR)

1. Return $nestable_function'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:446.1-446.50
def $nestable_function'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR' as objectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:465.1-465.47
def $directionless_trailing(direction*{direction <- direction*})

1. Return $directionless_trailing'($rev_<direction>(direction*{direction <- direction*}), true)

;; ../../../../spec-concrete/5.03-wellformed.watsup:466.1-466.54
def $directionless_trailing'(direction''*{direction'' <- direction''*}, _bool')

1. Case analysis on direction''*{direction'' <- direction''*}

  1. Case (% matches pattern [])

    1. Return true

  2. Case (% matches pattern _ :: _)

    1. (Let direction :: direction_t*{direction_t <- direction_t*} be direction''*{direction'' <- direction''*})

    2. If ((direction matches pattern `NO`)), then

      1. Case analysis on _bool'

        1. Case (% = true)

          1. Return $directionless_trailing'(direction_t*{direction_t <- direction_t*}, true)

        2. Case (% = false)

          1. Return false

    2. Else Phantom#528

    3. (Let direction_h :: direction_t*{direction_t <- direction_t*} be direction''*{direction'' <- direction''*})

    4. If (~(direction_h matches pattern `NO`)), then

      1. Return $directionless_trailing'(direction_t*{direction_t <- direction_t*}, false)

    4. Else Phantom#529

;; ../../../../spec-concrete/5.03-wellformed.watsup:479.1-479.47
def $nestable_action(direction, typeIR)

1. Return $nestable_action'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:480.1-480.48
def $nestable_action'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. Return false

  3. Case (% has type objectTypeIR)

    1. (Let objectTypeIR be (typeIR' as objectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:498.1-498.55
def $nestable_externfunction(direction, typeIR)

1. Return $nestable_externfunction'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:499.1-499.56
def $nestable_externfunction'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:528.1-528.53
def $nestable_externmethod(direction, typeIR)

1. Return $nestable_externmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:529.1-529.54
def $nestable_externmethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:551.1-551.61
def $nestable_externabstractmethod(direction, typeIR)

1. Return $nestable_externabstractmethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:552.1-552.62
def $nestable_externabstractmethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:574.1-574.58
def $nestable_parserapplymethod(direction, typeIR)

1. Return $nestable_parserapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:575.1-575.59
def $nestable_parserapplymethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  5. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  6. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:596.1-596.59
def $nestable_controlapplymethod(direction, typeIR)

1. Return $nestable_controlapplymethod'(direction, $canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:597.1-597.60
def $nestable_controlapplymethod'(direction', typeIR')

1. Case analysis on typeIR'

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `StrT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR' as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If (~(direction' matches pattern `NO`)), then

        1. Return false

  3. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  4. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  5. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:653.1-653.48
def $nestable_constructor_extern(typeIR)

1. Return $nestable'_constructor_extern($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:654.1-654.49
def $nestable'_constructor_extern(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  3. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  4. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:673.1-673.48
def $nestable_constructor_parser(typeIR)

1. Return $nestable'_constructor_parser($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:674.1-674.49
def $nestable'_constructor_parser(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as controlObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:692.1-692.49
def $nestable_constructor_control(typeIR)

1. Return $nestable'_constructor_control($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:693.1-693.50
def $nestable'_constructor_control(typeIR')

1. Case analysis on typeIR'

  1. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR' as parserObjectTypeIR))

    2. Return false

  2. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

    2. Return false

  3. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

    2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.03-wellformed.watsup:711.1-711.49
def $nestable_constructor_package(typeIR)

1. Return $nestable'_constructor_package($canon(typeIR))

;; ../../../../spec-concrete/5.03-wellformed.watsup:712.1-712.50
def $nestable'_constructor_package(typeIR')

1. If ((typeIR' has type tableObjectTypeIR)), then

  1. (Let (TableT _tid _typeIR) be (typeIR' as tableObjectTypeIR))

  2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.04-typing-relation.watsup:6.1-8.23
relation Eval_static: p, TC, (expressionIR (( _typeIR' _ctk )))

1. Case analysis on expressionIR

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expressionIR as literalExpression))

    2. Case analysis on literalExpression

      1. Case (% matches pattern `BoolE%`)

        1. (Let (BoolE b) be literalExpression)

        2. Result in ((BoolV b) as value)

      2. Case (% matches pattern `NumE%`)

        1. (Let (NumE number) be literalExpression)

        2. Case analysis on number

          1. Case (% matches pattern `INT%`)

            1. (Let (INT i) be number)

            2. Result in ((IntV i) as value)

          2. Case (% matches pattern `FBIT%%`)

            1. (Let (FBIT n i) be number)

            2. Result in ((FBitV n i) as value)

          3. Case (% matches pattern `FINT%%`)

            1. (Let (FINT n i) be number)

            2. Result in ((FIntV n i) as value)

      3. Case (% matches pattern `StrE%`)

        1. (Let (StrE t) be literalExpression)

        2. Result in ((StrV t) as value)

  2. Case (% has type referenceExpression)

    1. (Let (NameE prefixedName) be (expressionIR as referenceExpression))

    2. (Let value'?{value' <- value'?} be $find_value(p, TC, prefixedName))

    3. If ((value'?{value' <- value'?} matches pattern (_))), then

      1. (Let ?(value) be value'?{value' <- value'?})

      2. Result in value

    3. Else Phantom#530

  3. Case (% has type defaultExpressionIR)

    1. (Let defaultExpressionIR be (expressionIR as defaultExpressionIR))

    2. Result in ((DefaultV) as value)

  4. Case (% has type unaryExpressionIR)

    1. (Let (UnE unop typedExpressionIR) be (expressionIR as unaryExpressionIR))

    2. Case analysis on unop

      1. Case (% matches pattern `BNOT`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_bnot(value)

      2. Case (% matches pattern `LNOT`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_lnot(value)

      3. Case (% matches pattern `UPLUS`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_plus(value)

      4. Case (% matches pattern `UMINUS`)

        1. (Eval_static: p TC |- typedExpressionIR ~> value)

        2. Result in $un_minus(value)

  5. Case (% has type binaryExpressionIR)

    1. (Let (BinE typedExpressionIR_l binop typedExpressionIR_r) be (expressionIR as binaryExpressionIR))

    2. Case analysis on binop

      1. Case (% matches pattern `PLUS`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_plus(value_l, value_r)

      2. Case (% matches pattern `SPLUS`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_satplus(value_l, value_r)

      3. Case (% matches pattern `MINUS`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_minus(value_l, value_r)

      4. Case (% matches pattern `SMINUS`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_satminus(value_l, value_r)

      5. Case (% matches pattern `MUL`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_mul(value_l, value_r)

      6. Case (% matches pattern `DIV`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_div(value_l, value_r)

      7. Case (% matches pattern `SHL`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_shl(value_l, value_r)

      8. Case (% matches pattern `SHR`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_shr(value_l, value_r)

      9. Case (% matches pattern `LE`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_le(value_l, value_r)) as value)

      10. Case (% matches pattern `GE`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_ge(value_l, value_r)) as value)

      11. Case (% matches pattern `LT`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_lt(value_l, value_r)) as value)

      12. Case (% matches pattern `GT`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_gt(value_l, value_r)) as value)

      13. Case (% matches pattern `EQ`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_eq(value_l, value_r)) as value)

      14. Case (% matches pattern `NE`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in ((BoolV $bin_ne(value_l, value_r)) as value)

      15. Case (% matches pattern `BAND`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_band(value_l, value_r)

      16. Case (% matches pattern `BXOR`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_bxor(value_l, value_r)

      17. Case (% matches pattern `BOR`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_bor(value_l, value_r)

      18. Case (% matches pattern `CONCAT`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_concat(value_l, value_r)

      19. Case (% matches pattern `LAND`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_land(value_l, value_r)

      20. Case (% matches pattern `LOR`)

        1. (Eval_static: p TC |- typedExpressionIR_l ~> value_l)

        2. (Eval_static: p TC |- typedExpressionIR_r ~> value_r)

        3. Result in $bin_lor(value_l, value_r)

    2. Else Phantom#531

  6. Case (% has type ternaryExpressionIR)

    1. (Let (TernE typedExpressionIR_cond typedExpressionIR_true typedExpressionIR_false) be (expressionIR as ternaryExpressionIR))

    2. (Eval_static: p TC |- typedExpressionIR_cond ~> value)

    3. If ((value = ((BoolV true) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_true ~> value_true)

      2. Result in value_true

    3. Else Phantom#532

    4. If ((value = ((BoolV false) as value))), then

      1. (Eval_static: p TC |- typedExpressionIR_false ~> value_false)

      2. Result in value_false

    4. Else Phantom#533

  7. Case (% has type castExpressionIR)

    1. (Let (CastE typeIR typedExpressionIR) be (expressionIR as castExpressionIR))

    2. (Eval_static: p TC |- typedExpressionIR ~> value)

    3. (Let value_cast be $cast_op(typeIR, value))

    4. Result in value_cast

  8. Case (% has type dataExpressionIR)

    1. (Let dataExpressionIR be (expressionIR as dataExpressionIR))

    2. Case analysis on dataExpressionIR

      1. Case (% matches pattern `InvalidE`)

        1. Result in ((InvalidHeaderV) as value)

      2. Case (% matches pattern `SeqE%`)

        1. (Let (SeqE typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

        3. Result in ((SeqV value*{value <- value*}) as value)

      3. Case (% matches pattern `SeqDefaultE%`)

        1. (Let (SeqDefaultE typedExpressionIR*{typedExpressionIR <- typedExpressionIR*}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

        3. Result in ((SeqDefaultV value*{value <- value*}) as value)

      4. Case (% matches pattern `RecordE%`)

        1. (Let (RecordE (name typedExpressionIR)*{name <- name*, typedExpressionIR <- typedExpressionIR*}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

        3. Result in ((RecordV (value name)*{name <- name*, value <- value*}) as value)

      5. Case (% matches pattern `RecordDefaultE%`)

        1. (Let (RecordDefaultE (name typedExpressionIR)*{name <- name*, typedExpressionIR <- typedExpressionIR*}) be dataExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR ~> value)*{typedExpressionIR <- typedExpressionIR*, value <- value*}

        3. Result in ((RecordDefaultV (value name)*{name <- name*, value <- value*}) as value)

  9. Case (% has type errorAccessExpression)

    1. (Let (ErrAccE name) be (expressionIR as errorAccessExpression))

    2. (Let name_error be "error." ++ name)

    3. (Let value?{value <- value?} be $find_value(p, TC, (CURRENT name_error)))

    4. If ((value?{value <- value?} matches pattern (_))), then

      1. (Let ?(value_error) be value?{value <- value?})

      2. Result in value_error

    4. Else Phantom#534

  10. Case (% has type memberAccessExpressionIR)

    1. (Let memberAccessExpressionIR be (expressionIR as memberAccessExpressionIR))

    2. Case analysis on memberAccessExpressionIR

      1. Case (% matches pattern `TypeAccE%%`)

        1. (Let (TypeAccE prefixedName name) be memberAccessExpressionIR)

        2. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName))

        3. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

          2. If ((typeDefIR has type monoTypeDefIR)), then

            1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

            2. If ((typeIR has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR as enumTypeIR))

              2. Case analysis on enumTypeIR

                1. Case (% matches pattern `EnumT%%`)

                  1. (Let (EnumT tid id_member*{id_member <- id_member*}) be enumTypeIR)

                  2. If (name is in id_member*{id_member <- id_member*}), then

                    1. Result in ((EnumV tid name) as value)

                  2. Else Phantom#535

                2. Case (% matches pattern `SEnumT%%%`)

                  1. (Let (SEnumT tid typeIR (id_member value_member)*{id_member <- id_member*, value_member <- value_member*}) be enumTypeIR)

                  2. (Let value'?{value' <- value'?} be $assoc_<id, value>(name, (id_member, value_member)*{id_member <- id_member*, value_member <- value_member*}))

                  3. If ((value'?{value' <- value'?} matches pattern (_))), then

                    1. (Let ?(value) be value'?{value' <- value'?})

                    2. Result in ((SEnumV tid name value) as value)

                  3. Else Phantom#536

            2. Else Phantom#537

          2. Else Phantom#538

        3. Else Phantom#539

      2. Case (% matches pattern `ExprAccE%%`)

        1. (Let (ExprAccE typedExpressionIR_base text) be memberAccessExpressionIR)

        2. If ((text = "size")), then

          1. (Let typeIR be _typeIR')

          2. If ((typeIR has type headerStackTypeIR)), then

            1. (Let (HeaderStackT _typeIR n_size) be (typeIR as headerStackTypeIR))

            2. Result in ((IntV (n_size as int)) as value)

          2. Else Phantom#540

        2. Else Phantom#541

        3. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

        4. (Let value' be value_base)

        5. Case analysis on value'

          1. Case (% has type structValue)

            1. (Let (StructV _tid (value_field id_field)*{id_field <- id_field*, value_field <- value_field*}) be (value' as structValue))

            2. (Let value''?{value'' <- value''?} be $assoc_<id, value>(text, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*}))

            3. If ((value''?{value'' <- value''?} matches pattern (_))), then

              1. (Let ?(value) be value''?{value'' <- value''?})

              2. Result in value

            3. Else Phantom#542

          2. Case (% has type headerValue)

            1. (Let (HeaderV _tid _bool (value_field id_field)*{id_field <- id_field*, value_field <- value_field*}) be (value' as headerValue))

            2. (Let value''?{value'' <- value''?} be $assoc_<id, value>(text, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*}))

            3. If ((value''?{value'' <- value''?} matches pattern (_))), then

              1. (Let ?(value) be value''?{value'' <- value''?})

              2. Result in value

            3. Else Phantom#543

          3. Case (% has type headerUnionValue)

            1. (Let (HeaderUnionV _tid (value_field id_field)*{id_field <- id_field*, value_field <- value_field*}) be (value' as headerUnionValue))

            2. (Let value''?{value'' <- value''?} be $assoc_<id, value>(text, (id_field, value_field)*{id_field <- id_field*, value_field <- value_field*}))

            3. If ((value''?{value'' <- value''?} matches pattern (_))), then

              1. (Let ?(value) be value''?{value'' <- value''?})

              2. Result in value

            3. Else Phantom#544

        5. Else Phantom#545

  11. Case (% has type indexAccessExpressionIR)

    1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

    2. Case analysis on indexAccessExpressionIR

      1. Case (% matches pattern `ArrAccE%%`)

        1. (Let (ArrAccE typedExpressionIR_base typedExpressionIR_index) be indexAccessExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

        3. (Eval_static: p TC |- typedExpressionIR_index ~> value_index)

        4. (Let value' be value_base)

        5. Case analysis on value'

          1. Case (% has type tupleValue)

            1. (Let (TupleV value_e*{value_e <- value_e*}) be (value' as tupleValue))

            2. (Let int'?{int' <- int'?} be $to_number(value_index))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_index be (int as nat))

                2. If ((n_index < |value_e*{value_e <- value_e*}|)), then

                  1. (Let value be value_e*{value_e <- value_e*}[n_index])

                  2. Result in value

                2. Else Phantom#546

              2. Else Phantom#547

            3. Else Phantom#548

          2. Case (% has type headerStackValue)

            1. (Let (HeaderStackV value_e*{value_e <- value_e*} _nat _nat') be (value' as headerStackValue))

            2. (Let int'?{int' <- int'?} be $to_number(value_index))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_index be (int as nat))

                2. If ((n_index < |value_e*{value_e <- value_e*}|)), then

                  1. (Let value be value_e*{value_e <- value_e*}[n_index])

                  2. Result in value

                2. Else Phantom#549

              2. Else Phantom#550

            3. Else Phantom#551

        5. Else Phantom#552

      2. Case (% matches pattern `BitAccE%%%`)

        1. (Let (BitAccE typedExpressionIR_base typedExpressionIR_hi typedExpressionIR_lo) be indexAccessExpressionIR)

        2. (Eval_static: p TC |- typedExpressionIR_base ~> value_base)

        3. (Eval_static: p TC |- typedExpressionIR_hi ~> value_hi)

        4. (Eval_static: p TC |- typedExpressionIR_lo ~> value_lo)

        5. Result in $bitacc_op(value_base, value_hi, value_lo)

  12. Case (% has type callExpressionIR)

    1. (Let callExpressionIR be (expressionIR as callExpressionIR))

    2. If ((callExpressionIR matches pattern `CallE%%%`)), then

      1. (Let (CallE routineTargetIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*}) be callExpressionIR)

      2. Case analysis on routineTargetIR

        1. Case (% matches pattern `MethodT%%`)

          1. (Let (MethodT typedExpressionIR_base name) be routineTargetIR)

          2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

            1. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern [])), then

              1. (Let (_expressionIR (( typeIR_base _ctk' ))) be typedExpressionIR_base)

              2. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                1. Result in $sizeof(typeIR_base, name)

              2. Else Phantom#553

            1. Else Phantom#554

          2. Else Phantom#555

        2. Case (% matches pattern `TypeT%%`)

          1. (Let (TypeT prefixedName name) be routineTargetIR)

          2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

            1. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern [])), then

              1. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName))

              2. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

                1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

                2. Case analysis on typeDefIR

                  1. Case (% has type monoTypeDefIR)

                    1. (Let (MonoTD typeIR_base) be (typeDefIR as monoTypeDefIR))

                    2. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                      1. Result in $sizeof(typeIR_base, name)

                    2. Else Phantom#556

                  2. Case (% has type polyTypeDefIR)

                    1. (Let (PolyTD typeIR_base tid*{tid <- tid*} tid'*{tid' <- tid'*}) be (typeDefIR as polyTypeDefIR))

                    2. If ((tid*{tid <- tid*} matches pattern [])), then

                      1. If ((tid'*{tid' <- tid'*} matches pattern [])), then

                        1. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

                          1. Result in $sizeof(typeIR_base, name)

                        1. Else Phantom#557

                      1. Else Phantom#558

                    2. Else Phantom#559

              2. Else Phantom#560

            1. Else Phantom#561

          2. Else Phantom#562

      2. Else Phantom#563

    2. Else Phantom#564

;; ../../../../spec-concrete/5.04-typing-relation.watsup:15.1-17.23
relation Type_ok: p, TC, typeOrVoid

1. Case analysis on typeOrVoid

  1. Case (% has type baseType)

    1. (Let baseType be (typeOrVoid as baseType))

    2. Case analysis on baseType

      1. Case (% matches pattern `BoolT`)

        1. Result in ((BoolT) as typeIR), []

      2. Case (% matches pattern `ErrT`)

        1. Result in ((ErrT) as typeIR), []

      3. Case (% matches pattern `MatchKindT`)

        1. Result in ((MatchKindT) as typeIR), []

      4. Case (% matches pattern `StrT`)

        1. Result in ((StrT) as typeIR), []

      5. Case (% matches pattern `IntT`)

        1. Result in ((IntT) as typeIR), []

      6. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT expression) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

        4. If ((ctk matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. (Let int'?{int' <- int'?} be $to_number(value))

          3. If ((int'?{int' <- int'?} matches pattern (_))), then

            1. (Let ?(int) be int'?{int' <- int'?})

            2. If ((int has type nat)), then

              1. (Let n be (int as nat))

              2. If ((n > 0)), then

                1. Result in ((FIntT n) as typeIR), []

              2. Else Phantom#565

            2. Else Phantom#566

          3. Else Phantom#567

        4. Else Phantom#568

      7. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT expression) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

        4. If ((ctk matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. (Let int'?{int' <- int'?} be $to_number(value))

          3. If ((int'?{int' <- int'?} matches pattern (_))), then

            1. (Let ?(int) be int'?{int' <- int'?})

            2. If ((int has type nat)), then

              1. (Let n be (int as nat))

              2. Result in ((FBitT n) as typeIR), []

            2. Else Phantom#569

          3. Else Phantom#570

        4. Else Phantom#571

      8. Case (% matches pattern `VBitT%`)

        1. (Let (VBitT expression) be baseType)

        2. (Expr_ok: p TC |- expression : typedExpressionIR)

        3. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

        4. If ((ctk matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR ~> value)

          2. (Let int'?{int' <- int'?} be $to_number(value))

          3. If ((int'?{int' <- int'?} matches pattern (_))), then

            1. (Let ?(int) be int'?{int' <- int'?})

            2. If ((int has type nat)), then

              1. (Let n be (int as nat))

              2. Result in ((VBitT n) as typeIR), []

            2. Else Phantom#572

          3. Else Phantom#573

        4. Else Phantom#574

  2. Case (% has type nameType)

    1. (Let (NameT prefixedName) be (typeOrVoid as nameType))

    2. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName))

    3. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

      2. Case analysis on typeDefIR

        1. Case (% has type monoTypeDefIR)

          1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

          2. Result in typeIR, []

        2. Case (% has type polyTypeDefIR)

          1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

          2. Result in ((SpecT polyTypeDefIR []) as typeIR), []

    3. Else Phantom#575

  3. Case (% has type specializedType)

    1. (Let (SpecT prefixedName typeArgument*{typeArgument <- typeArgument*}) be (typeOrVoid as specializedType))

    2. If ((typeArgument*{typeArgument <- typeArgument*} matches pattern [])), then

      1. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName))

      2. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

        1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

        2. If ((typeDefIR has type monoTypeDefIR)), then

          1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

          2. Result in typeIR, []

        2. Else Phantom#576

      2. Else Phantom#577

    2. Else Phantom#578

    3. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName))

    4. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let polyTypeDefIR be (typeDefIR as polyTypeDefIR))

        2. (Let (PolyTD typeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) be polyTypeDefIR)

        3. (TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} tid_fresh*{tid_fresh <- tid_fresh*})

        4. Result in ((SpecT polyTypeDefIR typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR), tid_fresh*{tid_fresh <- tid_fresh*}

      2. Else Phantom#579

    4. Else Phantom#580

  4. Case (% has type headerStackType)

    1. (Let (HeaderStackT namedType expression_size) be (typeOrVoid as headerStackType))

    2. Case analysis on namedType

      1. Case (% has type nameType)

        1. (Let nameType be (namedType as nameType))

        2. (Type_ok: p TC |- (nameType as typeOrVoid) : typeIR_base tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

          2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR_size)

          3. If ((ctk matches pattern `LCTK`)), then

            1. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

            2. (Let int'?{int' <- int'?} be $to_number(value_size))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_size be (int as nat))

                2. (Let typeIR_stack be ((HeaderStackT ((NameT "T") as typeIR) n_size) as typeIR))

                3. (Let polyTypeDefIR_stack be (PolyTD typeIR_stack ["T"] []))

                4. Result in ((SpecT polyTypeDefIR_stack [typeIR_base]) as typeIR), []

              2. Else Phantom#581

            3. Else Phantom#582

          3. Else Phantom#583

        3. Else Phantom#584

      2. Case (% has type specializedType)

        1. (Let specializedType be (namedType as specializedType))

        2. (Type_ok: p TC |- (specializedType as typeOrVoid) : typeIR_base tid_fresh*{tid_fresh <- tid_fresh*})

        3. (Expr_ok: p TC |- expression_size : typedExpressionIR_size)

        4. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR_size)

        5. If ((ctk matches pattern `LCTK`)), then

          1. (Eval_static: p TC |- typedExpressionIR_size ~> value_size)

          2. (Let int'?{int' <- int'?} be $to_number(value_size))

          3. If ((int'?{int' <- int'?} matches pattern (_))), then

            1. (Let ?(int) be int'?{int' <- int'?})

            2. If ((int has type nat)), then

              1. (Let n_size be (int as nat))

              2. (Let typeIR_stack be ((HeaderStackT ((NameT "T") as typeIR) n_size) as typeIR))

              3. (Let polyTypeDefIR_stack be (PolyTD typeIR_stack ["T"] []))

              4. Result in ((SpecT polyTypeDefIR_stack [typeIR_base]) as typeIR), tid_fresh*{tid_fresh <- tid_fresh*}

            2. Else Phantom#585

          3. Else Phantom#586

        5. Else Phantom#587

  5. Case (% has type listType)

    1. (Let (ListT typeArgument) be (typeOrVoid as listType))

    2. (TypeArgument_ok: p TC |- typeArgument : typeIR_arg tid_fresh*{tid_fresh <- tid_fresh*})

    3. (Let typeIR_list be ((ListT ((NameT "T") as typeIR)) as typeIR))

    4. (Let polyTypeDefIR_list be (PolyTD typeIR_list ["T"] []))

    5. Result in ((SpecT polyTypeDefIR_list [typeIR_arg]) as typeIR), tid_fresh*{tid_fresh <- tid_fresh*}

  6. Case (% has type tupleType)

    1. (Let (TupleT typeArgument*{typeArgument <- typeArgument*}) be (typeOrVoid as tupleType))

    2. (TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeIR_arg*{typeIR_arg <- typeIR_arg*} tid_fresh*{tid_fresh <- tid_fresh*})

    3. (Let i_idx*{i_idx <- i_idx*} be ($init_(|typeIR_arg*{typeIR_arg <- typeIR_arg*}|) as int*))

    4. (Let tid_tparam be "T" ++ $int_to_text(i_idx))*{i_idx <- i_idx*, tid_tparam <- tid_tparam*}

    5. (Let typeIR_tuple be ((TupleT ((NameT tid_tparam) as typeIR)*{tid_tparam <- tid_tparam*}) as typeIR))

    6. (Let polyTypeDefIR_tuple be (PolyTD typeIR_tuple tid_tparam*{tid_tparam <- tid_tparam*} []))

    7. Result in ((SpecT polyTypeDefIR_tuple typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR), tid_fresh*{tid_fresh <- tid_fresh*}

1. Else Phantom#588

2. If ((typeOrVoid matches pattern `VoidT`)), then

  1. Result in ((VoidT) as typeIR), []

2. Else Phantom#589

;; ../../../../spec-concrete/5.04-typing-relation.watsup:19.1-21.23
relation TypeArgument_ok: p, TC, typeArgument

1. If ((typeArgument has type type)), then

  1. (Let type be (typeArgument as type))

  2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR tid_impl*{tid_impl <- tid_impl*})

  3. Result in typeIR, tid_impl*{tid_impl <- tid_impl*}

1. Else Phantom#590

2. Case analysis on typeArgument

  1. Case (% matches pattern `VoidT`)

    1. Result in ((VoidT) as typeArgumentIR), []

  2. Case (% matches pattern `AnyT`)

    1. (Let tid_impl be $fresh_tid)

    2. Result in ((NameT tid_impl) as typeArgumentIR), [tid_impl]

2. Else Phantom#591

;; ../../../../spec-concrete/5.04-typing-relation.watsup:23.1-25.23
relation TypeArguments_ok: p, TC, typeArgument*{typeArgument <- typeArgument*}

1. Case analysis on typeArgument*{typeArgument <- typeArgument*}

  1. Case (% matches pattern [])

    1. Result in [], []

  2. Case (% matches pattern _ :: _)

    1. (Let typeArgument_h :: typeArgument_t*{typeArgument_t <- typeArgument_t*} be typeArgument*{typeArgument <- typeArgument*})

    2. (TypeArgument_ok: p TC |- typeArgument_h : typeArgumentIR_h tid_impl_h*{tid_impl_h <- tid_impl_h*})

    3. (TypeArguments_ok: p TC |- typeArgument_t*{typeArgument_t <- typeArgument_t*} : typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*} tid_impl_t*{tid_impl_t <- tid_impl_t*})

    4. (Let tid_impl*{tid_impl <- tid_impl*} be tid_impl_h*{tid_impl_h <- tid_impl_h*} ++ tid_impl_t*{tid_impl_t <- tid_impl_t*})

    5. Result in typeArgumentIR_h :: typeArgumentIR_t*{typeArgumentIR_t <- typeArgumentIR_t*}, tid_impl*{tid_impl <- tid_impl*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:31.1-31.54
relation Sub_expl: typeIR_a, typeIR_b

1. (Let typeIR_a_canon be $canon(typeIR_a))

2. (Let typeIR_b_canon be $canon(typeIR_b))

3. If ((Sub_expl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

  1. The relation holds

3. Else Phantom#592

;; ../../../../spec-concrete/5.04-typing-relation.watsup:32.1-32.60
relation Sub_expl_canon: typeIR_a, typeIR_b

1. Case analysis on (Type_alpha: typeIR_a ~~ typeIR_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_expl_canon_neq: typeIR_a <: typeIR_b holds)), then

      1. The relation holds

    1. Else Phantom#593

;; ../../../../spec-concrete/5.04-typing-relation.watsup:33.1-33.64
relation Sub_expl_canon_neq: typeIR''''', typeIR''''''

1. If ((typeIR''''' = ((FBitT 1) as typeIR))), then

  1. If ((typeIR'''''' has type primitiveTypeIR)), then

    1. (Let primitiveTypeIR be (typeIR'''''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. The relation holds

    2. Else Phantom#594

  1. Else Phantom#595

1. Else Phantom#596

2. Case analysis on typeIR'''''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR''''' as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `BoolT`)), then

      1. If ((typeIR'''''' = ((FBitT 1) as typeIR))), then

        1. The relation holds

      1. Else Phantom#597

    2. Else Phantom#598

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR''''' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Case analysis on typeIR''''''

          1. Case (% has type primitiveTypeIR)

            1. (Let primitiveTypeIR be (typeIR'''''' as primitiveTypeIR))

            2. If ((primitiveTypeIR matches pattern `BoolT`)), then

              1. The relation holds

            2. Else Phantom#599

          2. Case (% has type numberTypeIR)

            1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

            2. Case analysis on numberTypeIR'

              1. Case (% matches pattern `FIntT%`)

                1. (Let (FIntT _nat) be numberTypeIR')

                2. The relation holds

              2. Case (% matches pattern `FBitT%`)

                1. (Let (FBitT _nat) be numberTypeIR')

                2. The relation holds

            2. Else Phantom#600

        1. Else Phantom#601

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. If ((typeIR'''''' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `IntT`)

              1. The relation holds

            2. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT w_b) be numberTypeIR')

              2. The relation holds

            3. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT w') be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

              2. Else Phantom#602

          2. Else Phantom#603

        2. Else Phantom#604

      3. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. If ((typeIR'''''' has type numberTypeIR)), then

          1. (Let numberTypeIR' be (typeIR'''''' as numberTypeIR))

          2. Case analysis on numberTypeIR'

            1. Case (% matches pattern `IntT`)

              1. The relation holds

            2. Case (% matches pattern `FIntT%`)

              1. (Let (FIntT w') be numberTypeIR')

              2. If ((_nat = w')), then

                1. The relation holds

              2. Else Phantom#605

            3. Case (% matches pattern `FBitT%`)

              1. (Let (FBitT w_b) be numberTypeIR')

              2. The relation holds

          2. Else Phantom#606

        2. Else Phantom#607

    2. Else Phantom#608

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR''''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR_a) be aliasTypeIR)

      2. If ((Sub_impl: typeIR_a <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#609

    2. Else Phantom#610

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR''''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR_a _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. If ((Sub_impl: typeIR_a <: typeIR'''''' holds)), then

        1. The relation holds

      2. Else Phantom#611

    2. Else Phantom#612

  5. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR''''' as defaultTypeIR))

    2. If ($is_defaultable_typeIR(typeIR'''''')), then

      1. The relation holds

    2. Else Phantom#613

  6. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR''''' as invalidHeaderTypeIR))

    2. Case analysis on typeIR''''''

      1. Case (% has type headerTypeIR)

        1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'''''' as headerTypeIR))

        2. The relation holds

      2. Case (% has type headerUnionTypeIR)

        1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR'''''' as headerUnionTypeIR))

        2. The relation holds

    2. Else Phantom#614

  7. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR''''' as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type listTypeIR)

            1. (Let (ListT typeIR_b) be (typeIR'''''' as listTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

              1. The relation holds

            2. Else Phantom#615

          2. Case (% has type tupleTypeIR)

            1. (Let (TupleT typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR'''''' as tupleTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#616

          3. Case (% has type headerStackTypeIR)

            1. (Let (HeaderStackT typeIR_b n_size) be (typeIR'''''' as headerStackTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)), then

              1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

                1. The relation holds

              1. Else Phantom#617

            2. Else Phantom#618

          4. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as structTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#619

          5. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as headerTypeIR))

            2. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#620

        2. Else Phantom#621

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type tupleTypeIR)

            1. (Let (TupleT typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR'''''' as tupleTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#622

              2. Else Phantom#623

            2. Else Phantom#624

          2. Case (% has type headerStackTypeIR)

            1. (Let (HeaderStackT typeIR_b n_size) be (typeIR'''''' as headerStackTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)), then

              1. If ((Sub_expl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

                1. If ($is_defaultable_typeIR(typeIR_b)), then

                  1. The relation holds

                1. Else Phantom#625

              1. Else Phantom#626

            2. Else Phantom#627

          3. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as structTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#628

              2. Else Phantom#629

            2. Else Phantom#630

          4. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as headerTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_expl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#631

              2. Else Phantom#632

            2. Else Phantom#633

        2. Else Phantom#634

  8. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR''''' as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR_a id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as structTypeIR))

            2. If ($eq_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}, then

                    1. The relation holds

                  2. Else Phantom#635

                3. Else Phantom#636

              2. Else Phantom#637

            2. Else Phantom#638

          2. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}, then

                    1. The relation holds

                  2. Else Phantom#639

                3. Else Phantom#640

              2. Else Phantom#641

            2. Else Phantom#642

        2. Else Phantom#643

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR_a id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. Case analysis on typeIR''''''

          1. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as structTypeIR))

            2. If ($sub_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}, then

                    1. (Let ({ id_default*{id_default <- id_default*} }) be $diff_set<id>(({ id_b*{id_b <- id_b*} }), ({ id_a*{id_a <- id_a*} })))

                    2. (Let typeIR''''?{typeIR'''' <- typeIR''''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}

                    3. If ((typeIR''''?{typeIR'''' <- typeIR''''?} matches pattern (_)))*{typeIR''''? <- typeIR''''?*}, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                        1. The relation holds

                      2. Else Phantom#644

                    3. Else Phantom#645

                  2. Else Phantom#646

                3. Else Phantom#647

              2. Else Phantom#648

            2. Else Phantom#649

          2. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR'''''' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}

                  2. If ((Sub_expl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}, then

                    1. (Let ({ id_default*{id_default <- id_default*} }) be $diff_set<id>(({ id_b*{id_b <- id_b*} }), ({ id_a*{id_a <- id_a*} })))

                    2. (Let typeIR''''?{typeIR'''' <- typeIR''''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}

                    3. If ((typeIR''''?{typeIR'''' <- typeIR''''?} matches pattern (_)))*{typeIR''''? <- typeIR''''?*}, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                        1. The relation holds

                      2. Else Phantom#650

                    3. Else Phantom#651

                  2. Else Phantom#652

                3. Else Phantom#653

              2. Else Phantom#654

            2. Else Phantom#655

        2. Else Phantom#656

  9. Case (% has type setTypeIR)

    1. (Let (SetT typeIR_a) be (typeIR''''' as setTypeIR))

    2. If ((typeIR'''''' has type setTypeIR)), then

      1. (Let (SetT typeIR_b) be (typeIR'''''' as setTypeIR))

      2. If ((Sub_expl: typeIR_a <: typeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#657

    2. Else Phantom#658

2. Else Phantom#659

3. Case analysis on typeIR''''''

  1. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'''''' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR_b) be aliasTypeIR)

      2. If ((Sub_impl: typeIR''''' <: typeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#660

    2. Else Phantom#661

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'''''' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR_b _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. If ((Sub_impl: typeIR''''' <: typeIR_b holds)), then

        1. The relation holds

      2. Else Phantom#662

    2. Else Phantom#663

  3. Case (% has type setTypeIR)

    1. (Let (SetT typeIR_b) be (typeIR'''''' as setTypeIR))

    2. If (~$is_set_typeIR(typeIR''''')), then

      1. If ((Sub_expl: typeIR''''' <: typeIR_b holds)), then

        1. The relation holds

      1. Else Phantom#664

    2. Else Phantom#665

3. Else Phantom#666

;; ../../../../spec-concrete/5.04-typing-relation.watsup:35.1-35.54
relation Sub_impl: typeIR_a, typeIR_b

1. (Let typeIR_a_canon be $canon(typeIR_a))

2. (Let typeIR_b_canon be $canon(typeIR_b))

3. If ((Sub_impl_canon: typeIR_a_canon <: typeIR_b_canon holds)), then

  1. The relation holds

3. Else Phantom#667

;; ../../../../spec-concrete/5.04-typing-relation.watsup:36.1-36.60
relation Sub_impl_canon: typeIR_a, typeIR_b

1. Case analysis on (Type_alpha: typeIR_a ~~ typeIR_b holds)

  1. Case true

    1. The relation holds

  2. Case false

    1. If ((Sub_impl_canon_neq: typeIR_a <: typeIR_b holds)), then

      1. The relation holds

    1. Else Phantom#668

;; ../../../../spec-concrete/5.04-typing-relation.watsup:37.1-37.64
relation Sub_impl_canon_neq: typeIR, typeIR'''''

1. Case analysis on typeIR

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. If ((numberTypeIR matches pattern `IntT`)), then

      1. If ((typeIR''''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat) be numberTypeIR')

            2. The relation holds

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat) be numberTypeIR')

            2. The relation holds

        2. Else Phantom#669

      1. Else Phantom#670

    2. Else Phantom#671

  2. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR_a _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. If ((Sub_impl: typeIR_a <: typeIR''''' holds)), then

        1. The relation holds

      2. Else Phantom#672

    2. Else Phantom#673

  3. Case (% has type defaultTypeIR)

    1. (Let defaultTypeIR be (typeIR as defaultTypeIR))

    2. If ($is_defaultable_typeIR(typeIR''''')), then

      1. The relation holds

    2. Else Phantom#674

  4. Case (% has type invalidHeaderTypeIR)

    1. (Let invalidHeaderTypeIR be (typeIR as invalidHeaderTypeIR))

    2. Case analysis on typeIR'''''

      1. Case (% has type headerTypeIR)

        1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR''''' as headerTypeIR))

        2. The relation holds

      2. Case (% has type headerUnionTypeIR)

        1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR''''' as headerUnionTypeIR))

        2. The relation holds

    2. Else Phantom#675

  5. Case (% has type sequenceTypeIR)

    1. (Let sequenceTypeIR be (typeIR as sequenceTypeIR))

    2. Case analysis on sequenceTypeIR

      1. Case (% matches pattern `SeqT%`)

        1. (Let (SeqT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type listTypeIR)

            1. (Let (ListT typeIR_b) be (typeIR''''' as listTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

              1. The relation holds

            2. Else Phantom#676

          2. Case (% has type tupleTypeIR)

            1. (Let (TupleT typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR''''' as tupleTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#677

          3. Case (% has type headerStackTypeIR)

            1. (Let (HeaderStackT typeIR_b n_size) be (typeIR''''' as headerStackTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| <= n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

                1. The relation holds

              1. Else Phantom#678

            2. Else Phantom#679

          4. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR''''' as structTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#680

          5. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR''''' as headerTypeIR))

            2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

              1. The relation holds

            2. Else Phantom#681

          6. Case (% has type sequenceTypeIR)

            1. (Let sequenceTypeIR' be (typeIR''''' as sequenceTypeIR))

            2. If ((sequenceTypeIR' matches pattern `SeqT%`)), then

              1. (Let (SeqT typeIR_b*{typeIR_b <- typeIR_b*}) be sequenceTypeIR')

              2. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*, typeIR_b <- typeIR_b*}, then

                1. The relation holds

              2. Else Phantom#682

            2. Else Phantom#683

        2. Else Phantom#684

      2. Case (% matches pattern `SeqDefaultT%`)

        1. (Let (SeqDefaultT typeIR_a*{typeIR_a <- typeIR_a*}) be sequenceTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type tupleTypeIR)

            1. (Let (TupleT typeIR_b*{typeIR_b <- typeIR_b*}) be (typeIR''''' as tupleTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#685

              2. Else Phantom#686

            2. Else Phantom#687

          2. Case (% has type headerStackTypeIR)

            1. (Let (HeaderStackT typeIR_b n_size) be (typeIR''''' as headerStackTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < n_size)), then

              1. If ((Sub_impl: typeIR_a <: typeIR_b holds))*{typeIR_a <- typeIR_a*}, then

                1. If ($is_defaultable_typeIR(typeIR_b)), then

                  1. The relation holds

                1. Else Phantom#688

              1. Else Phantom#689

            2. Else Phantom#690

          3. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR''''' as structTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#691

              2. Else Phantom#692

            2. Else Phantom#693

          4. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b _id)*{_id <- _id*, typeIR_b <- typeIR_b*}) be (typeIR''''' as headerTypeIR))

            2. If ((|typeIR_a*{typeIR_a <- typeIR_a*}| < |typeIR_b*{typeIR_b <- typeIR_b*}|)), then

              1. (Let (typeIR_b_non_default*{typeIR_b_non_default <- typeIR_b_non_default*}, typeIR_b_default*{typeIR_b_default <- typeIR_b_default*}) be $partition_<typeIR>(typeIR_b*{typeIR_b <- typeIR_b*}, |typeIR_a*{typeIR_a <- typeIR_a*}|))

              2. If ((Sub_impl: typeIR_a <: typeIR_b_non_default holds))*{typeIR_a <- typeIR_a*, typeIR_b_non_default <- typeIR_b_non_default*}, then

                1. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                  1. The relation holds

                1. Else Phantom#694

              2. Else Phantom#695

            2. Else Phantom#696

        2. Else Phantom#697

  6. Case (% has type recordTypeIR)

    1. (Let recordTypeIR be (typeIR as recordTypeIR))

    2. Case analysis on recordTypeIR

      1. Case (% matches pattern `RecordT%`)

        1. (Let (RecordT (typeIR_a id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR''''' as structTypeIR))

            2. If ($eq_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}, then

                    1. The relation holds

                  2. Else Phantom#698

                3. Else Phantom#699

              2. Else Phantom#700

            2. Else Phantom#701

          2. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR''''' as headerTypeIR))

            2. If ($eq_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_aligned <- typeIR_b_aligned*}

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_aligned <- typeIR_b_aligned*}, then

                    1. The relation holds

                  2. Else Phantom#702

                3. Else Phantom#703

              2. Else Phantom#704

            2. Else Phantom#705

        2. Else Phantom#706

      2. Case (% matches pattern `RecordDefaultT%`)

        1. (Let (RecordDefaultT (typeIR_a id_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*}) be recordTypeIR)

        2. Case analysis on typeIR'''''

          1. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR''''' as structTypeIR))

            2. If ($sub_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}, then

                    1. (Let ({ id_default*{id_default <- id_default*} }) be $diff_set<id>(({ id_b*{id_b <- id_b*} }), ({ id_a*{id_a <- id_a*} })))

                    2. (Let typeIR''''?{typeIR'''' <- typeIR''''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}

                    3. If ((typeIR''''?{typeIR'''' <- typeIR''''?} matches pattern (_)))*{typeIR''''? <- typeIR''''?*}, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                        1. The relation holds

                      2. Else Phantom#707

                    3. Else Phantom#708

                  2. Else Phantom#709

                3. Else Phantom#710

              2. Else Phantom#711

            2. Else Phantom#712

          2. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_b id_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*}) be (typeIR''''' as headerTypeIR))

            2. If ($sub_set<id>(({ id_a*{id_a <- id_a*} }), ({ id_b*{id_b <- id_b*} }))), then

              1. (Let typeIR''?{typeIR'' <- typeIR''?} be $find_map<id, typeIR>(({ (id_a -> typeIR_a)*{id_a <- id_a*, typeIR_a <- typeIR_a*} }), id_a))*{id_a <- id_a*, typeIR''? <- typeIR''?*}

              2. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_)))*{typeIR''? <- typeIR''?*}, then

                1. (Let ?(typeIR_a_aligned) be typeIR''?{typeIR'' <- typeIR''?})*{typeIR''? <- typeIR''?*, typeIR_a_aligned <- typeIR_a_aligned*}

                2. (Let typeIR'''?{typeIR''' <- typeIR'''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_a))*{id_a <- id_a*, typeIR'''? <- typeIR'''?*}

                3. If ((typeIR'''?{typeIR''' <- typeIR'''?} matches pattern (_)))*{typeIR'''? <- typeIR'''?*}, then

                  1. (Let ?(typeIR_b_non_default_aligned) be typeIR'''?{typeIR''' <- typeIR'''?})*{typeIR'''? <- typeIR'''?*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}

                  2. If ((Sub_impl: typeIR_a_aligned <: typeIR_b_non_default_aligned holds))*{typeIR_a_aligned <- typeIR_a_aligned*, typeIR_b_non_default_aligned <- typeIR_b_non_default_aligned*}, then

                    1. (Let ({ id_default*{id_default <- id_default*} }) be $diff_set<id>(({ id_b*{id_b <- id_b*} }), ({ id_a*{id_a <- id_a*} })))

                    2. (Let typeIR''''?{typeIR'''' <- typeIR''''?} be $find_map<id, typeIR>(({ (id_b -> typeIR_b)*{id_b <- id_b*, typeIR_b <- typeIR_b*} }), id_default))*{id_default <- id_default*, typeIR''''? <- typeIR''''?*}

                    3. If ((typeIR''''?{typeIR'''' <- typeIR''''?} matches pattern (_)))*{typeIR''''? <- typeIR''''?*}, then

                      1. (Let ?(typeIR_b_default) be typeIR''''?{typeIR'''' <- typeIR''''?})*{typeIR''''? <- typeIR''''?*, typeIR_b_default <- typeIR_b_default*}

                      2. If ($is_defaultable_typeIR(typeIR_b_default))*{typeIR_b_default <- typeIR_b_default*}, then

                        1. The relation holds

                      2. Else Phantom#713

                    3. Else Phantom#714

                  2. Else Phantom#715

                3. Else Phantom#716

              2. Else Phantom#717

            2. Else Phantom#718

        2. Else Phantom#719

1. Else Phantom#720

;; ../../../../spec-concrete/5.04-typing-relation.watsup:43.1-45.23
relation Expr_ok: p, TC, expression'''

1. Case analysis on expression'''

  1. Case (% has type literalExpression)

    1. (Let literalExpression be (expression''' as literalExpression))

    2. Case analysis on literalExpression

      1. Case (% matches pattern `BoolE%`)

        1. (Let (BoolE b) be literalExpression)

        2. (Let expressionNoteIR be (( ((BoolT) as typeIR) (LCTK) )))

        3. Result in (((BoolE b) as expressionIR) expressionNoteIR)

      2. Case (% matches pattern `NumE%`)

        1. (Let (NumE number) be literalExpression)

        2. Case analysis on number

          1. Case (% matches pattern `INT%`)

            1. (Let (INT i) be number)

            2. (Let expressionNoteIR be (( ((IntT) as typeIR) (LCTK) )))

            3. Result in (((NumE (INT i)) as expressionIR) expressionNoteIR)

          2. Case (% matches pattern `FINT%%`)

            1. (Let (FINT n i) be number)

            2. (Let expressionNoteIR be (( ((FIntT n) as typeIR) (LCTK) )))

            3. Result in (((NumE (FINT n i)) as expressionIR) expressionNoteIR)

          3. Case (% matches pattern `FBIT%%`)

            1. (Let (FBIT n i) be number)

            2. (Let expressionNoteIR be (( ((FBitT n) as typeIR) (LCTK) )))

            3. Result in (((NumE (FBIT n i)) as expressionIR) expressionNoteIR)

      3. Case (% matches pattern `StrE%`)

        1. (Let (StrE t) be literalExpression)

        2. (Let expressionNoteIR be (( ((StrT) as typeIR) (LCTK) )))

        3. Result in (((StrE t) as expressionIR) expressionNoteIR)

  2. Case (% has type referenceExpression)

    1. (Let (NameE prefixedName) be (expression''' as referenceExpression))

    2. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_var(p, TC, prefixedName))

    3. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

      1. (Let ?((_direction typeIR ctk _value?{_value <- _value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

      2. (Let expressionNoteIR be (( typeIR ctk )))

      3. Result in (((NameE prefixedName) as expressionIR) expressionNoteIR)

    3. Else Phantom#721

  3. Case (% has type defaultExpression)

    1. (Let defaultExpression be (expression''' as defaultExpression))

    2. (Let expressionNoteIR be (( ((DefaultT) as typeIR) (LCTK) )))

    3. Result in (((DefaultE) as expressionIR) expressionNoteIR)

  4. Case (% has type unaryExpression)

    1. (Let (UnE unop expression) be (expression''' as unaryExpression))

    2. Case analysis on unop

      1. Case (% matches pattern `LNOT`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR, $compat_lnot))

        3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

          2. (Let (_expressionIR expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((UnE (LNOT) typedExpressionIR_reduced) as expressionIR) expressionNoteIR)

        3. Else Phantom#722

      2. Case (% matches pattern `BNOT`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR, $compat_bnot))

        3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

          2. (Let (_expressionIR expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((UnE (BNOT) typedExpressionIR_reduced) as expressionIR) expressionNoteIR)

        3. Else Phantom#723

      3. Case (% matches pattern `UPLUS`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

        3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

          2. (Let (_expressionIR expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((UnE unop typedExpressionIR_reduced) as expressionIR) expressionNoteIR)

        3. Else Phantom#724

      4. Case (% matches pattern `UMINUS`)

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR, $compat_uplusminus))

        3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

          2. (Let (_expressionIR expressionNoteIR) be typedExpressionIR_reduced)

          3. Result in (((UnE unop typedExpressionIR_reduced) as expressionIR) expressionNoteIR)

        3. Else Phantom#725

  5. Case (% has type binaryExpression)

    1. (Let (BinE expression_l binop expression_r) be (expression''' as binaryExpression))

    2. Case analysis on binop

      1. Case (% is in [(PLUS), (MINUS), (MUL)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_plusminusmul))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#726

        4. Else Phantom#727

      2. Case (% is in [(SPLUS), (SMINUS)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_satplusminus))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#728

        4. Else Phantom#729

      3. Case (% is in [(DIV), (MOD)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_divmod))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. Case analysis on (ctk_r_reduced matches pattern `LCTK`)

              1. Case true

                1. (Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r)

                2. (Let int'?{int' <- int'?} be $to_number(value_r))

                3. If ((int'?{int' <- int'?} matches pattern (_))), then

                  1. (Let ?(int) be int'?{int' <- int'?})

                  2. If ((int has type nat)), then

                    1. (Let n_r be (int as nat))

                    2. If ((n_r > 0)), then

                      1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                      2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                      3. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

                    2. Else Phantom#730

                  2. Else Phantom#731

                3. Else Phantom#732

              2. Case false

                1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

                2. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

                3. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#733

        4. Else Phantom#734

      4. Case (% is in [(SHL), (SHR)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_shift))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (_expressionIR (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

          3. (Let (_expressionIR' (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          4. If ($is_fixed_bit_typeIR(typeIR_r_reduced)), then

            1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

            3. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          4. Else Phantom#735

          5. If ((ctk_r_reduced matches pattern `LCTK`)), then

            1. If ($is_arbitrary_int_typeIR(typeIR_r_reduced)), then

              1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

              2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

              3. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

            1. Else Phantom#736

            2. If ($is_fixed_int_typeIR(typeIR_r_reduced)), then

              1. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

              2. (Let expressionNoteIR be (( typeIR_l_reduced ctk_reduced )))

              3. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

            2. Else Phantom#737

          5. Else Phantom#738

        4. Else Phantom#739

      5. Case (% is in [(EQ), (NE)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (_expressionIR (( typeIR_cast ctk_l_cast ))) be typedExpressionIR_l_cast)

          3. (Let (_expressionIR' (( _typeIR ctk_r_cast ))) be typedExpressionIR_r_cast)

          4. If ($is_equalable_typeIR(typeIR_cast)), then

            1. (Let ctk_cast be $join_ctk(ctk_l_cast, ctk_r_cast))

            2. (Let expressionNoteIR be (( ((BoolT) as typeIR) ctk_cast )))

            3. Result in (((BinE typedExpressionIR_l_cast binop typedExpressionIR_r_cast) as expressionIR) expressionNoteIR)

          4. Else Phantom#740

        4. Else Phantom#741

      6. Case (% is in [(LE), (GE), (LT), (GT)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_compare))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( ((BoolT) as typeIR) ctk_reduced )))

            6. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#742

        4. Else Phantom#743

      7. Case (% is in [(BAND), (BXOR), (BOR)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_bitwise))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#744

        4. Else Phantom#745

      8. Case (% is in [(LAND), (LOR)])

        1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

        2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_logical))

          3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

            2. (Let (_expressionIR (( typeIR_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

            3. (Let (_expressionIR' (( _typeIR ctk_r_reduced ))) be typedExpressionIR_r_reduced)

            4. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

            5. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

            6. Result in (((BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#746

        4. Else Phantom#747

    2. Else Phantom#748

    3. If ((binop matches pattern `CONCAT`)), then

      1. (Expr_ok: p TC |- expression_l : typedExpressionIR_l)

      2. (Expr_ok: p TC |- expression_r : typedExpressionIR_r)

      3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $compat_concat))

      4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

        2. (Let (_expressionIR (( typeIR_l_reduced ctk_l_reduced ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' (( typeIR_r_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

        4. (Let typeIR?{typeIR <- typeIR?} be $result_concat(typeIR_l_reduced, typeIR_r_reduced))

        5. If ((typeIR?{typeIR <- typeIR?} matches pattern (_))), then

          1. (Let ?(typeIR_reduced) be typeIR?{typeIR <- typeIR?})

          2. (Let ctk_reduced be $join_ctk(ctk_l_reduced, ctk_r_reduced))

          3. (Let expressionNoteIR be (( typeIR_reduced ctk_reduced )))

          4. Result in (((BinE typedExpressionIR_l_reduced (CONCAT) typedExpressionIR_r_reduced) as expressionIR) expressionNoteIR)

        5. Else Phantom#749

      4. Else Phantom#750

    3. Else Phantom#751

  6. Case (% has type ternaryExpression)

    1. (Let (TernE expression_cond expression_true expression_false) be (expression''' as ternaryExpression))

    2. (Expr_ok: p TC |- expression_cond : typedExpressionIR_cond)

    3. (Let (_expressionIR (( typeIR ctk_cond ))) be typedExpressionIR_cond)

    4. If ((typeIR has type primitiveTypeIR)), then

      1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

      2. If ((primitiveTypeIR matches pattern `BoolT`)), then

        1. (Expr_ok: p TC |- expression_true : typedExpressionIR_true)

        2. (Expr_ok: p TC |- expression_false : typedExpressionIR_false)

        3. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_true, typedExpressionIR_false))

        4. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_true_cast, typedExpressionIR_false_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

          2. (Let (_expressionIR' (( typeIR_cast ctk_true_cast ))) be typedExpressionIR_true_cast)

          3. (Let (_expressionIR'' (( _typeIR ctk_false_cast ))) be typedExpressionIR_false_cast)

          4. If (($is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= (DYN)))), then

            1. (Let ctk be $joins_ctk([ctk_cond, ctk_true_cast, ctk_false_cast]))

            2. (Let expressionNoteIR be (( typeIR_cast ctk )))

            3. Result in (((TernE typedExpressionIR_cond typedExpressionIR_true_cast typedExpressionIR_false_cast) as expressionIR) expressionNoteIR)

          4. Else Phantom#752

        4. Else Phantom#753

      2. Else Phantom#754

    4. Else Phantom#755

  7. Case (% has type castExpression)

    1. (Let (CastE type_t expression) be (expression''' as castExpression))

    2. (Type_ok: p TC |- (type_t as typeOrVoid) : typeIR_t tid*{tid <- tid*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((Type_wf: $bound(p, TC) |- typeIR_t holds)), then

        1. (Expr_ok: p TC |- expression : typedExpressionIR)

        2. (Let (_expressionIR (( typeIR ctk ))) be typedExpressionIR)

        3. If ((Sub_expl: typeIR <: typeIR_t holds)), then

          1. (Let expressionNoteIR be (( typeIR_t ctk )))

          2. Result in (((CastE typeIR_t typedExpressionIR) as expressionIR) expressionNoteIR)

        3. Else Phantom#756

      1. Else Phantom#757

    3. Else Phantom#758

  8. Case (% has type dataExpression)

    1. (Let dataExpression be (expression''' as dataExpression))

    2. Case analysis on dataExpression

      1. Case (% matches pattern `InvalidE`)

        1. (Let expressionNoteIR be (( ((InvalidHeaderT) as typeIR) (LCTK) )))

        2. Result in (((InvalidE) as expressionIR) expressionNoteIR)

      2. Case (% matches pattern `SeqE%`)

        1. (Let (SeqE expression_e*{expression_e <- expression_e*}) be dataExpression)

        2. Case analysis on ((DefaultE) as expression) is in expression_e*{expression_e <- expression_e*}

          1. Case false

            1. (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*{expression_e <- expression_e*, typedExpressionIR_e <- typedExpressionIR_e*}

            2. (Let (_expressionIR (( typeIR_e ctk_e ))) be typedExpressionIR_e)*{_expressionIR <- _expressionIR*, ctk_e <- ctk_e*, typeIR_e <- typeIR_e*, typedExpressionIR_e <- typedExpressionIR_e*}

            3. (Let typeIR be ((SeqT typeIR_e*{typeIR_e <- typeIR_e*}) as typeIR))

            4. (Let ctk be $joins_ctk(ctk_e*{ctk_e <- ctk_e*}))

            5. (Let expressionNoteIR be (( typeIR ctk )))

            6. Result in (((SeqE typedExpressionIR_e*{typedExpressionIR_e <- typedExpressionIR_e*}) as expressionIR) expressionNoteIR)

          2. Case true

            1. (Let expression''*{expression'' <- expression''*} be $rev_<expression>(expression_e*{expression_e <- expression_e*}))

            2. If ((expression''*{expression'' <- expression''*} matches pattern _ :: _)), then

              1. (Let expression' :: expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*} be expression''*{expression'' <- expression''*})

              2. If ((expression' has type defaultExpression)), then

                1. (Let defaultExpression be (expression' as defaultExpression))

                2. (Let expression_e_h*{expression_e_h <- expression_e_h*} be $rev_<expression>(expression_e_h_rev*{expression_e_h_rev <- expression_e_h_rev*}))

                3. If (~((DefaultE) as expression) is in expression_e_h*{expression_e_h <- expression_e_h*}), then

                  1. (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*{expression_e_h <- expression_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}

                  2. (Let (_expressionIR (( typeIR_e_h ctk_e_h ))) be typedExpressionIR_e_h)*{_expressionIR <- _expressionIR*, ctk_e_h <- ctk_e_h*, typeIR_e_h <- typeIR_e_h*, typedExpressionIR_e_h <- typedExpressionIR_e_h*}

                  3. (Let typeIR be ((SeqDefaultT typeIR_e_h*{typeIR_e_h <- typeIR_e_h*}) as typeIR))

                  4. (Let ctk be $joins_ctk(ctk_e_h*{ctk_e_h <- ctk_e_h*}))

                  5. (Let expressionNoteIR be (( typeIR ctk )))

                  6. Result in (((SeqDefaultE typedExpressionIR_e_h*{typedExpressionIR_e_h <- typedExpressionIR_e_h*}) as expressionIR) expressionNoteIR)

                3. Else Phantom#759

              2. Else Phantom#760

            2. Else Phantom#761

      3. Case (% matches pattern `RecordE%`)

        1. (Let (RecordE (name_f expression_f)*{expression_f <- expression_f*, name_f <- name_f*}) be dataExpression)

        2. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}

        3. (Let (_expressionIR (( typeIR_f ctk_f ))) be typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}

        4. (Let typeIR be ((RecordT (typeIR_f name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) as typeIR))

        5. (Let ctk be $joins_ctk(ctk_f*{ctk_f <- ctk_f*}))

        6. (Let expressionNoteIR be (( typeIR ctk )))

        7. Result in (((RecordE (name_f typedExpressionIR_f)*{name_f <- name_f*, typedExpressionIR_f <- typedExpressionIR_f*}) as expressionIR) expressionNoteIR)

      4. Case (% matches pattern `RecordDefaultE%`)

        1. (Let (RecordDefaultE (name_f expression_f)*{expression_f <- expression_f*, name_f <- name_f*}) be dataExpression)

        2. (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*{expression_f <- expression_f*, typedExpressionIR_f <- typedExpressionIR_f*}

        3. (Let (_expressionIR (( typeIR_f ctk_f ))) be typedExpressionIR_f)*{_expressionIR <- _expressionIR*, ctk_f <- ctk_f*, typeIR_f <- typeIR_f*, typedExpressionIR_f <- typedExpressionIR_f*}

        4. (Let typeIR be ((RecordDefaultT (typeIR_f name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) as typeIR))

        5. (Let ctk be $joins_ctk(ctk_f*{ctk_f <- ctk_f*}))

        6. (Let expressionNoteIR be (( typeIR ctk )))

        7. Result in (((RecordDefaultE (name_f typedExpressionIR_f)*{name_f <- name_f*, typedExpressionIR_f <- typedExpressionIR_f*}) as expressionIR) expressionNoteIR)

  9. Case (% has type errorAccessExpression)

    1. (Let (ErrAccE name) be (expression''' as errorAccessExpression))

    2. (Let name_error be "error." ++ name)

    3. If ((?(((ErrV name) as value)) = $find_value(p, TC, (CURRENT name_error)))), then

      1. (Let expressionNoteIR be (( ((ErrT) as typeIR) (LCTK) )))

      2. Result in (((ErrAccE name) as expressionIR) expressionNoteIR)

    3. Else Phantom#762

  10. Case (% has type memberAccessExpression)

    1. (Let memberAccessExpression be (expression''' as memberAccessExpression))

    2. Case analysis on memberAccessExpression

      1. Case (% matches pattern `TypeAccE%%`)

        1. (Let (TypeAccE prefixedName_base name) be memberAccessExpression)

        2. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type(p, TC, prefixedName_base))

        3. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

          1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

          2. If ((typeDefIR has type monoTypeDefIR)), then

            1. (Let (MonoTD typeIR_base) be (typeDefIR as monoTypeDefIR))

            2. (Let typeIR be $canon(typeIR_base))

            3. If ((typeIR has type enumTypeIR)), then

              1. (Let enumTypeIR be (typeIR as enumTypeIR))

              2. Case analysis on enumTypeIR

                1. Case (% matches pattern `EnumT%%`)

                  1. (Let (EnumT _tid id_f*{id_f <- id_f*}) be enumTypeIR)

                  2. If (name is in id_f*{id_f <- id_f*}), then

                    1. (Let expressionNoteIR be (( typeIR_base (LCTK) )))

                    2. Result in (((TypeAccE prefixedName_base name) as expressionIR) expressionNoteIR)

                  2. Else Phantom#763

                2. Case (% matches pattern `SEnumT%%%`)

                  1. (Let (SEnumT _tid _typeIR (id_f _value)*{_value <- _value*, id_f <- id_f*}) be enumTypeIR)

                  2. If (name is in id_f*{id_f <- id_f*}), then

                    1. (Let expressionNoteIR be (( typeIR_base (LCTK) )))

                    2. Result in (((TypeAccE prefixedName_base name) as expressionIR) expressionNoteIR)

                  2. Else Phantom#764

            3. Else Phantom#765

          2. Else Phantom#766

        3. Else Phantom#767

      2. Case (% matches pattern `ExprAccE%%`)

        1. (Let (ExprAccE expression_base text) be memberAccessExpression)

        2. Case analysis on text

          1. Case (% = "size")

            1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

            2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

            3. (Let typeIR' be $canon(typeIR_base))

            4. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

              2. (Let expressionNoteIR be (( ((FBitT 32) as typeIR) (LCTK) )))

              3. Result in (((ExprAccE typedExpressionIR_base "size") as expressionIR) expressionNoteIR)

            4. Else Phantom#768

          2. Case (% = "lastIndex")

            1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( ((FBitT 32) as typeIR) (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "lastIndex") as expressionIR) expressionNoteIR)

              4. Else Phantom#769

            1. Else Phantom#770

            2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( ((FBitT 32) as typeIR) (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "lastIndex") as expressionIR) expressionNoteIR)

              4. Else Phantom#771

            2. Else Phantom#772

          3. Case (% = "last")

            1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( typeIR (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "last") as expressionIR) expressionNoteIR)

              4. Else Phantom#773

            1. Else Phantom#774

            2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( typeIR (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "last") as expressionIR) expressionNoteIR)

              4. Else Phantom#775

            2. Else Phantom#776

          4. Case (% = "next")

            1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( typeIR (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "next") as expressionIR) expressionNoteIR)

              4. Else Phantom#777

            1. Else Phantom#778

            2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

              1. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

              2. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              3. (Let typeIR' be $canon(typeIR_base))

              4. If ((typeIR' has type headerStackTypeIR)), then

                1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

                2. (Let expressionNoteIR be (( typeIR (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base "next") as expressionIR) expressionNoteIR)

              4. Else Phantom#779

            2. Else Phantom#780

        2. Else Phantom#781

        3. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        4. (Let (_expressionIR (( typeIR_base ctk_base ))) be typedExpressionIR_base)

        5. (Let typeIR' be $canon(typeIR_base))

        6. Case analysis on typeIR'

          1. Case (% has type structTypeIR)

            1. (Let (StructT _tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR' as structTypeIR))

            2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(text, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}))

            3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

              2. (Let expressionNoteIR be (( typeIR ctk_base )))

              3. Result in (((ExprAccE typedExpressionIR_base text) as expressionIR) expressionNoteIR)

            3. Else Phantom#782

          2. Case (% has type headerTypeIR)

            1. (Let (HeaderT _tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR' as headerTypeIR))

            2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(text, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}))

            3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

              2. (Let expressionNoteIR be (( typeIR ctk_base )))

              3. Result in (((ExprAccE typedExpressionIR_base text) as expressionIR) expressionNoteIR)

            3. Else Phantom#783

          3. Case (% has type headerUnionTypeIR)

            1. (Let (HeaderUnionT _tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be (typeIR' as headerUnionTypeIR))

            2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(text, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}))

            3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

              1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

              2. (Let expressionNoteIR be (( typeIR ctk_base )))

              3. Result in (((ExprAccE typedExpressionIR_base text) as expressionIR) expressionNoteIR)

            3. Else Phantom#784

          4. Case (% has type tableTypeIR)

            1. (Let tableTypeIR be (typeIR' as tableTypeIR))

            2. If ((tableTypeIR matches pattern `TableStructT%%`)), then

              1. (Let (TableStructT _tid (typeIR_f id_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}) be tableTypeIR)

              2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(text, (id_f, typeIR_f)*{id_f <- id_f*, typeIR_f <- typeIR_f*}))

              3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

                1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

                2. (Let expressionNoteIR be (( typeIR (DYN) )))

                3. Result in (((ExprAccE typedExpressionIR_base text) as expressionIR) expressionNoteIR)

              3. Else Phantom#785

            2. Else Phantom#786

        6. Else Phantom#787

  11. Case (% has type indexAccessExpression)

    1. (Let indexAccessExpression be (expression''' as indexAccessExpression))

    2. Case analysis on indexAccessExpression

      1. Case (% matches pattern `ArrAccE%%`)

        1. (Let (ArrAccE expression_base expression_index) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

        4. (Let (_expressionIR (( typeIR_base ctk_base ))) be typedExpressionIR_base)

        5. (Let (_expressionIR' (( typeIR_index ctk_index ))) be typedExpressionIR_index)

        6. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

        7. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

          2. (Let typeIR be $canon(typeIR_base))

          3. Case analysis on typeIR

            1. Case (% has type tupleTypeIR)

              1. (Let (TupleT typeIR_e*{typeIR_e <- typeIR_e*}) be (typeIR as tupleTypeIR))

              2. If ((ctk_index matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                2. (Let int'?{int' <- int'?} be $to_number(value_index))

                3. If ((int'?{int' <- int'?} matches pattern (_))), then

                  1. (Let ?(int) be int'?{int' <- int'?})

                  2. If ((int has type nat)), then

                    1. (Let n_index be (int as nat))

                    2. If ((n_index < |typeIR_e*{typeIR_e <- typeIR_e*}|)), then

                      1. (Let expressionNoteIR be (( typeIR_e*{typeIR_e <- typeIR_e*}[n_index] ctk_base )))

                      2. Result in (((ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced) as expressionIR) expressionNoteIR)

                    2. Else Phantom#788

                  2. Else Phantom#789

                3. Else Phantom#790

              2. Else Phantom#791

            2. Case (% has type headerStackTypeIR)

              1. (Let (HeaderStackT typeIR n_size) be (typeIR as headerStackTypeIR))

              2. Case analysis on (ctk_index matches pattern `LCTK`)

                1. Case true

                  1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

                  2. (Let int'?{int' <- int'?} be $to_number(value_index))

                  3. If ((int'?{int' <- int'?} matches pattern (_))), then

                    1. (Let ?(int) be int'?{int' <- int'?})

                    2. If ((int has type nat)), then

                      1. (Let n_index be (int as nat))

                      2. If ((n_index < n_size)), then

                        1. (Let expressionNoteIR be (( typeIR ctk_base )))

                        2. Result in (((ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced) as expressionIR) expressionNoteIR)

                      2. Else Phantom#792

                    2. Else Phantom#793

                  3. Else Phantom#794

                2. Case false

                  1. (Let ctk be $join_ctk(ctk_base, ctk_index))

                  2. (Let expressionNoteIR be (( typeIR ctk )))

                  3. Result in (((ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced) as expressionIR) expressionNoteIR)

          3. Else Phantom#795

        7. Else Phantom#796

      2. Case (% matches pattern `BitAccE%%%`)

        1. (Let (BitAccE expression_base expression_hi expression_lo) be indexAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

        4. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

        5. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $reduce_serenum_unary(typedExpressionIR_base, $compat_bitslice_base))

        6. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_base_reduced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

          2. (Let (_expressionIR (( typeIR_base_reduced ctk_base_reduced ))) be typedExpressionIR_base_reduced)

          3. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

          4. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

            1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

            2. (Let typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

            3. If ((typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?} matches pattern (_))), then

              1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR''?{typedExpressionIR'' <- typedExpressionIR''?})

              2. (Let (_expressionIR' (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

              3. (Let (_expressionIR'' (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

              4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

                1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

                2. (Let int'?{int' <- int'?} be $to_number(value_hi))

                3. If ((int'?{int' <- int'?} matches pattern (_))), then

                  1. (Let ?(int) be int'?{int' <- int'?})

                  2. If ((int has type nat)), then

                    1. (Let n_hi be (int as nat))

                    2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                      1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                      2. (Let int'''?{int''' <- int'''?} be $to_number(value_lo))

                      3. If ((int'''?{int''' <- int'''?} matches pattern (_))), then

                        1. (Let ?(int'') be int'''?{int''' <- int'''?})

                        2. If ((int'' has type nat)), then

                          1. (Let n_lo be (int'' as nat))

                          2. If ($is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)), then

                            1. (Let int'''' be ((n_hi - n_lo) + (1 as int)))

                            2. If ((int'''' has type nat)), then

                              1. (Let n' be (int'''' as nat))

                              2. (Let typeIR be ((FBitT n') as typeIR))

                              3. (Let expressionNoteIR be (( typeIR ctk_base_reduced )))

                              4. Result in (((BitAccE typedExpressionIR_base typedExpressionIR_hi_reduced typedExpressionIR_lo_reduced) as expressionIR) expressionNoteIR)

                            2. Else Phantom#797

                          2. Else Phantom#798

                        2. Else Phantom#799

                      3. Else Phantom#800

                    2. Else Phantom#801

                  2. Else Phantom#802

                3. Else Phantom#803

              4. Else Phantom#804

            3. Else Phantom#805

          4. Else Phantom#806

        6. Else Phantom#807

  12. Case (% has type callExpression)

    1. (Let callExpression be (expression''' as callExpression))

    2. Case analysis on callExpression

      1. Case (% matches pattern `CallE%%%`)

        1. (Let (CallE routineTarget typeArgument*{typeArgument <- typeArgument*} argument*{argument <- argument*}) be callExpression)

        2. (RoutineTarget_ok: p TC |- routineTarget : routineTargetIR)

        3. (TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_impl*{tid_impl <- tid_impl*})

        4. (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

        5. (RoutineType_ok: p TC |- routineTargetIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} : routineTypeIR tid_inserted*{tid_inserted <- tid_inserted*} id_default*{id_default <- id_default*})

        6. (Let tid_infer*{tid_infer <- tid_infer*} be tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*})

        7. (Call_ok: p TC |- routineTypeIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_infer*{tid_infer <- tid_infer*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_ret typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

        8. If ((typeIR_ret =/= ((VoidT) as typeIR))), then

          1. (Let ctk be $is_static_routineTarget(routineTargetIR))

          2. (Let callExpressionIR be (CallE routineTargetIR typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

          3. (Let expressionNoteIR be (( typeIR_ret ctk )))

          4. Result in ((callExpressionIR as expressionIR) expressionNoteIR)

        8. Else Phantom#808

      2. Case (% matches pattern `InstE%%`)

        1. (Let (InstE namedType argument*{argument <- argument*}) be callExpression)

        2. Case analysis on namedType

          1. Case (% has type nameType)

            1. (Let (NameT prefixedName) be (namedType as nameType))

            2. (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            3. (ConstructorType_ok: p TC |- prefixedName [] argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_impl*{tid_impl <- tid_impl*} id_default*{id_default <- id_default*})

            4. (Inst_ok: p TC (ANON) |- constructorTypeIR [] tid_impl*{tid_impl <- tid_impl*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            5. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be (InstE prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

              2. (Let expressionNoteIR be (( typeIR_object (CTK) )))

              3. Result in ((callExpressionIR as expressionIR) expressionNoteIR)

            5. Else Phantom#809

          2. Case (% has type specializedType)

            1. (Let (SpecT prefixedName typeArgument*{typeArgument <- typeArgument*}) be (namedType as specializedType))

            2. (TypeArguments_ok: p TC |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_impl*{tid_impl <- tid_impl*})

            3. (Argument_ok: p TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            4. (ConstructorType_ok: p TC |- prefixedName typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_inserted*{tid_inserted <- tid_inserted*} id_default*{id_default <- id_default*})

            5. (Let tid_infer*{tid_infer <- tid_infer*} be tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*})

            6. (Inst_ok: p TC (ANON) |- constructorTypeIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_infer*{tid_infer <- tid_infer*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            7. If ($is_concrete_extern_object(typeIR_object)), then

              1. (Let callExpressionIR be (InstE prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

              2. (Let expressionNoteIR be (( typeIR_object (CTK) )))

              3. Result in ((callExpressionIR as expressionIR) expressionNoteIR)

            7. Else Phantom#810

;; ../../../../spec-concrete/5.04-typing-relation.watsup:51.1-53.23
relation Argument_ok: p, TC, argument

1. Case analysis on argument

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA expression) be argument)

    2. (Expr_ok: p TC |- expression : typedExpressionIR)

    3. Result in (ExprA typedExpressionIR)

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA name expression) be argument)

    2. (Expr_ok: p TC |- expression : typedExpressionIR)

    3. Result in (NameA name typedExpressionIR)

  3. Case (% matches pattern `NameAnyA%`)

    1. (Let (NameAnyA name) be argument)

    2. Result in (NameAnyA name)

  4. Case (% matches pattern `AnyA`)

    1. Result in (AnyA)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:59.1-61.23
relation Lvalue_ok: p, TC, lvalue

1. Case analysis on lvalue

  1. Case (% matches pattern `NameL%`)

    1. (Let (NameL prefixedName) be lvalue)

    2. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_var(p, TC, prefixedName))

    3. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

      1. (Let ?((direction typeIR ctk value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

      2. If ((ctk matches pattern `DYN`)), then

        1. If ((value?{value <- value?} matches pattern ())), then

          1. Case analysis on direction

            1. Case (% matches pattern `OUT`)

              1. Result in ((NameL prefixedName) (( typeIR )))

            2. Case (% matches pattern `INOUT`)

              1. Result in ((NameL prefixedName) (( typeIR )))

          1. Else Phantom#811

        1. Else Phantom#812

      2. Else Phantom#813

    3. Else Phantom#814

  2. Case (% matches pattern `LvalueAccL%%`)

    1. (Let (LvalueAccL lvalue_base name) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR (( typeIR_base ))) be typedLvalueIR_base)

    4. (Let typeIR' be $canon(typeIR_base))

    5. Case analysis on typeIR'

      1. Case (% has type headerStackTypeIR)

        1. (Let (HeaderStackT typeIR _nat) be (typeIR' as headerStackTypeIR))

        2. Case analysis on name

          1. Case (% = "next")

            1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

              1. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

              2. Result in typedLvalueIR

            1. Else Phantom#815

            2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

              1. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

              2. Result in typedLvalueIR

            2. Else Phantom#816

          2. Case (% = "last")

            1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

              1. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

              2. Result in typedLvalueIR

            1. Else Phantom#817

            2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

              1. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

              2. Result in typedLvalueIR

            2. Else Phantom#818

        2. Else Phantom#819

      2. Case (% has type structTypeIR)

        1. (Let (StructT _tid (typeIR_f name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) be (typeIR' as structTypeIR))

        2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}))

        3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

          2. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

          3. Result in typedLvalueIR

        3. Else Phantom#820

      3. Case (% has type headerTypeIR)

        1. (Let (HeaderT _tid (typeIR_f name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) be (typeIR' as headerTypeIR))

        2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}))

        3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

          2. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

          3. Result in typedLvalueIR

        3. Else Phantom#821

      4. Case (% has type headerUnionTypeIR)

        1. (Let (HeaderUnionT _tid (typeIR_f name_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}) be (typeIR' as headerUnionTypeIR))

        2. (Let typeIR''?{typeIR'' <- typeIR''?} be $assoc_<name, typeIR>(name, (name_f, typeIR_f)*{name_f <- name_f*, typeIR_f <- typeIR_f*}))

        3. If ((typeIR''?{typeIR'' <- typeIR''?} matches pattern (_))), then

          1. (Let ?(typeIR) be typeIR''?{typeIR'' <- typeIR''?})

          2. (Let typedLvalueIR be ((LvalueAccL typedLvalueIR_base name) (( typeIR ))))

          3. Result in typedLvalueIR

        3. Else Phantom#822

    5. Else Phantom#823

  3. Case (% matches pattern `ArrAccL%%`)

    1. (Let (ArrAccL lvalue_base expression_index) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR (( typeIR_base ))) be typedLvalueIR_base)

    4. (Let typeIR' be $canon(typeIR_base))

    5. If ((typeIR' has type headerStackTypeIR)), then

      1. (Let (HeaderStackT typeIR n_size) be (typeIR' as headerStackTypeIR))

      2. (Expr_ok: p TC |- expression_index : typedExpressionIR_index)

      3. (Let (_expressionIR (( typeIR_index ctk_index ))) be typedExpressionIR_index)

      4. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $reduce_serenum_unary(typedExpressionIR_index, $compat_array_index))

      5. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

        1. (Let ?(typedExpressionIR_index_reduced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

        2. Case analysis on (ctk_index matches pattern `LCTK`)

          1. Case true

            1. (Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index)

            2. (Let int'?{int' <- int'?} be $to_number(value_index))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_index be (int as nat))

                2. If ((n_index < n_size)), then

                  1. (Let typedLvalueIR be ((ArrAccL typedLvalueIR_base typedExpressionIR_index_reduced) (( typeIR ))))

                  2. Result in typedLvalueIR

                2. Else Phantom#824

              2. Else Phantom#825

            3. Else Phantom#826

          2. Case false

            1. (Let typedLvalueIR be ((ArrAccL typedLvalueIR_base typedExpressionIR_index_reduced) (( typeIR ))))

            2. Result in typedLvalueIR

      5. Else Phantom#827

    5. Else Phantom#828

  4. Case (% matches pattern `BitAccL%%%`)

    1. (Let (BitAccL lvalue_base expression_hi expression_lo) be lvalue)

    2. (Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base)

    3. (Let (_lvalueIR (( typeIR_base ))) be typedLvalueIR_base)

    4. If ($compat_bitslice_base(typeIR_base)), then

      1. (Expr_ok: p TC |- expression_hi : typedExpressionIR_hi)

      2. (Expr_ok: p TC |- expression_lo : typedExpressionIR_lo)

      3. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $reduce_serenum_unary(typedExpressionIR_hi, $compat_bitslice_index))

      4. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

        1. (Let ?(typedExpressionIR_hi_reduced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

        2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $reduce_serenum_unary(typedExpressionIR_lo, $compat_bitslice_index))

        3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_lo_reduced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

          2. (Let (_expressionIR (( typeIR_hi_reduced ctk_hi_reduced ))) be typedExpressionIR_hi_reduced)

          3. (Let (_expressionIR' (( typeIR_lo_reduced ctk_lo_reduced ))) be typedExpressionIR_lo_reduced)

          4. If ((ctk_hi_reduced matches pattern `LCTK`)), then

            1. (Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi)

            2. (Let int'?{int' <- int'?} be $to_number(value_hi))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_hi be (int as nat))

                2. If ((ctk_lo_reduced matches pattern `LCTK`)), then

                  1. (Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo)

                  2. (Let int'''?{int''' <- int'''?} be $to_number(value_lo))

                  3. If ((int'''?{int''' <- int'''?} matches pattern (_))), then

                    1. (Let ?(int'') be int'''?{int''' <- int'''?})

                    2. If ((int'' has type nat)), then

                      1. (Let n_lo be (int'' as nat))

                      2. If ($is_valid_bitslice(typeIR_base, n_lo, n_hi)), then

                        1. (Let int'''' be ((n_hi - n_lo) + (1 as int)))

                        2. If ((int'''' has type nat)), then

                          1. (Let n' be (int'''' as nat))

                          2. (Let typeIR be ((FBitT n') as typeIR))

                          3. (Let typedLvalueIR be ((BitAccL typedLvalueIR_base typedExpressionIR_hi_reduced typedExpressionIR_lo_reduced) (( typeIR ))))

                          4. Result in typedLvalueIR

                        2. Else Phantom#829

                      2. Else Phantom#830

                    2. Else Phantom#831

                  3. Else Phantom#832

                2. Else Phantom#833

              2. Else Phantom#834

            3. Else Phantom#835

          4. Else Phantom#836

        3. Else Phantom#837

      4. Else Phantom#838

    4. Else Phantom#839

;; ../../../../spec-concrete/5.04-typing-relation.watsup:67.1-69.26
relation Stmt_ok: p', TC', f', statement''

1. Case analysis on statement''

  1. Case (% has type emptyStatement)

    1. (Let emptyStatement be (statement'' as emptyStatement))

    2. Result in TC', f', ((EmptyS) as statementIR)

  2. Case (% has type assignmentStatement)

    1. (Let (AssignS lvalue expression) be (statement'' as assignmentStatement))

    2. (Lvalue_ok: p' TC' |- lvalue : typedLvalueIR)

    3. (Expr_ok: p' TC' |- expression : typedExpressionIR)

    4. (Let (_lvalueIR (( typeIR_l ))) be typedLvalueIR)

    5. (Let (_expressionIR (( typeIR_r _ctk ))) be typedExpressionIR)

    6. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $coerce_unary(typedExpressionIR, typeIR_l))

    7. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

      1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

      2. Result in TC', f', ((AssignS typedLvalueIR typedExpressionIR_cast) as statementIR)

    7. Else Phantom#840

  3. Case (% has type callStatement)

    1. (Let (CallS lvalue_routine typeArgument*{typeArgument <- typeArgument*} argument*{argument <- argument*}) be (statement'' as callStatement))

    2. (RoutineTarget_lvalue_ok: p' TC' |- lvalue_routine : routineTargetIR)

    3. (TypeArguments_ok: p' TC' |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_impl*{tid_impl <- tid_impl*})

    4. (Argument_ok: p' TC' |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

    5. (RoutineType_ok: p' TC' |- routineTargetIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} : routineTypeIR tid_inserted*{tid_inserted <- tid_inserted*} id_default*{id_default <- id_default*})

    6. (Let tid_infer*{tid_infer <- tid_infer*} be tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*})

    7. (Call_ok: p' TC' |- routineTypeIR [] tid_infer*{tid_infer <- tid_infer*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_ret typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

    8. (Let callStatementIR be (CallS routineTargetIR typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

    9. Result in TC', f', (callStatementIR as statementIR)

  4. Case (% has type directApplicationStatement)

    1. (Let (InstS namedType argument*{argument <- argument*}) be (statement'' as directApplicationStatement))

    2. (Expr_ok: p' TC' |- ((InstE namedType []) as expression) : (expressionIR (( typeIR_object _ctk ))))

    3. If ((expressionIR has type callExpressionIR)), then

      1. (Let callExpressionIR be (expressionIR as callExpressionIR))

      2. If ((callExpressionIR matches pattern `InstE%%%`)), then

        1. (Let (InstE prefixedName typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*}) be callExpressionIR)

        2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

          1. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern [])), then

            1. If ($compat_direct_application(typeIR_object)), then

              1. (Let name_object be "__direct_application")

              2. (Let TC_1 be $add_var(p', TC', name_object, ((NO) typeIR_object (CTK) ?())))

              3. (Let lvalue be (LvalueAccL (NameL (CURRENT name_object)) "apply"))

              4. (Stmt_ok: p' TC_1 f' |- ((CallS lvalue [] argument*{argument <- argument*}) as statement) : _typingContext _flow statementIR)

              5. If ((statementIR has type callStatementIR)), then

                1. (Let callStatementIR be (statementIR as callStatementIR))

                2. (Let (CallS routineTargetIR typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}) be callStatementIR)

                3. If ((routineTargetIR = (MethodT (((NameE (CURRENT name_object)) as expressionIR) (( typeIR_object (CTK) ))) "apply"))), then

                  1. If ((typeArgumentIR'*{typeArgumentIR' <- typeArgumentIR'*} matches pattern [])), then

                    1. (Let directApplicationStatementIR be (InstS prefixedName argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

                    2. Result in TC', f', (directApplicationStatementIR as statementIR)

                  1. Else Phantom#841

                3. Else Phantom#842

              5. Else Phantom#843

            1. Else Phantom#844

          1. Else Phantom#845

        2. Else Phantom#846

      2. Else Phantom#847

    3. Else Phantom#848

  5. Case (% has type exitStatement)

    1. (Let exitStatement be (statement'' as exitStatement))

    2. Result in TC', f', ((ExitS) as statementIR)

  6. Case (% has type conditionalStatement)

    1. (Let (IfS expression_cond statement_then statement?{statement <- statement?}) be (statement'' as conditionalStatement))

    2. Case analysis on statement?{statement <- statement?}

      1. Case (% matches pattern ())

        1. (Expr_ok: p' TC' |- expression_cond : typedExpressionIR_cond)

        2. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR_cond)

        3. If ((typeIR has type primitiveTypeIR)), then

          1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

          2. If ((primitiveTypeIR matches pattern `BoolT`)), then

            1. (Stmt_ok: p' TC' f' |- statement_then : TC_then f_then statementIR_then)

            2. Result in TC', f', ((IfS typedExpressionIR_cond statementIR_then ?()) as statementIR)

          2. Else Phantom#849

        3. Else Phantom#850

      2. Case (% matches pattern (_))

        1. (Let ?(statement_else) be statement?{statement <- statement?})

        2. (Expr_ok: p' TC' |- expression_cond : typedExpressionIR_cond)

        3. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR_cond)

        4. If ((typeIR has type primitiveTypeIR)), then

          1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

          2. If ((primitiveTypeIR matches pattern `BoolT`)), then

            1. (Stmt_ok: p' TC' f' |- statement_then : TC_then f_then statementIR_then)

            2. (Stmt_ok: p' TC' f' |- statement_else : TC_else f_else statementIR_else)

            3. (Let f_post be $join_flow(f_then, f_else))

            4. Result in TC', f_post, ((IfS typedExpressionIR_cond statementIR_then ?(statementIR_else)) as statementIR)

          2. Else Phantom#851

        4. Else Phantom#852

1. Else Phantom#853

2. If ((p' matches pattern `LOCAL`)), then

  1. If ((statement'' = ((ReturnS ?()) as statement))), then

    1. If ((?(((VoidT) as typeIR)) = $find_return_type(TC'))), then

      1. Result in TC', (RET), ((ReturnS ?()) as statementIR)

    1. Else Phantom#854

  1. Else Phantom#855

  2. Case analysis on statement''

    1. Case (% has type returnStatement)

      1. (Let (ReturnS expression'?{expression' <- expression'?}) be (statement'' as returnStatement))

      2. If ((expression'?{expression' <- expression'?} matches pattern (_))), then

        1. (Let ?(expression) be expression'?{expression' <- expression'?})

        2. (Expr_ok: (LOCAL) TC' |- expression : typedExpressionIR)

        3. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR)

        4. (Let typeIR'?{typeIR' <- typeIR'?} be $find_return_type(TC'))

        5. If ((typeIR'?{typeIR' <- typeIR'?} matches pattern (_))), then

          1. (Let ?(typeIR_ret) be typeIR'?{typeIR' <- typeIR'?})

          2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $coerce_unary(typedExpressionIR, typeIR_ret))

          3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

            1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

            2. Result in TC', (RET), ((ReturnS ?(typedExpressionIR_cast)) as statementIR)

          3. Else Phantom#856

        5. Else Phantom#857

      2. Else Phantom#858

    2. Case (% has type blockStatement)

      1. (Let blockStatement be (statement'' as blockStatement))

      2. (Block_ok: TC' f' |- blockStatement : TC_1 f_1 blockStatementIR)

      3. Result in TC_1, f_1, (blockStatementIR as statementIR)

    3. Case (% has type switchStatement)

      1. (Let (SwitchS expression_switch switchCase*{switchCase <- switchCase*}) be (statement'' as switchStatement))

      2. (Expr_ok: (LOCAL) TC' |- expression_switch : typedExpressionIR_switch)

      3. (Let (_expressionIR (( typeIR_switch _ctk ))) be typedExpressionIR_switch)

      4. (Let typeIR be $canon(typeIR_switch))

      5. If ((typeIR has type tableTypeIR)), then

        1. (Let tableTypeIR be (typeIR as tableTypeIR))

        2. If ((tableTypeIR matches pattern `TableEnumT%%`)), then

          1. (Let (TableEnumT tid_table_enum _id*{_id <- _id*}) be tableTypeIR)

          2. (Let tid_table be $strip_prefix($strip_suffix(tid_table_enum, ")"), "action_list("))

          3. (SwitchCases_table_ok: TC' f' tid_table |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} switchLabel*{switchLabel <- switchLabel*})

          4. If ($distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})), then

            1. (Let switchStatementIR be (SwitchS typedExpressionIR_switch switchCaseIR*{switchCaseIR <- switchCaseIR*}))

            2. Result in TC', f_post, (switchStatementIR as statementIR)

          4. Else Phantom#859

        2. Else Phantom#860

      5. Else Phantom#861

      6. If ($compat_switch(typeIR_switch)), then

        1. (SwitchCases_general_ok: TC' f' typeIR_switch |- switchCase*{switchCase <- switchCase*} : f_post switchCaseIR*{switchCaseIR <- switchCaseIR*} switchLabel*{switchLabel <- switchLabel*})

        2. If ($distinct_<switchLabel>(switchLabel*{switchLabel <- switchLabel*})), then

          1. (Let switchStatementIR be (SwitchS typedExpressionIR_switch switchCaseIR*{switchCaseIR <- switchCaseIR*}))

          2. Result in TC', f_post, (switchStatementIR as statementIR)

        2. Else Phantom#862

      6. Else Phantom#863

  2. Else Phantom#864

2. Else Phantom#865

;; ../../../../spec-concrete/5.04-typing-relation.watsup:71.1-73.26
relation Stmts_ok: 



;; ../../../../spec-concrete/5.04-typing-relation.watsup:75.1-78.23
relation BlockElementStmt_ok: TC_0, f, blockElementStatement

1. Case analysis on blockElementStatement

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (blockElementStatement as constantDeclaration))

    2. (Decl_ok: (LOCAL) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, f, (constantDeclarationIR as blockElementStatementIR)

    3. Else Phantom#866

  2. Case (% has type variableDeclaration)

    1. (Let (VarD type name initializer?{initializer <- initializer?}) be (blockElementStatement as variableDeclaration))

    2. Case analysis on initializer?{initializer <- initializer?}

      1. Case (% matches pattern ())

        1. (Type_ok: (LOCAL) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        2. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((LOCAL), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let TC_1 be $add_var((LOCAL), TC_0, name, ((INOUT) typeIR (DYN) ?())))

              2. (Let variableDeclarationIR be (VarD typeIR name ?()))

              3. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

            1. Else Phantom#867

          1. Else Phantom#868

        2. Else Phantom#869

      2. Case (% matches pattern (_))

        1. (Let ?(expression_init) be initializer?{initializer <- initializer?})

        2. (Type_ok: (LOCAL) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((LOCAL), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (LOCAL) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

                2. (Let TC_1 be $add_var((LOCAL), TC_0, name, ((INOUT) typeIR (DYN) ?())))

                3. (Let variableDeclarationIR be (VarD typeIR name ?(typedExpressionIR_init_cast)))

                4. Result in TC_1, f, (variableDeclarationIR as blockElementStatementIR)

              3. Else Phantom#870

            1. Else Phantom#871

          1. Else Phantom#872

        3. Else Phantom#873

  3. Case (% has type statement)

    1. (Let statement be (blockElementStatement as statement))

    2. (Stmt_ok: (LOCAL) TC_0 f |- statement : TC_1 f_post statementIR)

    3. Result in TC_1, f_post, (statementIR as blockElementStatementIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:80.1-83.23
relation BlockElementStmts_ok: TC', f', blockElementStatement*{blockElementStatement <- blockElementStatement*}

1. Case analysis on blockElementStatement*{blockElementStatement <- blockElementStatement*}

  1. Case (% matches pattern [])

    1. Result in TC', f', []

  2. Case (% matches pattern _ :: _)

    1. (Let blockElementStatement_h :: blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} be blockElementStatement*{blockElementStatement <- blockElementStatement*})

    2. (BlockElementStmt_ok: TC' f' |- blockElementStatement_h : TC_1 f_1 blockElementStatementIR_h)

    3. (BlockElementStmts_ok: TC_1 f_1 |- blockElementStatement_t*{blockElementStatement_t <- blockElementStatement_t*} : TC_2 f_2 blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*})

    4. Result in TC_2, f_2, blockElementStatementIR_h :: blockElementStatementIR_t*{blockElementStatementIR_t <- blockElementStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:85.1-88.23
relation Block_ok: TC_0, f, (BlockS blockElementStatement*{blockElementStatement <- blockElementStatement*})

1. (Let TC_1 be $enter(TC_0))

2. (BlockElementStmts_ok: TC_1 f |- blockElementStatement*{blockElementStatement <- blockElementStatement*} : TC_2 f_post blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*})

3. (Let TC_3 be $exit(TC_2))

4. (Let blockStatementIR be (BlockS blockElementStatementIR*{blockElementStatementIR <- blockElementStatementIR*}))

5. Result in TC_3, f_post, blockStatementIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:95.1-97.23
relation Parameter_ok: p, TC, (direction type name initializer?{initializer <- initializer?})

1. Case analysis on initializer?{initializer <- initializer?}

  1. Case (% matches pattern ())

    1. (Type_ok: p TC |- (type as typeOrVoid) : typeIR tid_fresh*{tid_fresh <- tid_fresh*})

    2. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

    3. If ((Type_wf: bound |- typeIR holds)), then

      1. Result in (direction typeIR name ?()), tid_fresh*{tid_fresh <- tid_fresh*}

    3. Else Phantom#874

  2. Case (% matches pattern (_))

    1. (Let ?(expression_init) be initializer?{initializer <- initializer?})

    2. (Type_ok: p TC |- (type as typeOrVoid) : typeIR tid_fresh*{tid_fresh <- tid_fresh*})

    3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_fresh*{tid_fresh <- tid_fresh*} })))

    4. If ((Type_wf: bound |- typeIR holds)), then

      1. (Expr_ok: p TC |- expression_init : typedExpressionIR_init)

      2. (Let (_expressionIR (( typeIR_init ctk ))) be typedExpressionIR_init)

      3. If ((ctk matches pattern `LCTK`)), then

        1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_init, typeIR))

        2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

          2. (Eval_static: p TC |- typedExpressionIR_init_cast ~> value_init)

          3. Result in (direction typeIR name ?(value_init)), tid_fresh*{tid_fresh <- tid_fresh*}

        2. Else Phantom#875

      3. Else Phantom#876

    4. Else Phantom#877

;; ../../../../spec-concrete/5.04-typing-relation.watsup:99.1-101.23
relation Parameters_ok: p, TC, parameter*{parameter <- parameter*}

1. Case analysis on parameter*{parameter <- parameter*}

  1. Case (% matches pattern [])

    1. Result in [], []

  2. Case (% matches pattern _ :: _)

    1. (Let parameter_h :: parameter_t*{parameter_t <- parameter_t*} be parameter*{parameter <- parameter*})

    2. (Parameter_ok: p TC |- parameter_h : parameterIR_h tid_fresh_h*{tid_fresh_h <- tid_fresh_h*})

    3. (Parameters_ok: p TC |- parameter_t*{parameter_t <- parameter_t*} : parameterIR_t*{parameterIR_t <- parameterIR_t*} tid_fresh_t*{tid_fresh_t <- tid_fresh_t*})

    4. Result in parameterIR_h :: parameterIR_t*{parameterIR_t <- parameterIR_t*}, tid_fresh_h*{tid_fresh_h <- tid_fresh_h*} ++ tid_fresh_t*{tid_fresh_t <- tid_fresh_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:103.1-103.48
def $parameterIR((direction typeIR name constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}))

1. Case analysis on constantInitializerIR?{constantInitializerIR <- constantInitializerIR?}

  1. Case (% matches pattern ())

    1. Return (direction typeIR name ?())

  2. Case (% matches pattern (_))

    1. (Let ?(value) be constantInitializerIR?{constantInitializerIR <- constantInitializerIR?})

    2. Return (direction typeIR name ?(value))

;; ../../../../spec-concrete/5.04-typing-relation.watsup:109.1-112.23
relation ConstructorParameter_ok: p, TC, constructorParameter

1. (Parameter_ok: p TC |- constructorParameter : constructorParameterIR tid_fresh*{tid_fresh <- tid_fresh*})

2. Result in constructorParameterIR, tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:114.1-117.23
relation ConstructorParameters_ok: p, TC, constructorParameter*{constructorParameter <- constructorParameter*}

1. (Parameters_ok: p TC |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} tid_fresh*{tid_fresh <- tid_fresh*})

2. Result in constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}, tid_fresh*{tid_fresh <- tid_fresh*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:119.1-119.81
def $constructorParameterIR(constructorParameterIR)

1. Return $parameterIR(constructorParameterIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:127.1-129.23
relation ExternMethod_ok: TC_0, tid_extern, methodPrototype

1. Case analysis on methodPrototype

  1. Case (% matches pattern `MethodM%%%%`)

    1. (Let (MethodM typeOrVoid name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*}) be methodPrototype)

    2. If ((name =/= tid_extern)), then

      1. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      2. (Let TC_1 be $add_types((LOCAL), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      3. (Type_ok: (LOCAL) TC_1 |- typeOrVoid : typeIR_ret tid*{tid <- tid*})

      4. If ((tid*{tid <- tid*} matches pattern [])), then

        1. (Let TC_2 be TC_1[LOCAL.KIND = (EXTERNMETHOD typeIR_ret)])

        2. (Parameters_ok: (LOCAL) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

        3. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

        4. (Let TC_3 be $add_parameters((LOCAL), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

        5. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        6. (Let routineTypeIR be (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        7. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        8. If ((RoutineTypeDef_wf: $bound((BLOCK), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((BLOCK), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (MethodM typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*}))

          3. Result in TC_4, methodPrototypeIR

        8. Else Phantom#878

      4. Else Phantom#879

    2. Else Phantom#880

  2. Case (% matches pattern `AbstractMethodM%%%%`)

    1. (Let (AbstractMethodM typeOrVoid name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*}) be methodPrototype)

    2. If ((name =/= tid_extern)), then

      1. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      2. (Let TC_1 be $add_types((LOCAL), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      3. (Type_ok: (LOCAL) TC_1 |- typeOrVoid : typeIR_ret tid*{tid <- tid*})

      4. If ((tid*{tid <- tid*} matches pattern [])), then

        1. (Let TC_2 be TC_1[LOCAL.KIND = (EXTERNABSTRACTMETHOD typeIR_ret)])

        2. (Parameters_ok: (LOCAL) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

        3. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

        4. (Let TC_3 be $add_parameters((LOCAL), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

        5. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        6. (Let routineTypeIR be (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        7. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        8. If ((RoutineTypeDef_wf: $bound((BLOCK), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_non_overload((BLOCK), TC_0, rid, routineTypeDefIR))

          2. (Let methodPrototypeIR be (AbstractMethodM typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*}))

          3. Result in TC_4, methodPrototypeIR

        8. Else Phantom#881

      4. Else Phantom#882

    2. Else Phantom#883

1. Else Phantom#884

;; ../../../../spec-concrete/5.04-typing-relation.watsup:131.1-133.23
relation ExternMethods_ok: TC', tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}

1. Case analysis on methodPrototype*{methodPrototype <- methodPrototype*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} be methodPrototype*{methodPrototype <- methodPrototype*})

    2. (ExternMethod_ok: TC' tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    3. (ExternMethods_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

    4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:135.1-137.23
relation ExternConstructor_ok: TC_0, tid_extern, methodPrototype

1. If ((methodPrototype matches pattern `ConsM%%`)), then

  1. (Let (ConsM name constructorParameter*{constructorParameter <- constructorParameter*}) be methodPrototype)

  2. If ((name = tid_extern)), then

    1. (ConstructorParameters_ok: (BLOCK) TC_0 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} tid_impl*{tid_impl <- tid_impl*})

    2. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}

    3. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type((GLOBAL), TC_0, (CURRENT name)))

    4. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

      1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

      2. If ((typeDefIR has type polyTypeDefIR)), then

        1. (Let (PolyTD typeIR_extern tid_expl*{tid_expl <- tid_expl*} tid*{tid <- tid*}) be (typeDefIR as polyTypeDefIR))

        2. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Let cid be $cid(name, constructorParameter*{constructorParameter <- constructorParameter*}))

          2. (Let typeIR_extern_spec be ((SpecT (PolyTD typeIR_extern tid_expl*{tid_expl <- tid_expl*} []) ((NameT tid_expl) as typeIR)*{tid_expl <- tid_expl*}) as typeIR))

          3. (Let constructorTypeIR be (ConstructorT constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} typeIR_extern_spec))

          4. (Let constructorTypeDefIR be (PolyTD constructorTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}))

          5. If ((ConstructorTypeDef_wf: $bound((BLOCK), TC_0) |- constructorTypeDefIR holds)), then

            1. (Let TC_1 be $add_constructor(TC_0, cid, constructorTypeDefIR))

            2. (Let methodPrototypeIR be (ConsM name tid_impl*{tid_impl <- tid_impl*} constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}))

            3. Result in TC_1, methodPrototypeIR

          5. Else Phantom#885

        2. Else Phantom#886

      2. Else Phantom#887

    4. Else Phantom#888

  2. Else Phantom#889

1. Else Phantom#890

;; ../../../../spec-concrete/5.04-typing-relation.watsup:139.1-141.23
relation ExternConstructors_ok: TC', tid_extern, methodPrototype*{methodPrototype <- methodPrototype*}

1. Case analysis on methodPrototype*{methodPrototype <- methodPrototype*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} be methodPrototype*{methodPrototype <- methodPrototype*})

    2. (ExternConstructor_ok: TC' tid_extern |- methodPrototype_h : TC_1 methodPrototypeIR_h)

    3. (ExternConstructors_ok: TC_1 tid_extern |- methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} : TC_2 methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*})

    4. Result in TC_2, methodPrototypeIR_h :: methodPrototypeIR_t*{methodPrototypeIR_t <- methodPrototypeIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:147.1-149.23
relation ParserTransition_ok: TC_0, name_state*{name_state <- name_state*}, (TransS stateExpression)

1. Case analysis on stateExpression

  1. Case (% matches pattern `NameE%`)

    1. (Let (NameE name) be stateExpression)

    2. If (name is in name_state*{name_state <- name_state*}), then

      1. (Let transitionStatementIR be (TransS ?((NameE name))))

      2. Result in transitionStatementIR

    2. Else Phantom#891

  2. Case (% matches pattern `SelectE%%`)

    1. (Let (SelectE expression_key*{expression_key <- expression_key*} selectCase*{selectCase <- selectCase*}) be stateExpression)

    2. (Expr_ok: (LOCAL) TC_0 |- expression_key : typedExpressionIR_key)*{expression_key <- expression_key*, typedExpressionIR_key <- typedExpressionIR_key*}

    3. (Let (_expressionIR (( typeIR_key _ctk ))) be typedExpressionIR_key)*{_ctk <- _ctk*, _expressionIR <- _expressionIR*, typeIR_key <- typeIR_key*, typedExpressionIR_key <- typedExpressionIR_key*}

    4. If ((Type_wf: $bound((LOCAL), TC_0) |- ((SetT typeIR_key) as typeIR) holds))*{typeIR_key <- typeIR_key*}, then

      1. (SelectCase_ok: TC_0 name_state*{name_state <- name_state*} typeIR_key*{typeIR_key <- typeIR_key*} |- selectCase : selectCaseIR)*{selectCase <- selectCase*, selectCaseIR <- selectCaseIR*}

      2. (Let transitionStatementIR be (TransS ?((SelectE typedExpressionIR_key*{typedExpressionIR_key <- typedExpressionIR_key*} selectCaseIR*{selectCaseIR <- selectCaseIR*}))))

      3. Result in transitionStatementIR

    4. Else Phantom#892

;; ../../../../spec-concrete/5.04-typing-relation.watsup:151.1-153.20
relation ParserStmt_ok: TC_0', parserStatement''

1. Case analysis on parserStatement''

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (parserStatement'' as constantDeclaration))

    2. (Decl_ok: (LOCAL) TC_0' |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserStatementIR)

    3. Else Phantom#893

  2. Case (% has type variableDeclaration)

    1. (Let (VarD type name initializer?{initializer <- initializer?}) be (parserStatement'' as variableDeclaration))

    2. Case analysis on initializer?{initializer <- initializer?}

      1. Case (% matches pattern ())

        1. (Type_ok: (LOCAL) TC_0' |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        2. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((LOCAL), TC_0') |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let TC_1 be $add_var((LOCAL), TC_0', name, ((INOUT) typeIR (DYN) ?())))

              2. (Let variableDeclarationIR be (VarD typeIR name ?()))

              3. Result in TC_1, (variableDeclarationIR as parserStatementIR)

            1. Else Phantom#894

          1. Else Phantom#895

        2. Else Phantom#896

      2. Case (% matches pattern (_))

        1. (Let ?(expression_init) be initializer?{initializer <- initializer?})

        2. (Type_ok: (LOCAL) TC_0' |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((LOCAL), TC_0') |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (LOCAL) TC_0' |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

                2. (Let TC_1 be $add_var((LOCAL), TC_0', name, ((INOUT) typeIR (DYN) ?())))

                3. (Let variableDeclarationIR be (VarD typeIR name ?(typedExpressionIR_init_cast)))

                4. Result in TC_1, (variableDeclarationIR as parserStatementIR)

              3. Else Phantom#897

            1. Else Phantom#898

          1. Else Phantom#899

        3. Else Phantom#900

  3. Case (% has type emptyStatement)

    1. (Let emptyStatement be (parserStatement'' as emptyStatement))

    2. (Stmt_ok: (LOCAL) TC_0' (CONT) |- (emptyStatement as statement) : _typingContext _flow statementIR)

    3. If ((statementIR has type emptyStatementIR)), then

      1. (Let emptyStatementIR be (statementIR as emptyStatementIR))

      2. Result in TC_0', (emptyStatementIR as parserStatementIR)

    3. Else Phantom#901

  4. Case (% has type assignmentStatement)

    1. (Let assignmentStatement be (parserStatement'' as assignmentStatement))

    2. (Stmt_ok: (LOCAL) TC_0' (CONT) |- (assignmentStatement as statement) : TC_1 _flow statementIR)

    3. If ((statementIR has type assignmentStatementIR)), then

      1. (Let assignmentStatementIR be (statementIR as assignmentStatementIR))

      2. Result in TC_1, (assignmentStatementIR as parserStatementIR)

    3. Else Phantom#902

  5. Case (% has type callStatement)

    1. (Let callStatement be (parserStatement'' as callStatement))

    2. (Stmt_ok: (LOCAL) TC_0' (CONT) |- (callStatement as statement) : TC_1 _flow statementIR)

    3. If ((statementIR has type callStatementIR)), then

      1. (Let callStatementIR be (statementIR as callStatementIR))

      2. Result in TC_1, (callStatementIR as parserStatementIR)

    3. Else Phantom#903

  6. Case (% has type directApplicationStatement)

    1. (Let directApplicationStatement be (parserStatement'' as directApplicationStatement))

    2. (Stmt_ok: (LOCAL) TC_0' (CONT) |- (directApplicationStatement as statement) : TC_1 _flow statementIR)

    3. If ((statementIR has type directApplicationStatementIR)), then

      1. (Let directApplicationStatementIR be (statementIR as directApplicationStatementIR))

      2. Result in TC_1, (directApplicationStatementIR as parserStatementIR)

    3. Else Phantom#904

  7. Case (% has type parserBlockStatement)

    1. (Let (ParserBlockS parserStatement*{parserStatement <- parserStatement*}) be (parserStatement'' as parserBlockStatement))

    2. (Let TC_1 be $enter(TC_0'))

    3. (ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*})

    4. (Let TC_3 be $exit(TC_2))

    5. (Let parserBlockStatementIR be (ParserBlockS parserStatementIR*{parserStatementIR <- parserStatementIR*}))

    6. Result in TC_3, (parserBlockStatementIR as parserStatementIR)

  8. Case (% has type conditionalStatement)

    1. (Let conditionalStatement be (parserStatement'' as conditionalStatement))

    2. (Stmt_ok: (LOCAL) TC_0' (CONT) |- (conditionalStatement as statement) : TC_1 _flow statementIR)

    3. If ((statementIR has type conditionalStatementIR)), then

      1. (Let conditionalStatementIR be (statementIR as conditionalStatementIR))

      2. Result in TC_1, (conditionalStatementIR as parserStatementIR)

    3. Else Phantom#905

;; ../../../../spec-concrete/5.04-typing-relation.watsup:155.1-157.20
relation ParserStmts_ok: TC', parserStatement*{parserStatement <- parserStatement*}

1. Case analysis on parserStatement*{parserStatement <- parserStatement*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserStatement_h :: parserStatement_t*{parserStatement_t <- parserStatement_t*} be parserStatement*{parserStatement <- parserStatement*})

    2. (ParserStmt_ok: TC' |- parserStatement_h : TC_1 parserStatementIR_h)

    3. (ParserStmts_ok: TC_1 |- parserStatement_t*{parserStatement_t <- parserStatement_t*} : TC_2 parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*})

    4. Result in TC_2, parserStatementIR_h :: parserStatementIR_t*{parserStatementIR_t <- parserStatementIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:159.1-161.23
relation ParserState_ok: TC_0, name_state*{name_state <- name_state*}, (name parserStatement*{parserStatement <- parserStatement*} transitionStatement''?{transitionStatement'' <- transitionStatement''?})

1. Case analysis on transitionStatement''?{transitionStatement'' <- transitionStatement''?}

  1. Case (% matches pattern ())

    1. (Let TC_1 be $enter(TC_0))

    2. (ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*})

    3. (Let transitionStatementIR be (TransS ?((NameE "reject"))))

    4. (Let TC_3 be $exit(TC_2))

    5. (Let parserStateIR be (name parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR))

    6. Result in parserStateIR

  2. Case (% matches pattern (_))

    1. (Let ?(transitionStatement) be transitionStatement''?{transitionStatement'' <- transitionStatement''?})

    2. (Let TC_1 be $enter(TC_0))

    3. (ParserStmts_ok: TC_1 |- parserStatement*{parserStatement <- parserStatement*} : TC_2 parserStatementIR*{parserStatementIR <- parserStatementIR*})

    4. (ParserTransition_ok: TC_2 name_state*{name_state <- name_state*} |- transitionStatement : transitionStatementIR)

    5. (Let TC_3 be $exit(TC_2))

    6. (Let parserStateIR be (name parserStatementIR*{parserStatementIR <- parserStatementIR*} transitionStatementIR))

    7. Result in parserStateIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:163.1-165.20
relation ParserStates_ok: TC, parserState*{parserState <- parserState*}

1. (Let (name_state _parserStatement*{_parserStatement <- _parserStatement*} _transitionStatement?{_transitionStatement <- _transitionStatement?}) be parserState)*{_parserStatement* <- _parserStatement**, _transitionStatement? <- _transitionStatement?*, name_state <- name_state*, parserState <- parserState*}

2. If ($distinct_<name>(name_state*{name_state <- name_state*})), then

  1. If ("start" is in name_state*{name_state <- name_state*}), then

    1. If ((~"accept" is in name_state*{name_state <- name_state*} /\ ~"reject" is in name_state*{name_state <- name_state*})), then

      1. (Let name_state_impl*{name_state_impl <- name_state_impl*} be "accept" :: "reject" :: name_state*{name_state <- name_state*})

      2. (ParserState_ok: TC name_state_impl*{name_state_impl <- name_state_impl*} |- parserState : parserStateIR)*{parserState <- parserState*, parserStateIR <- parserStateIR*}

      3. Result in parserStateIR*{parserStateIR <- parserStateIR*}

    1. Else Phantom#906

  1. Else Phantom#907

2. Else Phantom#908

;; ../../../../spec-concrete/5.04-typing-relation.watsup:167.1-170.20
relation ParserLocalDecl_ok: TC_0, parserLocalDeclaration

1. Case analysis on parserLocalDeclaration

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (parserLocalDeclaration as constantDeclaration))

    2. (Decl_ok: (BLOCK) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as parserLocalDeclarationIR)

    3. Else Phantom#909

  2. Case (% has type instantiation)

    1. (Let instantiation be (parserLocalDeclaration as instantiation))

    2. (Decl_ok: (BLOCK) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as parserLocalDeclarationIR)

    3. Else Phantom#910

  3. Case (% has type variableDeclaration)

    1. (Let (VarD type name initializer?{initializer <- initializer?}) be (parserLocalDeclaration as variableDeclaration))

    2. Case analysis on initializer?{initializer <- initializer?}

      1. Case (% matches pattern ())

        1. (Type_ok: (BLOCK) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        2. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((BLOCK), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((INOUT) typeIR (DYN) ?())))

              2. (Let variableDeclarationIR be (VarD typeIR name ?()))

              3. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

            1. Else Phantom#911

          1. Else Phantom#912

        2. Else Phantom#913

      2. Case (% matches pattern (_))

        1. (Let ?(expression_init) be initializer?{initializer <- initializer?})

        2. (Type_ok: (BLOCK) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((BLOCK), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (BLOCK) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

                2. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((INOUT) typeIR (DYN) ?())))

                3. (Let variableDeclarationIR be (VarD typeIR name ?(typedExpressionIR_init_cast)))

                4. Result in TC_1, (variableDeclarationIR as parserLocalDeclarationIR)

              3. Else Phantom#914

            1. Else Phantom#915

          1. Else Phantom#916

        3. Else Phantom#917

  4. Case (% has type valueSetDeclaration)

    1. (Let (ValueSetD valueSetType expression name) be (parserLocalDeclaration as valueSetDeclaration))

    2. (Type_ok: (BLOCK) TC_0 |- (valueSetType as typeOrVoid) : typeIR tid*{tid <- tid*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((Type_wf: $bound((BLOCK), TC_0) |- ((SetT typeIR) as typeIR) holds)), then

        1. (Expr_ok: (BLOCK) TC_0 |- expression : typedExpressionIR)

        2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

        3. If (~(ctk matches pattern `DYN`)), then

          1. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((NO) ((SetT typeIR) as typeIR) (CTK) ?())))

          2. (Let valueSetDeclarationIR be (ValueSetD typeIR typedExpressionIR name))

          3. Result in TC_1, (valueSetDeclarationIR as parserLocalDeclarationIR)

        3. Else Phantom#918

      1. Else Phantom#919

    3. Else Phantom#920

;; ../../../../spec-concrete/5.04-typing-relation.watsup:172.1-175.20
relation ParserLocalDecls_ok: TC', parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}

1. Case analysis on parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let parserLocalDeclaration_h :: parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} be parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*})

    2. (ParserLocalDecl_ok: TC' |- parserLocalDeclaration_h : TC_1 parserLocalDeclarationIR_h)

    3. (ParserLocalDecls_ok: TC_1 |- parserLocalDeclaration_t*{parserLocalDeclaration_t <- parserLocalDeclaration_t*} : TC_2 parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*})

    4. Result in TC_2, parserLocalDeclarationIR_h :: parserLocalDeclarationIR_t*{parserLocalDeclarationIR_t <- parserLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:181.1-183.23
relation TableKey_ok: TC, TBLC_0, (expression name_matchkind)

1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

2. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR)

3. If ((Type_wf: $bound((LOCAL), TC) |- ((SetT typeIR) as typeIR) holds)), then

  1. If ((?(((MatchKindV name_matchkind) as value)) = $find_value((LOCAL), TC, (CURRENT name_matchkind)))), then

    1. If ($compat_table_key(name_matchkind, typeIR)), then

      1. (Let TBLC_1 be $update_mode(TBLC_0, name_matchkind, typeIR))

      2. (Let TBLC_2 be $add_key(TBLC_1, name_matchkind, typeIR))

      3. (Let tableKeyIR be (typedExpressionIR name_matchkind))

      4. Result in TBLC_2, tableKeyIR

    1. Else Phantom#921

  1. Else Phantom#922

3. Else Phantom#923

;; ../../../../spec-concrete/5.04-typing-relation.watsup:185.1-187.23
relation TableKeys_ok: TC, TBLC', tableKey*{tableKey <- tableKey*}

1. Case analysis on tableKey*{tableKey <- tableKey*}

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableKey_h :: tableKey_t*{tableKey_t <- tableKey_t*} be tableKey*{tableKey <- tableKey*})

    2. (TableKey_ok: TC TBLC' |- tableKey_h : TBLC_1 tableKeyIR_h)

    3. (TableKeys_ok: TC TBLC_1 |- tableKey_t*{tableKey_t <- tableKey_t*} : TBLC_2 tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*})

    4. Result in TBLC_2, tableKeyIR_h :: tableKeyIR_t*{tableKeyIR_t <- tableKeyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:189.1-192.23
relation Call_action_partial_ok: TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}

1. (Let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) be $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

2. If ((|parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

  1. (Call_convention_ok: (LOCAL) TC (ACTION) |- parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

  2. Result in parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

2. Else Phantom#924

;; ../../../../spec-concrete/5.04-typing-relation.watsup:194.1-196.23
relation TableAction_ok: TC, TBLC_0, (prefixedName argument*{argument <- argument*})

1. (Let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} be $find_routine_non_overloaded((LOCAL), TC, prefixedName))

2. If (((rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches pattern (_))), then

  1. (Let ?((_rid, routineTypeDefIR)) be (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?})

  2. If ((routineTypeDefIR has type monoRoutineTypeDefIR)), then

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. If ((routineTypeIR matches pattern `ActionT%`)), then

      1. (Let (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

      2. (Argument_ok: (LOCAL) TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

      3. (Call_action_partial_ok: TC |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*} parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

      4. (Let TBLC_1 be $add_action(TBLC_0, prefixedName, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

      5. (Let tableActionIR be (prefixedName argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}))

      6. Result in TBLC_1, tableActionIR

    2. Else Phantom#925

  2. Else Phantom#926

2. Else Phantom#927

;; ../../../../spec-concrete/5.04-typing-relation.watsup:198.1-200.23
relation TableActions_ok: TC, TBLC', tableAction*{tableAction <- tableAction*}

1. Case analysis on tableAction*{tableAction <- tableAction*}

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableAction_h :: tableAction_t*{tableAction_t <- tableAction_t*} be tableAction*{tableAction <- tableAction*})

    2. (TableAction_ok: TC TBLC' |- tableAction_h : TBLC_1 tableActionIR_h)

    3. (TableActions_ok: TC TBLC_1 |- tableAction_t*{tableAction_t <- tableAction_t*} : TBLC_2 tableActionIR_t*{tableActionIR_t <- tableActionIR_t*})

    4. Result in TBLC_2, tableActionIR_h :: tableActionIR_t*{tableActionIR_t <- tableActionIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:202.1-205.23
relation Call_action_default_ok: TC, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}

1. (Let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) be $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

2. (Call_convention_ok: (LOCAL) TC (ACTION) |- parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

3. Result in parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:207.1-209.23
relation TableDefaultAction_ok: TC, TBLC, initializer

1. Case analysis on initializer

  1. Case (% has type referenceExpression)

    1. (Let (NameE prefixedName) be (initializer as referenceExpression))

    2. If ((?(([], [])) = $find_action(TBLC, prefixedName))), then

      1. Result in (prefixedName [])

    2. Else Phantom#928

  2. Case (% has type callExpression)

    1. (Let callExpression be (initializer as callExpression))

    2. If ((callExpression matches pattern `CallE%%%`)), then

      1. (Let (CallE routineTarget typeArgument*{typeArgument <- typeArgument*} argument*{argument <- argument*}) be callExpression)

      2. If ((routineTarget has type referenceExpression)), then

        1. (Let (NameE prefixedName) be (routineTarget as referenceExpression))

        2. If ((typeArgument*{typeArgument <- typeArgument*} matches pattern [])), then

          1. (Let (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} be $find_action(TBLC, prefixedName))

          2. If (((parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} matches pattern (_))), then

            1. (Let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) be (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?})

            2. (Argument_ok: (LOCAL) TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            3. (Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            4. (Let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} be argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|])

            5. (Let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} be argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|])

            6. If ((argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}, then

              1. Result in (prefixedName argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            6. Else Phantom#929

          2. Else Phantom#930

        2. Else Phantom#931

      2. Else Phantom#932

    2. Else Phantom#933

1. Else Phantom#934

;; ../../../../spec-concrete/5.04-typing-relation.watsup:211.1-213.23
relation TableEntry_keysets_ok: TC, TBLC, keysetExpression*{keysetExpression <- keysetExpression*}

1. Case analysis on keysetExpression*{keysetExpression <- keysetExpression*}

  1. Case (% = [(DefaultK)])

    1. (Let matchMode be TBLC.MODE)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM n) be matchMode)

      2. (Let TBLS be (LPM n))

      3. Result in TBLS, [(DefaultK)]

    2. Else Phantom#935

    3. Case analysis on TBLC.MODE

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(DefaultK)]

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(DefaultK)]

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(DefaultK)]

    3. Else Phantom#936

  2. Case (% = [(AnyK)])

    1. (Let matchMode be TBLC.MODE)

    2. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM n) be matchMode)

      2. (Let TBLS be (LPM 0))

      3. Result in TBLS, [(AnyK)]

    2. Else Phantom#937

    3. Case analysis on TBLC.MODE

      1. Case (% matches pattern `NOPRI`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(AnyK)]

      2. Case (% matches pattern `PRI`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(AnyK)]

      3. Case (% matches pattern `PRILPM`)

        1. (Let TBLS be (NOLPM))

        2. Result in TBLS, [(AnyK)]

    3. Else Phantom#938

1. Else Phantom#939

2. If (((keysetExpression*{keysetExpression <- keysetExpression*} =/= [(AnyK)]) /\ (keysetExpression*{keysetExpression <- keysetExpression*} =/= [(DefaultK)]))), then

  1. If ((|TBLC.KEYS| = |keysetExpression*{keysetExpression <- keysetExpression*}|)), then

    1. (TableEntry_keysets_ok': TC TBLC (NOLPM) |- TBLC.KEYS keysetExpression*{keysetExpression <- keysetExpression*} : TBLS keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})

    2. Result in TBLS, keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*}

  1. Else Phantom#940

2. Else Phantom#941

;; ../../../../spec-concrete/5.04-typing-relation.watsup:215.1-217.23
relation TableEntry_action_ok: TC, TBLC, (prefixedName argument*{argument <- argument*})

1. (Let (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} be $find_action(TBLC, prefixedName))

2. If (((parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?} matches pattern (_))), then

  1. (Let ?((parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*}, argumentIR_action*{argumentIR_action <- argumentIR_action*})) be (parameterTypeIR*, argumentIR*)?{(parameterTypeIR*, argumentIR*) <- (parameterTypeIR*, argumentIR*)?})

  2. (Argument_ok: (LOCAL) TC |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

  3. (Call_action_default_ok: TC |- parameterTypeIR_action*{parameterTypeIR_action <- parameterTypeIR_action*} argumentIR*{argumentIR <- argumentIR*} : parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*} parameterTypeIR_action_control*{parameterTypeIR_action_control <- parameterTypeIR_action_control*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

  4. (Let argumentIR_action_data*{argumentIR_action_data <- argumentIR_action_data*} be argumentIR_action*{argumentIR_action <- argumentIR_action*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|])

  5. (Let argumentIR_cast_data*{argumentIR_cast_data <- argumentIR_cast_data*} be argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}[0 : |parameterTypeIR_action_data*{parameterTypeIR_action_data <- parameterTypeIR_action_data*}|])

  6. If ((argumentIR_action_data = argumentIR_cast_data))*{argumentIR_action_data <- argumentIR_action_data*, argumentIR_cast_data <- argumentIR_cast_data*}, then

    1. Result in (prefixedName argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

  6. Else Phantom#942

2. Else Phantom#943

;; ../../../../spec-concrete/5.04-typing-relation.watsup:219.1-222.26
relation TableEntry_priority_ok: TC, TBLC', TBLS, tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}

1. Case analysis on tableEntryPriority?{tableEntryPriority <- tableEntryPriority?}

  1. Case (% matches pattern ())

    1. If ((TBLC'.MODE matches pattern `NOPRI`)), then

      1. Result in TBLC', ?()

    1. Else Phantom#944

    2. (Let matchMode be TBLC'.MODE)

    3. If ((matchMode matches pattern `NOPRILPM%`)), then

      1. (Let (NOPRILPM n) be matchMode)

      2. (Let tableEntryState be TBLS)

      3. If ((tableEntryState matches pattern `LPM%`)), then

        1. (Let (LPM n_prefix) be tableEntryState)

        2. Result in TBLC', ?()

      3. Else Phantom#945

    3. Else Phantom#946

    4. Case analysis on TBLC'.MODE

      1. Case (% matches pattern `PRI`)

        1. Case analysis on TBLC'.PRIORITIES.VALUES

          1. Case (% = [])

            1. Case analysis on TBLC'.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let n_size be TBLC'.ENTRIES.SIZE)

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let int be (((n_size - 1) * (n_delta as int)) + (1 as int)))

                4. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                  3. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                  4. Result in TBLC_1, ?(typedExpressionIR)

                4. Else Phantom#947

              2. Case false

                1. (Let TBLC_1 be $add_table_priority(TBLC', 1))

                2. (Let typedExpressionIR be (((NumE (INT (1 as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                3. Result in TBLC_1, ?(typedExpressionIR)

          2. Case (% =/= [])

            1. Case analysis on TBLC'.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let int be (n_last - n_delta))

                4. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                  3. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                  4. Result in TBLC_1, ?(typedExpressionIR)

                4. Else Phantom#948

              2. Case false

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let n be (n_last + n_delta))

                4. (Let TBLC_1 be $add_table_priority(TBLC', n))

                5. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                6. Result in TBLC_1, ?(typedExpressionIR)

      2. Case (% matches pattern `PRILPM`)

        1. Case analysis on TBLC'.PRIORITIES.VALUES

          1. Case (% = [])

            1. Case analysis on TBLC'.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let n_size be TBLC'.ENTRIES.SIZE)

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let int be (((n_size - 1) * (n_delta as int)) + (1 as int)))

                4. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                  3. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                  4. Result in TBLC_1, ?(typedExpressionIR)

                4. Else Phantom#949

              2. Case false

                1. (Let TBLC_1 be $add_table_priority(TBLC', 1))

                2. (Let typedExpressionIR be (((NumE (INT (1 as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                3. Result in TBLC_1, ?(typedExpressionIR)

          2. Case (% =/= [])

            1. Case analysis on TBLC'.PRIORITIES.LARGEST_WINS

              1. Case true

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let int be (n_last - n_delta))

                4. If ((int has type nat)), then

                  1. (Let n be (int as nat))

                  2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                  3. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                  4. Result in TBLC_1, ?(typedExpressionIR)

                4. Else Phantom#950

              2. Case false

                1. (Let n_last be $find_table_priority_last(TBLC'))

                2. (Let n_delta be TBLC'.PRIORITIES.DELTA)

                3. (Let n be (n_last + n_delta))

                4. (Let TBLC_1 be $add_table_priority(TBLC', n))

                5. (Let typedExpressionIR be (((NumE (INT (n as int))) as expressionIR) (( ((IntT) as typeIR) (LCTK) ))))

                6. Result in TBLC_1, ?(typedExpressionIR)

    4. Else Phantom#951

  2. Case (% matches pattern (_))

    1. (Let ?(expression) be tableEntryPriority?{tableEntryPriority <- tableEntryPriority?})

    2. Case analysis on TBLC'.MODE

      1. Case (% matches pattern `PRI`)

        1. If (~TBLC'.ENTRIES.CONST), then

          1. Case analysis on TBLC'.PRIORITIES.VALUES

            1. Case (% = [])

              1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

              2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

              3. If ((ctk matches pattern `LCTK`)), then

                1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

                2. (Let int'?{int' <- int'?} be $to_number(value))

                3. If ((int'?{int' <- int'?} matches pattern (_))), then

                  1. (Let ?(int) be int'?{int' <- int'?})

                  2. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be TBLC'[PRIORITIES.INIT = true])

                    3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                    4. Result in TBLC_2, ?(typedExpressionIR)

                  2. Else Phantom#952

                3. Else Phantom#953

              3. Else Phantom#954

            2. Case (% =/= [])

              1. If (TBLC'.PRIORITIES.INIT), then

                1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

                  2. (Let int'?{int' <- int'?} be $to_number(value))

                  3. If ((int'?{int' <- int'?} matches pattern (_))), then

                    1. (Let ?(int) be int'?{int' <- int'?})

                    2. If ((int has type nat)), then

                      1. (Let n be (int as nat))

                      2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                      3. Result in TBLC_1, ?(typedExpressionIR)

                    2. Else Phantom#955

                  3. Else Phantom#956

                3. Else Phantom#957

              1. Else Phantom#958

        1. Else Phantom#959

      2. Case (% matches pattern `PRILPM`)

        1. If (~TBLC'.ENTRIES.CONST), then

          1. Case analysis on TBLC'.PRIORITIES.VALUES

            1. Case (% = [])

              1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

              2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

              3. If ((ctk matches pattern `LCTK`)), then

                1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

                2. (Let int'?{int' <- int'?} be $to_number(value))

                3. If ((int'?{int' <- int'?} matches pattern (_))), then

                  1. (Let ?(int) be int'?{int' <- int'?})

                  2. If ((int has type nat)), then

                    1. (Let n be (int as nat))

                    2. (Let TBLC_1 be TBLC'[PRIORITIES.INIT = true])

                    3. (Let TBLC_2 be $add_table_priority(TBLC_1, n))

                    4. Result in TBLC_2, ?(typedExpressionIR)

                  2. Else Phantom#960

                3. Else Phantom#961

              3. Else Phantom#962

            2. Case (% =/= [])

              1. If (TBLC'.PRIORITIES.INIT), then

                1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

                2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR)

                3. If ((ctk matches pattern `LCTK`)), then

                  1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

                  2. (Let int'?{int' <- int'?} be $to_number(value))

                  3. If ((int'?{int' <- int'?} matches pattern (_))), then

                    1. (Let ?(int) be int'?{int' <- int'?})

                    2. If ((int has type nat)), then

                      1. (Let n be (int as nat))

                      2. (Let TBLC_1 be $add_table_priority(TBLC', n))

                      3. Result in TBLC_1, ?(typedExpressionIR)

                    2. Else Phantom#963

                  3. Else Phantom#964

                3. Else Phantom#965

              1. Else Phantom#966

        1. Else Phantom#967

    2. Else Phantom#968

;; ../../../../spec-concrete/5.04-typing-relation.watsup:224.1-226.23
relation TableEntry_ok: TC, TBLC_0, (const?{const <- const?} tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} keysetExpression*{keysetExpression <- keysetExpression*} tableActionReference)

1. (TableEntry_keysets_ok: TC TBLC_0 |- keysetExpression*{keysetExpression <- keysetExpression*} : TBLS keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})

2. (TableEntry_action_ok: TC TBLC_0 |- tableActionReference : tableActionReferenceIR)

3. (TableEntry_priority_ok: TC TBLC_0 TBLS |- tableEntryPriority?{tableEntryPriority <- tableEntryPriority?} : TBLC_1 tableEntryPriorityIR?{tableEntryPriorityIR <- tableEntryPriorityIR?})

4. (Let tableEntryIR be (const?{const <- const?} tableEntryPriorityIR?{tableEntryPriorityIR <- tableEntryPriorityIR?} keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*} tableActionReferenceIR))

5. Result in TBLC_1, tableEntryIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:228.1-230.23
relation TableEntries_ok: TC, TBLC', tableEntry*{tableEntry <- tableEntry*}

1. Case analysis on tableEntry*{tableEntry <- tableEntry*}

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableEntry_h :: tableEntry_t*{tableEntry_t <- tableEntry_t*} be tableEntry*{tableEntry <- tableEntry*})

    2. (TableEntry_ok: TC TBLC' |- tableEntry_h : TBLC_1 tableEntryIR_h)

    3. (TableEntries_ok: TC TBLC_1 |- tableEntry_t*{tableEntry_t <- tableEntry_t*} : TBLC_2 tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*})

    4. Result in TBLC_2, tableEntryIR_h :: tableEntryIR_t*{tableEntryIR_t <- tableEntryIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:232.1-234.23
relation TableProperty_ok: TC, TBLC_0', tableProperty

1. Case analysis on tableProperty

  1. Case (% matches pattern `KeyP%`)

    1. (Let (KeyP tableKey*{tableKey <- tableKey*}) be tableProperty)

    2. (TableKeys_ok: TC TBLC_0' |- tableKey*{tableKey <- tableKey*} : TBLC_1 tableKeyIR*{tableKeyIR <- tableKeyIR*})

    3. Result in TBLC_1, (KeyP tableKeyIR*{tableKeyIR <- tableKeyIR*})

  2. Case (% matches pattern `ActionP%`)

    1. (Let (ActionP tableAction*{tableAction <- tableAction*}) be tableProperty)

    2. (TableActions_ok: TC TBLC_0' |- tableAction*{tableAction <- tableAction*} : TBLC_1 tableActionIR*{tableActionIR <- tableActionIR*})

    3. Result in TBLC_1, (ActionP tableActionIR*{tableActionIR <- tableActionIR*})

  3. Case (% matches pattern `EntryP%%`)

    1. (Let (EntryP const?{const <- const?} tableEntry*{tableEntry <- tableEntry*}) be tableProperty)

    2. If (((|TBLC_0'.KEYS| = 0) => (|tableEntry*{tableEntry <- tableEntry*}| = 0))), then

      1. (Let TBLC_1 be TBLC_0'[ENTRIES.SIZE = |tableEntry*{tableEntry <- tableEntry*}|])

      2. (Let TBLC_2 be TBLC_1[ENTRIES.CONST = (const?{const <- const?} = ?((CONST)))])

      3. (TableEntries_ok: TC TBLC_2 |- tableEntry*{tableEntry <- tableEntry*} : TBLC_3 tableEntryIR*{tableEntryIR <- tableEntryIR*})

      4. Result in TBLC_3, (EntryP const?{const <- const?} tableEntryIR*{tableEntryIR <- tableEntryIR*})

    2. Else Phantom#969

  4. Case (% matches pattern `CustomP%%%`)

    1. (Let (CustomP const?{const <- const?} text initializer) be tableProperty)

    2. Case analysis on text

      1. Case (% = "default_action")

        1. (TableDefaultAction_ok: TC TBLC_0' |- initializer : tableActionReferenceIR)

        2. (Let tablePropertyIR be (DefaultActionP const?{const <- const?} tableActionReferenceIR))

        3. Result in TBLC_0', tablePropertyIR

      2. Case (% = "size")

        1. (Expr_ok: (LOCAL) TC |- initializer : typedExpressionIR)

        2. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR)

        3. If ($is_arbitrary_int_typeIR(typeIR)), then

          1. (Let tablePropertyIR be (CustomP const?{const <- const?} "size" typedExpressionIR))

          2. Result in TBLC_0', tablePropertyIR

        3. Else Phantom#970

        4. If ($is_fixed_int_typeIR(typeIR)), then

          1. (Let tablePropertyIR be (CustomP const?{const <- const?} "size" typedExpressionIR))

          2. Result in TBLC_0', tablePropertyIR

        4. Else Phantom#971

        5. If ($is_fixed_bit_typeIR(typeIR)), then

          1. (Let tablePropertyIR be (CustomP const?{const <- const?} "size" typedExpressionIR))

          2. Result in TBLC_0', tablePropertyIR

        5. Else Phantom#972

      3. Case (% = "largest_priority_wins")

        1. (Expr_ok: (LOCAL) TC |- initializer : typedExpressionIR)

        2. (Let (_expressionIR expressionNoteIR) be typedExpressionIR)

        3. If ((expressionNoteIR = (( ((BoolT) as typeIR) (LCTK) )))), then

          1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

          2. If ((value has type primitiveValue)), then

            1. (Let primitiveValue be (value as primitiveValue))

            2. If ((primitiveValue matches pattern `BoolV%`)), then

              1. (Let (BoolV b_largest_priority_wins) be primitiveValue)

              2. (Let TBLC_1 be TBLC_0'[PRIORITIES.LARGEST_WINS = b_largest_priority_wins])

              3. (Let tablePropertyIR be (CustomConstP const?{const <- const?} "largest_priority_wins" ((BoolV b_largest_priority_wins) as constantInitializerIR)))

              4. Result in TBLC_1, tablePropertyIR

            2. Else Phantom#973

          2. Else Phantom#974

        3. Else Phantom#975

      4. Case (% = "priority_delta")

        1. (Expr_ok: (LOCAL) TC |- initializer : typedExpressionIR)

        2. (Let (_expressionIR (( typeIR ctk ))) be typedExpressionIR)

        3. If ((ctk matches pattern `LCTK`)), then

          1. If ($is_arbitrary_int_typeIR(typeIR)), then

            1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

            2. (Let int'?{int' <- int'?} be $to_number(value))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_delta be (int as nat))

                2. If ((n_delta > 0)), then

                  1. (Let TBLC_1 be TBLC_0'[PRIORITIES.DELTA = n_delta])

                  2. (Let tablePropertyIR be (CustomConstP const?{const <- const?} "priority_delta" ((IntV (n_delta as int)) as constantInitializerIR)))

                  3. Result in TBLC_1, tablePropertyIR

                2. Else Phantom#976

              2. Else Phantom#977

            3. Else Phantom#978

          1. Else Phantom#979

          2. If ($is_fixed_int_typeIR(typeIR)), then

            1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

            2. (Let int'?{int' <- int'?} be $to_number(value))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_delta be (int as nat))

                2. If ((n_delta > 0)), then

                  1. (Let TBLC_1 be TBLC_0'[PRIORITIES.DELTA = n_delta])

                  2. (Let tablePropertyIR be (CustomConstP const?{const <- const?} "priority_delta" ((IntV (n_delta as int)) as constantInitializerIR)))

                  3. Result in TBLC_1, tablePropertyIR

                2. Else Phantom#980

              2. Else Phantom#981

            3. Else Phantom#982

          2. Else Phantom#983

          3. If ($is_fixed_bit_typeIR(typeIR)), then

            1. (Eval_static: (LOCAL) TC |- typedExpressionIR ~> value)

            2. (Let int'?{int' <- int'?} be $to_number(value))

            3. If ((int'?{int' <- int'?} matches pattern (_))), then

              1. (Let ?(int) be int'?{int' <- int'?})

              2. If ((int has type nat)), then

                1. (Let n_delta be (int as nat))

                2. If ((n_delta > 0)), then

                  1. (Let TBLC_1 be TBLC_0'[PRIORITIES.DELTA = n_delta])

                  2. (Let tablePropertyIR be (CustomConstP const?{const <- const?} "priority_delta" ((IntV (n_delta as int)) as constantInitializerIR)))

                  3. Result in TBLC_1, tablePropertyIR

                2. Else Phantom#984

              2. Else Phantom#985

            3. Else Phantom#986

          3. Else Phantom#987

        3. Else Phantom#988

    2. Else Phantom#989

    3. If ((((text =/= "size") /\ (text =/= "largest_priority_wins")) /\ (text =/= "priority_delta"))), then

      1. (Expr_ok: (LOCAL) TC |- initializer : typedExpressionIR)

      2. (Let tablePropertyIR be (CustomP const?{const <- const?} text typedExpressionIR))

      3. Result in TBLC_0', tablePropertyIR

    3. Else Phantom#990

;; ../../../../spec-concrete/5.04-typing-relation.watsup:236.1-238.23
relation TableProperties_ok: TC, TBLC', tableProperty*{tableProperty <- tableProperty*}

1. Case analysis on tableProperty*{tableProperty <- tableProperty*}

  1. Case (% matches pattern [])

    1. Result in TBLC', []

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty_h :: tableProperty_t*{tableProperty_t <- tableProperty_t*} be tableProperty*{tableProperty <- tableProperty*})

    2. (TableProperty_ok: TC TBLC' |- tableProperty_h : TBLC_1 tablePropertyIR_h)

    3. (TableProperties_ok: TC TBLC_1 |- tableProperty_t*{tableProperty_t <- tableProperty_t*} : TBLC_2 tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*})

    4. Result in TBLC_2, tablePropertyIR_h :: tablePropertyIR_t*{tablePropertyIR_t <- tablePropertyIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:240.1-242.20
relation Table_ok: TC, tableProperty*{tableProperty <- tableProperty*}

1. If (($count_table_keys(tableProperty*{tableProperty <- tableProperty*}) <= 1)), then

  1. If (($count_table_actions(tableProperty*{tableProperty <- tableProperty*}) = 1)), then

    1. (Let TBLC_0 be $empty_tableContext)

    2. (TableProperties_ok: TC TBLC_0 |- tableProperty*{tableProperty <- tableProperty*} : TBLC_1 tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})

    3. Result in TBLC_1, tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}

  1. Else Phantom#991

1. Else Phantom#992

;; ../../../../spec-concrete/5.04-typing-relation.watsup:244.1-246.23
relation TableType_ok: TC_0, TBLC, name

1. (Let tid_enum be "action_list(" ++ name ++ ")")

2. (Let (prefixedName_action, _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}, _argumentIR*{_argumentIR <- _argumentIR*})*{_argumentIR* <- _argumentIR**, _parameterTypeIR* <- _parameterTypeIR**, prefixedName_action <- prefixedName_action*} be TBLC.ACTIONS)

3. (Let id_enum_field be $flatten_prefixedName(prefixedName_action))*{id_enum_field <- id_enum_field*, prefixedName_action <- prefixedName_action*}

4. (Let typeIR_table_enum be ((TableEnumT tid_enum id_enum_field*{id_enum_field <- id_enum_field*}) as typeIR))

5. (Let value_enum_field be ((TableEnumV tid_enum id_enum_field) as value))*{id_enum_field <- id_enum_field*, value_enum_field <- value_enum_field*}

6. (Let varTypeIR_enum_field be ((NO) typeIR_table_enum (LCTK) ?(value_enum_field)))*{value_enum_field <- value_enum_field*, varTypeIR_enum_field <- varTypeIR_enum_field*}

7. (Let TC_1 be $add_vars((BLOCK), TC_0, tid_enum ++ "." ++ id_enum_field*{id_enum_field <- id_enum_field*}, varTypeIR_enum_field*{varTypeIR_enum_field <- varTypeIR_enum_field*}))

8. (Let tid_struct be "apply_result(" ++ name ++ ")")

9. (Let typeIR_table_struct be ((TableStructT tid_struct [(((BoolT) as typeIR) "hit"), (((BoolT) as typeIR) "miss"), (typeIR_table_enum "action_run")]) as typeIR))

10. (Let typeIR_table be ((TableT name typeIR_table_struct) as typeIR))

11. Result in TC_1, typeIR_table

;; ../../../../spec-concrete/5.04-typing-relation.watsup:248.1-251.20
relation ControlLocalDecl_ok: TC_0, controlLocalDeclaration

1. Case analysis on controlLocalDeclaration

  1. Case (% has type constantDeclaration)

    1. (Let constantDeclaration be (controlLocalDeclaration as constantDeclaration))

    2. (Decl_ok: (BLOCK) TC_0 |- (constantDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type constantDeclarationIR)), then

      1. (Let constantDeclarationIR be (declarationIR as constantDeclarationIR))

      2. Result in TC_1, (constantDeclarationIR as controlLocalDeclarationIR)

    3. Else Phantom#993

  2. Case (% has type instantiation)

    1. (Let instantiation be (controlLocalDeclaration as instantiation))

    2. (Decl_ok: (BLOCK) TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. Result in TC_1, (instantiationIR as controlLocalDeclarationIR)

    3. Else Phantom#994

  3. Case (% has type variableDeclaration)

    1. (Let (VarD type name initializer?{initializer <- initializer?}) be (controlLocalDeclaration as variableDeclaration))

    2. Case analysis on initializer?{initializer <- initializer?}

      1. Case (% matches pattern ())

        1. (Type_ok: (BLOCK) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        2. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((BLOCK), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((INOUT) typeIR (DYN) ?())))

              2. (Let variableDeclarationIR be (VarD typeIR name ?()))

              3. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

            1. Else Phantom#995

          1. Else Phantom#996

        2. Else Phantom#997

      2. Case (% matches pattern (_))

        1. (Let ?(expression_init) be initializer?{initializer <- initializer?})

        2. (Type_ok: (BLOCK) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. If ((Type_wf: $bound((BLOCK), TC_0) |- typeIR holds)), then

            1. If ($is_assignable_typeIR(typeIR)), then

              1. (Expr_ok: (BLOCK) TC_0 |- expression_init : typedExpressionIR_init)

              2. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_init, typeIR))

              3. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

                1. (Let ?(typedExpressionIR_init_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

                2. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((INOUT) typeIR (DYN) ?())))

                3. (Let variableDeclarationIR be (VarD typeIR name ?(typedExpressionIR_init_cast)))

                4. Result in TC_1, (variableDeclarationIR as controlLocalDeclarationIR)

              3. Else Phantom#998

            1. Else Phantom#999

          1. Else Phantom#1000

        3. Else Phantom#1001

  4. Case (% has type actionDeclaration)

    1. (Let actionDeclaration be (controlLocalDeclaration as actionDeclaration))

    2. (Decl_ok: (BLOCK) TC_0 |- (actionDeclaration as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type actionDeclarationIR)), then

      1. (Let actionDeclarationIR be (declarationIR as actionDeclarationIR))

      2. Result in TC_1, (actionDeclarationIR as controlLocalDeclarationIR)

    3. Else Phantom#1002

  5. Case (% has type tableDeclaration)

    1. (Let (TableD name tableProperty*{tableProperty <- tableProperty*}) be (controlLocalDeclaration as tableDeclaration))

    2. (Let TC_1 be TC_0[LOCAL.KIND = (TABLEAPPLYMETHOD)])

    3. (Table_ok: TC_1 |- tableProperty*{tableProperty <- tableProperty*} : TBLC tablePropertyIR*{tablePropertyIR <- tablePropertyIR*})

    4. (TableType_ok: TC_1 TBLC |- name : TC_2 typeIR_table)

    5. (Let TC_3 be $add_var((BLOCK), TC_2, name, ((NO) typeIR_table (DYN) ?())))

    6. (Let tableDeclarationIR be (TableD typeIR_table name tablePropertyIR*{tablePropertyIR <- tablePropertyIR*}))

    7. Result in TC_3, (tableDeclarationIR as controlLocalDeclarationIR)

;; ../../../../spec-concrete/5.04-typing-relation.watsup:253.1-256.20
relation ControlLocalDecls_ok: TC', controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}

1. Case analysis on controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let controlLocalDeclaration_h :: controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} be controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*})

    2. (ControlLocalDecl_ok: TC' |- controlLocalDeclaration_h : TC_1 controlLocalDeclarationIR_h)

    3. (ControlLocalDecls_ok: TC_1 |- controlLocalDeclaration_t*{controlLocalDeclaration_t <- controlLocalDeclaration_t*} : TC_2 controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*})

    4. Result in TC_2, controlLocalDeclarationIR_h :: controlLocalDeclarationIR_t*{controlLocalDeclarationIR_t <- controlLocalDeclarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:262.1-264.23
relation Decl_ok: p', TC_0, declaration

1. Case analysis on declaration

  1. Case (% has type constantDeclaration)

    1. (Let (ConstD type name expression_value) be (declaration as constantDeclaration))

    2. (Type_ok: p' TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

    3. If ((tid*{tid <- tid*} matches pattern [])), then

      1. If ((Type_wf: $bound(p', TC_0) |- typeIR holds)), then

        1. (Expr_ok: p' TC_0 |- expression_value : typedExpressionIR_value)

        2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR_value)

        3. If ((ctk matches pattern `LCTK`)), then

          1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_value, typeIR))

          2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

            1. (Let ?(typedExpressionIR_value_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

            2. (Eval_static: p' TC_0 |- typedExpressionIR_value_cast ~> value)

            3. (Let TC_1 be $add_var(p', TC_0, name, ((NO) typeIR (LCTK) ?(value))))

            4. (Let constantDeclarationIR be (ConstD typeIR name value))

            5. Result in TC_1, (constantDeclarationIR as declarationIR)

          2. Else Phantom#1003

        3. Else Phantom#1004

      1. Else Phantom#1005

    3. Else Phantom#1006

  2. Case (% has type instantiation)

    1. (Let (InstD type argument*{argument <- argument*} name objectInitializer?{objectInitializer <- objectInitializer?}) be (declaration as instantiation))

    2. Case analysis on type

      1. Case (% has type nameType)

        1. (Let (NameT prefixedName) be (type as nameType))

        2. Case analysis on objectInitializer?{objectInitializer <- objectInitializer?}

          1. Case (% matches pattern ())

            1. (Argument_ok: p' TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            2. (ConstructorType_ok: p' TC_0 |- prefixedName [] argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_impl*{tid_impl <- tid_impl*} id_default*{id_default <- id_default*})

            3. (Inst_ok: p' TC_0 (NAMED) |- constructorTypeIR [] tid_impl*{tid_impl <- tid_impl*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            4. (Let TC_1 be $add_var(p', TC_0, name, ((NO) typeIR_object (CTK) ?())))

            5. (Let instantiationIR be (InstD typeIR_object prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR*{argumentIR <- argumentIR*} name ?()))

            6. Result in TC_1, (instantiationIR as declarationIR)

          2. Case (% matches pattern (_))

            1. (Let ?(objectDeclaration*{objectDeclaration <- objectDeclaration*}) be objectInitializer?{objectInitializer <- objectInitializer?})

            2. (Argument_ok: p' TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            3. (ConstructorType_ok: p' TC_0 |- prefixedName [] argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_impl*{tid_impl <- tid_impl*} id_default*{id_default <- id_default*})

            4. (Inst_ok: p' TC_0 (NAMED) |- constructorTypeIR [] tid_impl*{tid_impl <- tid_impl*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            5. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `SpecT%%`)), then

                  1. (Let (SpecT (PolyTD typeIR tid_expl*{tid_expl <- tid_expl*} tid'*{tid' <- tid'*}) typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (ExternT tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})), then

                      1. (Let TC_1 be $add_var((LOCAL), TC_0, "this", ((NO) typeIR_object (CTK) ?())))

                      2. (Decls_object_ok: p' TC_1 ({ [] }) ({ [] }) |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})

                      3. (Let tid*{tid <- tid*} be tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})

                      4. (Let theta be ({ (tid -> typeIR_arg)*{tid <- tid*, typeIR_arg <- typeIR_arg*} }))

                      5. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      6. (Let typeIR_object_init be ((SpecT (PolyTD ((ExternT tid_extern rdenv_init_subst) as typeIR) tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR))

                      7. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let TC_2 be $add_var(p', TC_0, name, ((NO) typeIR_object_init (CTK) ?())))

                        2. (Let instantiationIR be (InstD typeIR_object_init prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR*{argumentIR <- argumentIR*} name ?(objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})))

                        3. Result in TC_2, (instantiationIR as declarationIR)

                      7. Else Phantom#1007

                    2. Else Phantom#1008

                  2. Else Phantom#1009

                2. Else Phantom#1010

              2. Else Phantom#1011

            5. Else Phantom#1012

      2. Case (% has type specializedType)

        1. (Let (SpecT prefixedName typeArgument*{typeArgument <- typeArgument*}) be (type as specializedType))

        2. Case analysis on objectInitializer?{objectInitializer <- objectInitializer?}

          1. Case (% matches pattern ())

            1. (TypeArguments_ok: p' TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_impl*{tid_impl <- tid_impl*})

            2. (Argument_ok: p' TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            3. (ConstructorType_ok: p' TC_0 |- prefixedName typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_inserted*{tid_inserted <- tid_inserted*} id_default*{id_default <- id_default*})

            4. (Let tid_infer*{tid_infer <- tid_infer*} be tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*})

            5. (Inst_ok: p' TC_0 (NAMED) |- constructorTypeIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_infer*{tid_infer <- tid_infer*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            6. (Let TC_1 be $add_var(p', TC_0, name, ((NO) typeIR_object (CTK) ?())))

            7. (Let instantiationIR be (InstD typeIR_object prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR*{argumentIR <- argumentIR*} name ?()))

            8. Result in TC_1, (instantiationIR as declarationIR)

          2. Case (% matches pattern (_))

            1. (Let ?(objectDeclaration*{objectDeclaration <- objectDeclaration*}) be objectInitializer?{objectInitializer <- objectInitializer?})

            2. (TypeArguments_ok: p' TC_0 |- typeArgument*{typeArgument <- typeArgument*} : typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_impl*{tid_impl <- tid_impl*})

            3. (Argument_ok: p' TC_0 |- argument : argumentIR)*{argument <- argument*, argumentIR <- argumentIR*}

            4. (ConstructorType_ok: p' TC_0 |- prefixedName typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} argumentIR*{argumentIR <- argumentIR*} : constructorTypeIR tid_inserted*{tid_inserted <- tid_inserted*} id_default*{id_default <- id_default*})

            5. (Let tid_infer*{tid_infer <- tid_infer*} be tid_impl*{tid_impl <- tid_impl*} ++ tid_inserted*{tid_inserted <- tid_inserted*})

            6. (Inst_ok: p' TC_0 (NAMED) |- constructorTypeIR typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} tid_infer*{tid_infer <- tid_infer*} argumentIR*{argumentIR <- argumentIR*} id_default*{id_default <- id_default*} : typeIR_object typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            7. If ($is_extern_object_typeIR($canon(typeIR_object))), then

              1. (Let typeIR' be typeIR_object)

              2. If ((typeIR' has type namedTypeIR)), then

                1. (Let namedTypeIR be (typeIR' as namedTypeIR))

                2. If ((namedTypeIR matches pattern `SpecT%%`)), then

                  1. (Let (SpecT (PolyTD typeIR tid_expl*{tid_expl <- tid_expl*} tid'*{tid' <- tid'*}) typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

                  2. If ((typeIR has type externObjectTypeIR)), then

                    1. (Let (ExternT tid_extern rdenv_extern) be (typeIR as externObjectTypeIR))

                    2. If ((tid'*{tid' <- tid'*} = tid_impl*{tid_impl <- tid_impl*})), then

                      1. (Let TC_1 be $add_var((LOCAL), TC_0, "this", ((NO) typeIR_object (CTK) ?())))

                      2. (Decls_object_ok: p' TC_1 ({ [] }) ({ [] }) |- objectDeclaration*{objectDeclaration <- objectDeclaration*} : frame_init rdenv_init objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})

                      3. (Let tid*{tid <- tid*} be tid_expl*{tid_expl <- tid_expl*} ++ tid_impl*{tid_impl <- tid_impl*})

                      4. (Let theta be ({ (tid -> typeIR_arg)*{tid <- tid*, typeIR_arg <- typeIR_arg*} }))

                      5. (Let rdenv_init_subst be $subst_rdenv(theta, rdenv_extern, rdenv_init))

                      6. (Let typeIR_object_init be ((SpecT (PolyTD ((ExternT tid_extern rdenv_init_subst) as typeIR) tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) typeIR_arg*{typeIR_arg <- typeIR_arg*}) as typeIR))

                      7. If ($is_concrete_extern_object(typeIR_object_init)), then

                        1. (Let TC_2 be $add_var(p', TC_0, name, ((NO) typeIR_object_init (CTK) ?())))

                        2. (Let instantiationIR be (InstD typeIR_object_init prefixedName typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} argumentIR*{argumentIR <- argumentIR*} name ?(objectDeclarationIR*{objectDeclarationIR <- objectDeclarationIR*})))

                        3. Result in TC_2, (instantiationIR as declarationIR)

                      7. Else Phantom#1013

                    2. Else Phantom#1014

                  2. Else Phantom#1015

                2. Else Phantom#1016

              2. Else Phantom#1017

            7. Else Phantom#1018

    2. Else Phantom#1019

  3. Case (% has type functionDeclaration)

    1. (Let (FuncD typeOrVoid name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*} blockStatement) be (declaration as functionDeclaration))

    2. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

    3. (Let TC_1 be $add_types((LOCAL), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

    4. (Type_ok: (LOCAL) TC_1 |- typeOrVoid : typeIR_ret tid*{tid <- tid*})

    5. If ((tid*{tid <- tid*} matches pattern [])), then

      1. (Parameters_ok: (LOCAL) TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

      2. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

      3. (Let TC_2 be $add_parameters((LOCAL), TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

      4. (Let TC_3 be TC_2[LOCAL.KIND = (FUNC typeIR_ret)])

      5. (Block_ok: TC_3 (CONT) |- blockStatement : _typingContext f blockStatementIR)

      6. If ((f matches pattern `RET`)), then

        1. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        2. (Let routineTypeIR be (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        3. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p', TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload(p', TC_0, rid, routineTypeDefIR))

          2. (Let functionDeclarationIR be (FuncD typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*} blockStatementIR))

          3. Result in TC_4, (functionDeclarationIR as declarationIR)

        4. Else Phantom#1020

      6. Else Phantom#1021

      7. If ((typeIR_ret = ((VoidT) as typeIR))), then

        1. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        2. (Let routineTypeIR be (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        3. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p', TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload(p', TC_0, rid, routineTypeDefIR))

          2. (Let functionDeclarationIR be (FuncD typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*} blockStatementIR))

          3. Result in TC_4, (functionDeclarationIR as declarationIR)

        4. Else Phantom#1022

      7. Else Phantom#1023

    5. Else Phantom#1024

  4. Case (% has type actionDeclaration)

    1. (Let (ActionD name parameter*{parameter <- parameter*} blockStatement) be (declaration as actionDeclaration))

    2. (Let TC_1 be TC_0[LOCAL.KIND = (ACTION)])

    3. (Parameters_ok: (LOCAL) TC_1 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid*{tid <- tid*})

    4. If ((tid*{tid <- tid*} matches pattern [])), then

      1. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

      2. (Let TC_2 be $add_parameters((LOCAL), TC_1, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

      3. (Block_ok: TC_2 (CONT) |- blockStatement : _typingContext _flow blockStatementIR)

      4. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

      5. (Let routineTypeIR be (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

      6. If ((RoutineTypeDef_wf: $bound(p', TC_0) |- ((MonoTD routineTypeIR) as routineTypeDefIR) holds)), then

        1. (Let TC_3 be $add_routine_non_overload(p', TC_0, rid, ((MonoTD routineTypeIR) as routineTypeDefIR)))

        2. (Let actionDeclarationIR be (ActionD name parameterIR*{parameterIR <- parameterIR*} blockStatementIR))

        3. Result in TC_3, (actionDeclarationIR as declarationIR)

      6. Else Phantom#1025

    4. Else Phantom#1026

1. Else Phantom#1027

2. If ((p' matches pattern `GLOBAL`)), then

  1. Case analysis on declaration

    1. Case (% has type errorDeclaration)

      1. (Let (ErrD name*{name <- name*}) be (declaration as errorDeclaration))

      2. If ($distinct_<name>(name*{name <- name*})), then

        1. (Let name_error be "error." ++ name)*{name <- name*, name_error <- name_error*}

        2. (Let value_error be ((ErrV name) as value))*{name <- name*, value_error <- value_error*}

        3. (Let TC_1 be $add_vars((GLOBAL), TC_0, name_error*{name_error <- name_error*}, ((NO) ((ErrT) as typeIR) (LCTK) ?(value_error))*{value_error <- value_error*}))

        4. Result in TC_1, ((ErrD name*{name <- name*}) as declarationIR)

      2. Else Phantom#1028

    2. Case (% has type matchKindDeclaration)

      1. (Let (MatchKindD name*{name <- name*}) be (declaration as matchKindDeclaration))

      2. If ($distinct_<name>(name*{name <- name*})), then

        1. (Let value_match_kind be ((MatchKindV name) as value))*{name <- name*, value_match_kind <- value_match_kind*}

        2. (Let TC_1 be $add_vars((GLOBAL), TC_0, name*{name <- name*}, ((NO) ((MatchKindT) as typeIR) (LCTK) ?(value_match_kind))*{value_match_kind <- value_match_kind*}))

        3. Result in TC_1, ((MatchKindD name*{name <- name*}) as declarationIR)

      2. Else Phantom#1029

    3. Case (% has type externFunctionDeclaration)

      1. (Let (ExternFuncD typeOrVoid name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*}) be (declaration as externFunctionDeclaration))

      2. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      3. (Let TC_1 be $add_types((LOCAL), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      4. (Type_ok: (LOCAL) TC_1 |- typeOrVoid : typeIR_ret tid*{tid <- tid*})

      5. If ((tid*{tid <- tid*} matches pattern [])), then

        1. (Let TC_2 be TC_1[LOCAL.KIND = (EXTERNFUNC typeIR_ret)])

        2. (Parameters_ok: (LOCAL) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

        3. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

        4. (Let TC_3 be $add_parameters((LOCAL), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

        5. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        6. (Let routineTypeIR be (ExternFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        7. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        8. If ((RoutineTypeDef_wf: $bound((GLOBAL), TC_0) |- routineTypeDefIR holds)), then

          1. (Let TC_4 be $add_routine_overload((GLOBAL), TC_0, rid, routineTypeDefIR))

          2. (Let externFunctionDeclarationIR be (ExternFuncD typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*}))

          3. Result in TC_4, (externFunctionDeclarationIR as declarationIR)

        8. Else Phantom#1030

      5. Else Phantom#1031

    4. Case (% has type externObjectDeclaration)

      1. (Let (ExternObjectD name typeParameter*{typeParameter <- typeParameter*} methodPrototype*{methodPrototype <- methodPrototype*}) be (declaration as externObjectDeclaration))

      2. (Let (methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*}, methodPrototype_method*{methodPrototype_method <- methodPrototype_method*}) be $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*}))

      3. (Let TC_1 be TC_0[BLOCK.KIND = (EXTERN)])

      4. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      5. (Let TC_2 be $add_types((BLOCK), TC_1, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      6. (ExternMethods_ok: TC_2 name |- methodPrototype_method*{methodPrototype_method <- methodPrototype_method*} : TC_3 methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*})

      7. (Let typeIR_extern be ((ExternT name TC_3.BLOCK.RDENV) as typeIR))

      8. (Let typeDefIR_extern be ((PolyTD typeIR_extern tid_expl*{tid_expl <- tid_expl*} []) as typeDefIR))

      9. (Let TC_4 be $add_type((GLOBAL), TC_0, name, typeDefIR_extern))

      10. (Let TC_5 be TC_4[BLOCK.KIND = (EXTERN)])

      11. (Let TC_6 be $add_types((BLOCK), TC_5, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      12. (ExternConstructors_ok: TC_6 name |- methodPrototype_constructor*{methodPrototype_constructor <- methodPrototype_constructor*} : TC_7 methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*})

      13. (Let TC_8 be TC_4[GLOBAL.CDENV = TC_7.GLOBAL.CDENV])

      14. (Let externObjectDeclarationIR be (ExternObjectD name tid_expl*{tid_expl <- tid_expl*} methodPrototypeIR_constructor*{methodPrototypeIR_constructor <- methodPrototypeIR_constructor*} ++ methodPrototypeIR_method*{methodPrototypeIR_method <- methodPrototypeIR_method*}))

      15. Result in TC_8, (externObjectDeclarationIR as declarationIR)

    5. Case (% has type parserDeclaration)

      1. (Let (ParserD name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*} constructorParameter*{constructorParameter <- constructorParameter*} parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} parserState*{parserState <- parserState*}) be (declaration as parserDeclaration))

      2. If ((typeParameter*{typeParameter <- typeParameter*} matches pattern [])), then

        1. (Let TC_1 be TC_0[BLOCK.KIND = (PARSER)])

        2. (ConstructorParameters_ok: (BLOCK) TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}

          2. (Let TC_2 be $add_parameters((BLOCK), TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}))

          3. (Parameters_ok: (BLOCK) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid'*{tid' <- tid'*})

          4. If ((tid'*{tid' <- tid'*} matches pattern [])), then

            1. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

            2. (Let TC_3 be $add_parameters((BLOCK), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            3. (ParserLocalDecls_ok: TC_3 |- parserLocalDeclaration*{parserLocalDeclaration <- parserLocalDeclaration*} : TC_4 parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*})

            4. (Let TC_5 be TC_4[LOCAL.KIND = (PARSERSTATE)])

            5. (ParserStates_ok: TC_5 |- parserState*{parserState <- parserState*} : parserStateIR*{parserStateIR <- parserStateIR*})

            6. (Let routineTypeIR be (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            7. If ((RoutineTypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD routineTypeIR) as routineTypeDefIR) holds)), then

              1. (Let cid be $cid(name, constructorParameter*{constructorParameter <- constructorParameter*}))

              2. (Let typeIR_parser be ((ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR))

              3. (Let typeIR_parser_spec be ((SpecT (PolyTD typeIR_parser [] []) []) as typeIR))

              4. (Let constructorTypeIR be (ConstructorT constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} typeIR_parser_spec))

              5. (Let constructorTypeDefIR be (PolyTD constructorTypeIR [] []))

              6. If ((ConstructorTypeDef_wf: $bound((GLOBAL), TC_0) |- constructorTypeDefIR holds)), then

                1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                2. (Let parserDeclarationIR be (ParserD name [] parameterIR*{parameterIR <- parameterIR*} constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} parserLocalDeclarationIR*{parserLocalDeclarationIR <- parserLocalDeclarationIR*} parserStateIR*{parserStateIR <- parserStateIR*}))

                3. Result in TC_6, (parserDeclarationIR as declarationIR)

              6. Else Phantom#1032

            7. Else Phantom#1033

          4. Else Phantom#1034

        3. Else Phantom#1035

      2. Else Phantom#1036

    6. Case (% has type controlDeclaration)

      1. (Let (ControlD name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*} constructorParameter*{constructorParameter <- constructorParameter*} controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} controlBody) be (declaration as controlDeclaration))

      2. If ((typeParameter*{typeParameter <- typeParameter*} matches pattern [])), then

        1. (Let TC_1 be TC_0[BLOCK.KIND = (CONTROL)])

        2. (ConstructorParameters_ok: (BLOCK) TC_1 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} tid*{tid <- tid*})

        3. If ((tid*{tid <- tid*} matches pattern [])), then

          1. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}

          2. (Let TC_2 be $add_parameters((BLOCK), TC_1, constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*}))

          3. (Parameters_ok: (BLOCK) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid'*{tid' <- tid'*})

          4. If ((tid'*{tid' <- tid'*} matches pattern [])), then

            1. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

            2. (Let TC_3 be $add_parameters((BLOCK), TC_2, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            3. (ControlLocalDecls_ok: TC_3 |- controlLocalDeclaration*{controlLocalDeclaration <- controlLocalDeclaration*} : TC_4 controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*})

            4. (Let TC_5 be TC_4[LOCAL.KIND = (CONTROLAPPLYMETHOD)])

            5. (Block_ok: TC_5 (CONT) |- controlBody : _typingContext _flow controlBodyIR)

            6. (Let routineTypeIR be (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            7. If ((RoutineTypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD routineTypeIR) as routineTypeDefIR) holds)), then

              1. (Let cid be $cid(name, constructorParameter*{constructorParameter <- constructorParameter*}))

              2. (Let typeIR_control be ((ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR))

              3. (Let typeIR_control_spec be ((SpecT (PolyTD typeIR_control [] []) []) as typeIR))

              4. (Let constructorTypeIR be (ConstructorT constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} typeIR_control_spec))

              5. (Let constructorTypeDefIR be (PolyTD constructorTypeIR [] []))

              6. If ((ConstructorTypeDef_wf: $bound((GLOBAL), TC_0) |- constructorTypeDefIR holds)), then

                1. (Let TC_6 be $add_constructor(TC_0, cid, constructorTypeDefIR))

                2. (Let controlDeclarationIR be (ControlD name [] parameterIR*{parameterIR <- parameterIR*} constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} controlLocalDeclarationIR*{controlLocalDeclarationIR <- controlLocalDeclarationIR*} controlBodyIR))

                3. Result in TC_6, (controlDeclarationIR as declarationIR)

              6. Else Phantom#1037

            7. Else Phantom#1038

          4. Else Phantom#1039

        3. Else Phantom#1040

      2. Else Phantom#1041

    7. Case (% has type enumTypeDeclaration)

      1. (Let enumTypeDeclaration be (declaration as enumTypeDeclaration))

      2. Case analysis on enumTypeDeclaration

        1. Case (% matches pattern `EnumD%%`)

          1. (Let (EnumD name name_field*{name_field <- name_field*}) be enumTypeDeclaration)

          2. (Let typeIR_enum be ((EnumT name name_field*{name_field <- name_field*}) as typeIR))

          3. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_enum) as typeDefIR) holds)), then

            1. (Let TC_1 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_enum) as typeDefIR)))

            2. (Let id_field be name ++ "." ++ name_field)*{id_field <- id_field*, name_field <- name_field*}

            3. (Let value_field be ((EnumV name name_field) as value))*{name_field <- name_field*, value_field <- value_field*}

            4. (Let TC_2 be $add_vars((GLOBAL), TC_1, id_field*{id_field <- id_field*}, ((NO) typeIR_enum (LCTK) ?(value_field))*{value_field <- value_field*}))

            5. (Let enumTypeDeclarationIR be (EnumD name name_field*{name_field <- name_field*}))

            6. Result in TC_2, (enumTypeDeclarationIR as declarationIR)

          3. Else Phantom#1042

        2. Case (% matches pattern `SEnumD%%%`)

          1. (Let (SEnumD type name namedExpression_field*{namedExpression_field <- namedExpression_field*}) be enumTypeDeclaration)

          2. (Type_ok: (GLOBAL) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

          3. If ((tid*{tid <- tid*} matches pattern [])), then

            1. If ((Type_wf: $bound((GLOBAL), TC_0) |- typeIR holds)), then

              1. (Enum_serializable_fields_ok: TC_0 name typeIR |- namedExpression_field*{namedExpression_field <- namedExpression_field*} : TC_1 namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*} value_field*{value_field <- value_field*})

              2. (Let (name_field _typedExpressionIR) be namedExpressionIR_field)*{_typedExpressionIR <- _typedExpressionIR*, name_field <- name_field*, namedExpressionIR_field <- namedExpressionIR_field*}

              3. (Let id_field be name ++ "." ++ name_field)*{id_field <- id_field*, name_field <- name_field*}

              4. (Let typeIR_enum be ((SEnumT name typeIR (name_field value_field)*{name_field <- name_field*, value_field <- value_field*}) as typeIR))

              5. (Let TC_2 be $add_vars((GLOBAL), TC_0, id_field*{id_field <- id_field*}, ((NO) typeIR_enum (LCTK) ?(value_field))*{value_field <- value_field*}))

              6. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_enum) as typeDefIR) holds)), then

                1. (Let TC_3 be $add_type((GLOBAL), TC_2, name, ((MonoTD typeIR_enum) as typeDefIR)))

                2. (Let enumTypeDeclarationIR be (SEnumD typeIR name namedExpressionIR_field*{namedExpressionIR_field <- namedExpressionIR_field*}))

                3. Result in TC_3, (enumTypeDeclarationIR as declarationIR)

              6. Else Phantom#1043

            1. Else Phantom#1044

          3. Else Phantom#1045

    8. Case (% has type structTypeDeclaration)

      1. (Let (StructD name typeParameter*{typeParameter <- typeParameter*} typeField*{typeField <- typeField*}) be (declaration as structTypeDeclaration))

      2. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      3. (Let TC_1 be $add_types((BLOCK), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      4. (Let (type_field name_field) be typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}

      5. (Type_ok: (BLOCK) TC_1 |- (type_field as typeOrVoid) : typeIR_field tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}

      6. (Let tid_impl*{tid_impl <- tid_impl*} be $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**}))

      7. (Let typeIR_struct be ((StructT name (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR))

      8. (Let typeDefIR_struct be ((PolyTD typeIR_struct tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as typeDefIR))

      9. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- typeDefIR_struct holds)), then

        1. (Let TC_2 be $add_type((GLOBAL), TC_0, name, typeDefIR_struct))

        2. (Let structTypeDeclarationIR be (StructD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}))

        3. Result in TC_2, (structTypeDeclarationIR as declarationIR)

      9. Else Phantom#1046

    9. Case (% has type headerTypeDeclaration)

      1. (Let (HeaderD name typeParameter*{typeParameter <- typeParameter*} typeField*{typeField <- typeField*}) be (declaration as headerTypeDeclaration))

      2. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      3. (Let TC_1 be $add_types((BLOCK), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      4. (Let (type_field name_field) be typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}

      5. (Type_ok: (BLOCK) TC_1 |- (type_field as typeOrVoid) : typeIR_field tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}

      6. (Let tid_impl*{tid_impl <- tid_impl*} be $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**}))

      7. (Let typeIR_struct be ((HeaderT name (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR))

      8. (Let typeDefIR_struct be ((PolyTD typeIR_struct tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as typeDefIR))

      9. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- typeDefIR_struct holds)), then

        1. (Let TC_2 be $add_type((GLOBAL), TC_0, name, typeDefIR_struct))

        2. (Let headerTypeDeclarationIR be (HeaderD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}))

        3. Result in TC_2, (headerTypeDeclarationIR as declarationIR)

      9. Else Phantom#1047

    10. Case (% has type headerUnionTypeDeclaration)

      1. (Let (HeaderUnionD name typeParameter*{typeParameter <- typeParameter*} typeField*{typeField <- typeField*}) be (declaration as headerUnionTypeDeclaration))

      2. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      3. (Let TC_1 be $add_types((BLOCK), TC_0, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      4. (Let (type_field name_field) be typeField)*{name_field <- name_field*, typeField <- typeField*, type_field <- type_field*}

      5. (Type_ok: (BLOCK) TC_1 |- (type_field as typeOrVoid) : typeIR_field tid_impl_field*{tid_impl_field <- tid_impl_field*})*{tid_impl_field* <- tid_impl_field**, typeIR_field <- typeIR_field*, type_field <- type_field*}

      6. (Let tid_impl*{tid_impl <- tid_impl*} be $concat_<tid>(tid_impl_field*{tid_impl_field <- tid_impl_field*}*{tid_impl_field* <- tid_impl_field**}))

      7. (Let typeIR_struct be ((HeaderUnionT name (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}) as typeIR))

      8. (Let typeDefIR_struct be ((PolyTD typeIR_struct tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as typeDefIR))

      9. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- typeDefIR_struct holds)), then

        1. (Let TC_2 be $add_type((GLOBAL), TC_0, name, typeDefIR_struct))

        2. (Let headerUnionTypeDeclarationIR be (HeaderUnionD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} (typeIR_field name_field)*{name_field <- name_field*, typeIR_field <- typeIR_field*}))

        3. Result in TC_2, (headerUnionTypeDeclarationIR as declarationIR)

      9. Else Phantom#1048

    11. Case (% has type typedefDeclaration)

      1. (Let typedefDeclaration be (declaration as typedefDeclaration))

      2. Case analysis on typedefDeclaration

        1. Case (% matches pattern `TypeDefD%%`)

          1. (Let (TypeDefD typedefType name) be typedefDeclaration)

          2. Case analysis on typedefType

            1. Case (% matches pattern `PlainT%`)

              1. (Let (PlainT type) be typedefType)

              2. (Type_ok: (GLOBAL) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

              3. If ((tid*{tid <- tid*} matches pattern [])), then

                1. If ((Type_wf: $bound((GLOBAL), TC_0) |- typeIR holds)), then

                  1. If (~($is_extern_object_typeIR($canon(typeIR)) \/ $is_package_object_typeIR($canon(typeIR)))), then

                    1. (Let typeIR_typedef be ((DefT name typeIR) as typeIR))

                    2. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_typedef) as typeDefIR) holds)), then

                      1. (Let TC_1 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_typedef) as typeDefIR)))

                      2. (Let typedefDeclarationIR be (TypeDefD (PlainT typeIR) name))

                      3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                    2. Else Phantom#1049

                  1. Else Phantom#1050

                  2. (Let typeIR' be $canon(typeIR))

                  3. Case analysis on typeIR'

                    1. Case (% has type externObjectTypeIR)

                      1. (Let (ExternT tid_alias _map<rid, routineTypeDefIR>) be (typeIR' as externObjectTypeIR))

                      2. (Let typeIR'' be typeIR)

                      3. If ((typeIR'' has type namedTypeIR)), then

                        1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

                        2. If ((namedTypeIR matches pattern `SpecT%%`)), then

                          1. (Let (SpecT _polyTypeDefIR typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

                          2. (Let typeIR_typedef be ((DefT name typeIR) as typeIR))

                          3. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_typedef) as typeDefIR) holds)), then

                            1. (Let TC_1 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_typedef) as typeDefIR)))

                            2. (Let (cid, constructorTypeDefIR)*{cid <- cid*, constructorTypeDefIR <- constructorTypeDefIR*} be $find_constructors_non_overloaded(TC_0, (CURRENT tid_alias)))

                            3. (Let (_id pid*{pid <- pid*}) be cid)*{_id <- _id*, cid <- cid*, pid* <- pid**}

                            4. (Let cid_alias be (name pid*{pid <- pid*}))*{cid_alias <- cid_alias*, pid* <- pid**}

                            5. (Let (PolyTD (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} _typeIR) tid_expl*{tid_expl <- tid_expl*} tid'*{tid' <- tid'*}) be constructorTypeDefIR)*{_typeIR <- _typeIR*, constructorTypeDefIR <- constructorTypeDefIR*, parameterTypeIR* <- parameterTypeIR**, tid'* <- tid'**, tid_expl* <- tid_expl**}

                            6. If ((tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}, then

                              1. (Let theta be ({ (tid_expl -> typeIR_arg)*{tid_expl <- tid_expl*, typeIR_arg <- typeIR_arg*} }))*{theta <- theta*, tid_expl* <- tid_expl**}

                              2. (Let parameterTypeIR_subst be $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*, theta <- theta*}*{parameterTypeIR* <- parameterTypeIR**, parameterTypeIR_subst* <- parameterTypeIR_subst**}

                              3. (Let constructorTypeDefIR_alias be (PolyTD (ConstructorT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR) [] []))*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*, parameterTypeIR_subst* <- parameterTypeIR_subst**}

                              4. (Let TC_2 be $add_constructors(TC_1, cid_alias*{cid_alias <- cid_alias*}, constructorTypeDefIR_alias*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*}))

                              5. (Let typedefDeclarationIR be (TypeDefD (PlainT typeIR) name))

                              6. Result in TC_2, (typedefDeclarationIR as declarationIR)

                            6. Else Phantom#1051

                          3. Else Phantom#1052

                        2. Else Phantom#1053

                      3. Else Phantom#1054

                    2. Case (% has type packageObjectTypeIR)

                      1. (Let (PackageT tid_alias _typeIR*{_typeIR <- _typeIR*}) be (typeIR' as packageObjectTypeIR))

                      2. (Let typeIR'' be typeIR)

                      3. If ((typeIR'' has type namedTypeIR)), then

                        1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

                        2. If ((namedTypeIR matches pattern `SpecT%%`)), then

                          1. (Let (SpecT _polyTypeDefIR typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR)

                          2. (Let typeIR_typedef be ((DefT name typeIR) as typeIR))

                          3. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_typedef) as typeDefIR) holds)), then

                            1. (Let TC_1 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_typedef) as typeDefIR)))

                            2. (Let (cid, constructorTypeDefIR)*{cid <- cid*, constructorTypeDefIR <- constructorTypeDefIR*} be $find_constructors_non_overloaded(TC_0, (CURRENT tid_alias)))

                            3. (Let (_id pid*{pid <- pid*}) be cid)*{_id <- _id*, cid <- cid*, pid* <- pid**}

                            4. (Let cid_alias be (name pid*{pid <- pid*}))*{cid_alias <- cid_alias*, pid* <- pid**}

                            5. (Let (PolyTD (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} _typeIR') tid_expl*{tid_expl <- tid_expl*} tid'*{tid' <- tid'*}) be constructorTypeDefIR)*{_typeIR' <- _typeIR'*, constructorTypeDefIR <- constructorTypeDefIR*, parameterTypeIR* <- parameterTypeIR**, tid'* <- tid'**, tid_expl* <- tid_expl**}

                            6. If ((tid'*{tid' <- tid'*} matches pattern []))*{tid'* <- tid'**}, then

                              1. (Let theta be ({ (tid_expl -> typeIR_arg)*{tid_expl <- tid_expl*, typeIR_arg <- typeIR_arg*} }))*{theta <- theta*, tid_expl* <- tid_expl**}

                              2. (Let parameterTypeIR_subst be $subst_parameterType(theta, parameterTypeIR))*{parameterTypeIR <- parameterTypeIR*, parameterTypeIR_subst <- parameterTypeIR_subst*, theta <- theta*}*{parameterTypeIR* <- parameterTypeIR**, parameterTypeIR_subst* <- parameterTypeIR_subst**}

                              3. (Let constructorTypeDefIR_alias be (PolyTD (ConstructorT parameterTypeIR_subst*{parameterTypeIR_subst <- parameterTypeIR_subst*} typeIR) [] []))*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*, parameterTypeIR_subst* <- parameterTypeIR_subst**}

                              4. (Let TC_2 be $add_constructors(TC_1, cid_alias*{cid_alias <- cid_alias*}, constructorTypeDefIR_alias*{constructorTypeDefIR_alias <- constructorTypeDefIR_alias*}))

                              5. (Let typedefDeclarationIR be (TypeDefD (PlainT typeIR) name))

                              6. Result in TC_2, (typedefDeclarationIR as declarationIR)

                            6. Else Phantom#1055

                          3. Else Phantom#1056

                        2. Else Phantom#1057

                      3. Else Phantom#1058

                  3. Else Phantom#1059

                1. Else Phantom#1060

              3. Else Phantom#1061

            2. Case (% matches pattern `DerivedT%`)

              1. (Let (DerivedT derivedTypeDeclaration) be typedefType)

              2. (Decl_ok: (GLOBAL) TC_0 |- (derivedTypeDeclaration as declaration) : TC_1 declarationIR)

              3. If ((declarationIR has type derivedTypeDeclarationIR)), then

                1. (Let derivedTypeDeclarationIR be (declarationIR as derivedTypeDeclarationIR))

                2. (Let ({ tid'*{tid' <- tid'*} }) be $diff_set<tid>($dom_map<tid, typeDefIR>(TC_1.GLOBAL.TDENV), $dom_map<tid, typeDefIR>(TC_0.GLOBAL.TDENV)))

                3. If ((tid'*{tid' <- tid'*} matches pattern [ _/1 ])), then

                  1. (Let [tid] be tid'*{tid' <- tid'*})

                  2. (Let typeDefIR'?{typeDefIR' <- typeDefIR'?} be $find_type((GLOBAL), TC_1, (CURRENT tid)))

                  3. If ((typeDefIR'?{typeDefIR' <- typeDefIR'?} matches pattern (_))), then

                    1. (Let ?(typeDefIR) be typeDefIR'?{typeDefIR' <- typeDefIR'?})

                    2. Case analysis on typeDefIR

                      1. Case (% has type monoTypeDefIR)

                        1. (Let (MonoTD typeIR) be (typeDefIR as monoTypeDefIR))

                        2. (Let typeIR_typedef be ((DefT name typeIR) as typeIR))

                        3. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_typedef) as typeDefIR) holds)), then

                          1. (Let TC_2 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_typedef) as typeDefIR)))

                          2. (Let typedefDeclarationIR be (TypeDefD (DerivedT derivedTypeDeclarationIR) name))

                          3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                        3. Else Phantom#1062

                      2. Case (% has type polyTypeDefIR)

                        1. (Let (PolyTD typeIR tid''*{tid'' <- tid''*} tid'''*{tid''' <- tid'''*}) be (typeDefIR as polyTypeDefIR))

                        2. If ((tid''*{tid'' <- tid''*} matches pattern [])), then

                          1. If ((tid'''*{tid''' <- tid'''*} matches pattern [])), then

                            1. (Let typeIR_typedef be ((DefT name ((SpecT (PolyTD typeIR [] []) []) as typeIR)) as typeIR))

                            2. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_typedef) as typeDefIR) holds)), then

                              1. (Let TC_2 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_typedef) as typeDefIR)))

                              2. (Let typedefDeclarationIR be (TypeDefD (DerivedT derivedTypeDeclarationIR) name))

                              3. Result in TC_1, (typedefDeclarationIR as declarationIR)

                            2. Else Phantom#1063

                          1. Else Phantom#1064

                        2. Else Phantom#1065

                  3. Else Phantom#1066

                3. Else Phantom#1067

              3. Else Phantom#1068

        2. Case (% matches pattern `NewTypeD%%`)

          1. (Let (NewTypeD type name) be typedefDeclaration)

          2. (Type_ok: (GLOBAL) TC_0 |- (type as typeOrVoid) : typeIR tid*{tid <- tid*})

          3. If ((tid*{tid <- tid*} matches pattern [])), then

            1. If ((Type_wf: $bound((GLOBAL), TC_0) |- typeIR holds)), then

              1. (Let typeIR_newtype be ((NewT name typeIR) as typeIR))

              2. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- ((MonoTD typeIR_newtype) as typeDefIR) holds)), then

                1. (Let TC_1 be $add_type((GLOBAL), TC_0, name, ((MonoTD typeIR_newtype) as typeDefIR)))

                2. (Let typedefDeclarationIR be (NewTypeD typeIR name))

                3. Result in TC_1, (typedefDeclarationIR as declarationIR)

              2. Else Phantom#1069

            1. Else Phantom#1070

          3. Else Phantom#1071

    12. Case (% has type parserTypeDeclaration)

      1. (Let (ParserTypeD name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*}) be (declaration as parserTypeDeclaration))

      2. (Let TC_1 be TC_0[BLOCK.KIND = (PARSER)])

      3. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      4. (Let TC_2 be $add_types((BLOCK), TC_1, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      5. (Parameters_ok: (BLOCK) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

      6. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

      7. (Let typeIR_parser be ((ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR))

      8. (Let typeDefIR_parser be ((PolyTD typeIR_parser tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as typeDefIR))

      9. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- typeDefIR_parser holds)), then

        1. (Let TC_3 be $add_type((GLOBAL), TC_0, name, typeDefIR_parser))

        2. (Let parserTypeDeclarationIR be (ParserTypeD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*}))

        3. Result in TC_3, (parserTypeDeclarationIR as declarationIR)

      9. Else Phantom#1072

    13. Case (% has type controlTypeDeclaration)

      1. (Let (ControlTypeD name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*}) be (declaration as controlTypeDeclaration))

      2. (Let TC_1 be TC_0[BLOCK.KIND = (CONTROL)])

      3. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      4. (Let TC_2 be $add_types((BLOCK), TC_1, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      5. (Parameters_ok: (BLOCK) TC_2 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

      6. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

      7. (Let typeIR_control be ((ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) as typeIR))

      8. (Let typeDefIR_control be ((PolyTD typeIR_control tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as typeDefIR))

      9. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- typeDefIR_control holds)), then

        1. (Let TC_3 be $add_type((GLOBAL), TC_0, name, typeDefIR_control))

        2. (Let controlTypeDeclarationIR be (ControlTypeD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*}))

        3. Result in TC_3, (controlTypeDeclarationIR as declarationIR)

      9. Else Phantom#1073

    14. Case (% has type packageTypeDeclaration)

      1. (Let (PackageTypeD name typeParameter*{typeParameter <- typeParameter*} constructorParameter*{constructorParameter <- constructorParameter*}) be (declaration as packageTypeDeclaration))

      2. (Let TC_1 be TC_0[BLOCK.KIND = (PACKAGE)])

      3. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

      4. (Let TC_2 be $add_types((BLOCK), TC_1, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

      5. (ConstructorParameters_ok: (BLOCK) TC_2 |- constructorParameter*{constructorParameter <- constructorParameter*} : constructorParameterIR*{constructorParameterIR <- constructorParameterIR*} tid_impl*{tid_impl <- tid_impl*})

      6. (Let constructorParameterTypeIR be $constructorParameterIR(constructorParameterIR))*{constructorParameterIR <- constructorParameterIR*, constructorParameterTypeIR <- constructorParameterTypeIR*}

      7. (Let (_direction typeIR_package_inner _id _value?{_value <- _value?}) be constructorParameterTypeIR)*{_direction <- _direction*, _id <- _id*, _value? <- _value?*, constructorParameterTypeIR <- constructorParameterTypeIR*, typeIR_package_inner <- typeIR_package_inner*}

      8. (Let typeIR_package be ((PackageT name typeIR_package_inner*{typeIR_package_inner <- typeIR_package_inner*}) as typeIR))

      9. (Let polyTypeDefIR_package be (PolyTD typeIR_package tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}))

      10. If ((TypeDef_wf: $bound((GLOBAL), TC_0) |- (polyTypeDefIR_package as typeDefIR) holds)), then

        1. (Let TC_3 be $add_type((GLOBAL), TC_0, name, (polyTypeDefIR_package as typeDefIR)))

        2. (Let cid be $cid(name, constructorParameter*{constructorParameter <- constructorParameter*}))

        3. (Let typeIR_package_spec be ((SpecT polyTypeDefIR_package ((NameT tid_expl) as typeIR)*{tid_expl <- tid_expl*} ++ ((NameT tid_impl) as typeIR)*{tid_impl <- tid_impl*}) as typeIR))

        4. (Let constructorTypeIR be (ConstructorT constructorParameterTypeIR*{constructorParameterTypeIR <- constructorParameterTypeIR*} typeIR_package_spec))

        5. (Let constructorTypeDefIR be (PolyTD constructorTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}))

        6. If ((ConstructorTypeDef_wf: $bound((GLOBAL), TC_0) |- constructorTypeDefIR holds)), then

          1. (Let TC_4 be $add_constructor(TC_3, cid, constructorTypeDefIR))

          2. (Let packageTypeDeclarationIR be (PackageTypeD name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} constructorParameterIR*{constructorParameterIR <- constructorParameterIR*}))

          3. Result in TC_4, (packageTypeDeclarationIR as declarationIR)

        6. Else Phantom#1074

      10. Else Phantom#1075

  1. Else Phantom#1076

2. Else Phantom#1077

;; ../../../../spec-concrete/5.04-typing-relation.watsup:266.1-268.23
relation Decls_ok: p, TC', declaration*{declaration <- declaration*}

1. Case analysis on declaration*{declaration <- declaration*}

  1. Case (% matches pattern [])

    1. Result in TC', []

  2. Case (% matches pattern _ :: _)

    1. (Let declaration_h :: declaration_t*{declaration_t <- declaration_t*} be declaration*{declaration <- declaration*})

    2. (Decl_ok: p TC' |- declaration_h : TC_1 declarationIR_h)

    3. (Decls_ok: p TC_1 |- declaration_t*{declaration_t <- declaration_t*} : TC_2 declarationIR_t*{declarationIR_t <- declarationIR_t*})

    4. Result in TC_2, declarationIR_h :: declarationIR_t*{declarationIR_t <- declarationIR_t*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:270.1-272.17
relation Program_ok: declaration*{declaration <- declaration*}

1. (Let TC_0 be $empty_typingContext)

2. (Decls_ok: (GLOBAL) TC_0 |- declaration*{declaration <- declaration*} : TC_1 declarationIR*{declarationIR <- declarationIR*})

3. Result in TC_1, declarationIR*{declarationIR <- declarationIR*}

;; ../../../../spec-concrete/5.04-typing-relation.watsup:282.18-282.35
syntax actctxt = 
   | `ACTION`()
   | `NOACTION`()

;; ../../../../spec-concrete/5.04-typing-relation.watsup:284.1-287.29
relation Call_convention_expr_ok: p, TC, actctxt, (direction typeIR_param _id _value?{_value <- _value?}), typedExpressionIR_arg

1. Case analysis on direction

  1. Case (% matches pattern `IN`)

    1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_arg, typeIR_param))

    2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

      1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

      2. Result in typedExpressionIR_arg_cast

    2. Else Phantom#1078

  2. Case (% matches pattern `OUT`)

    1. (Let (_expressionIR (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

    2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

      1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

        1. Result in typedExpressionIR_arg

      1. Else Phantom#1079

    2. Else Phantom#1080

  3. Case (% matches pattern `INOUT`)

    1. (Let (_expressionIR (( typeIR_arg _ctk ))) be typedExpressionIR_arg)

    2. If ((Type_alpha: typeIR_param ~~ typeIR_arg holds)), then

      1. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_arg holds)), then

        1. Result in typedExpressionIR_arg

      1. Else Phantom#1081

    2. Else Phantom#1082

1. Else Phantom#1083

2. Case analysis on actctxt

  1. Case (% matches pattern `ACTION`)

    1. If ((direction matches pattern `NO`)), then

      1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_arg, typeIR_param))

      2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

        1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

        2. Result in typedExpressionIR_arg_cast

      2. Else Phantom#1084

    1. Else Phantom#1085

  2. Case (% matches pattern `NOACTION`)

    1. If ((direction matches pattern `NO`)), then

      1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_arg, typeIR_param))

      2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

        1. (Let ?(typedExpressionIR_arg_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

        2. (Let (_expressionIR (( _typeIR ctk_arg_cast ))) be typedExpressionIR_arg_cast)

        3. If (~(ctk_arg_cast matches pattern `DYN`)), then

          1. Result in typedExpressionIR_arg_cast

        3. Else Phantom#1086

      2. Else Phantom#1087

    1. Else Phantom#1088

;; ../../../../spec-concrete/5.04-typing-relation.watsup:289.1-292.29
relation Call_convention_argument_ok: p, TC, actctxt, parameterTypeIR, argumentIR

1. Case analysis on argumentIR

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA typedExpressionIR) be argumentIR)

    2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR typedExpressionIR : typedExpressionIR_cast)

    3. Result in (ExprA typedExpressionIR_cast)

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA name typedExpressionIR) be argumentIR)

    2. (Call_convention_expr_ok: p TC actctxt |- parameterTypeIR typedExpressionIR : typedExpressionIR_cast)

    3. Result in (NameA name typedExpressionIR_cast)

  3. Case (% matches pattern `NameAnyA%`)

    1. (Let (NameAnyA name) be argumentIR)

    2. (Let (direction _typeIR _id _value?{_value <- _value?}) be parameterTypeIR)

    3. If ((direction matches pattern `OUT`)), then

      1. Result in (NameAnyA name)

    3. Else Phantom#1089

  4. Case (% matches pattern `AnyA`)

    1. (Let (direction _typeIR _id _value?{_value <- _value?}) be parameterTypeIR)

    2. If ((direction matches pattern `OUT`)), then

      1. Result in (AnyA)

    2. Else Phantom#1090

;; ../../../../spec-concrete/5.04-typing-relation.watsup:294.1-297.29
relation Call_convention_ok: p, TC, actctxt, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*}

1. Case analysis on parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

  1. Case (% matches pattern [])

    1. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern [])), then

      1. Result in []

    1. Else Phantom#1091

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} be parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

    2. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern _ :: _)), then

      1. (Let argumentIR_h :: argumentIR_t*{argumentIR_t <- argumentIR_t*} be argumentIR*{argumentIR <- argumentIR*})

      2. (Call_convention_argument_ok: p TC actctxt |- parameterTypeIR_h argumentIR_h : argumentIR_h_cast)

      3. (Call_convention_ok: p TC actctxt |- parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} argumentIR_t*{argumentIR_t <- argumentIR_t*} : argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*})

      4. Result in argumentIR_h_cast :: argumentIR_t_cast*{argumentIR_t_cast <- argumentIR_t_cast*}

    2. Else Phantom#1092

;; ../../../../spec-concrete/5.04-typing-relation.watsup:307.1-309.23
relation RoutineTarget_ok: p, TC, routineTarget

1. Case analysis on routineTarget

  1. Case (% has type referenceExpression)

    1. (Let (NameE prefixedName) be (routineTarget as referenceExpression))

    2. If ((((prefixedName = (CURRENT "verify")) \/ (prefixedName = (TOP "verify"))) => (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND)) \/ ((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))))), then

      1. Result in (FuncT prefixedName)

    2. Else Phantom#1093

  2. Case (% has type memberAccessExpression)

    1. (Let memberAccessExpression be (routineTarget as memberAccessExpression))

    2. Case analysis on memberAccessExpression

      1. Case (% matches pattern `TypeAccE%%`)

        1. (Let (TypeAccE prefixedName name) be memberAccessExpression)

        2. Result in (TypeT prefixedName name)

      2. Case (% matches pattern `ExprAccE%%`)

        1. (Let (ExprAccE expression_base name) be memberAccessExpression)

        2. (Expr_ok: p TC |- expression_base : typedExpressionIR_base)

        3. Result in (MethodT typedExpressionIR_base name)

1. Else Phantom#1094

;; ../../../../spec-concrete/5.04-typing-relation.watsup:311.1-313.23
relation RoutineTarget_lvalue_ok: p, TC, lvalue

1. (Let expression be $lvalue_as_expression(lvalue))

2. (RoutineTarget_ok: p TC |- expression : routineTargetIR)

3. Result in routineTargetIR

;; ../../../../spec-concrete/5.04-typing-relation.watsup:315.1-318.29
relation RoutineType_ok: p, TC, routineTargetIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR''*{argumentIR'' <- argumentIR''*}

1. Case analysis on routineTargetIR

  1. Case (% matches pattern `FuncT%`)

    1. (Let (FuncT prefixedName) be routineTargetIR)

    2. (Let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} be $find_routine_overloaded(p, TC, prefixedName, argumentIR''*{argumentIR'' <- argumentIR''*}))

    3. If (((rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches pattern (_))), then

      1. (Let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) be (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?})

      2. (Let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}))

      3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl*{tid_impl <- tid_impl*} })))

      4. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

        1. Result in routineTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*}

      4. Else Phantom#1095

    3. Else Phantom#1096

  2. Case (% matches pattern `MethodT%%`)

    1. (Let (MethodT typedExpressionIR_base name) be routineTargetIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. Case analysis on argumentIR''*{argumentIR'' <- argumentIR''*}

        1. Case (% matches pattern [])

          1. Case analysis on name

            1. Case (% is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"])

              1. (Let routineTypeIR be (BuiltinMethodT [] ((IntT) as typeIR)))

              2. Result in routineTypeIR, [], []

            2. Case (% is in ["isValid"])

              1. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              2. (Let typeIR be $canon(typeIR_base))

              3. Case analysis on typeIR

                1. Case (% has type headerTypeIR)

                  1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerTypeIR))

                  2. (Let routineTypeIR be (BuiltinMethodT [] ((BoolT) as typeIR)))

                  3. Result in routineTypeIR, [], []

                2. Case (% has type headerUnionTypeIR)

                  1. (Let (HeaderUnionT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerUnionTypeIR))

                  2. (Let routineTypeIR be (BuiltinMethodT [] ((BoolT) as typeIR)))

                  3. Result in routineTypeIR, [], []

              3. Else Phantom#1097

            3. Case (% is in ["setValid", "setInvalid"])

              1. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

              2. (Let typeIR be $canon(typeIR_base))

              3. If ((typeIR has type headerTypeIR)), then

                1. (Let (HeaderT _tid _fieldTypeIR*{_fieldTypeIR <- _fieldTypeIR*}) be (typeIR as headerTypeIR))

                2. (Let routineTypeIR be (BuiltinMethodT [] ((VoidT) as typeIR)))

                3. Result in routineTypeIR, [], []

              3. Else Phantom#1098

          1. Else Phantom#1099

        2. Case (% matches pattern [ _/1 ])

          1. (Let [argumentIR] be argumentIR''*{argumentIR'' <- argumentIR''*})

          2. If (name is in ["push_front", "pop_front"]), then

            1. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

            2. (Let typeIR' be $canon(typeIR_base))

            3. If ((typeIR' has type headerStackTypeIR)), then

              1. (Let (HeaderStackT typeIR _nat) be (typeIR' as headerStackTypeIR))

              2. (Let parameterTypeIR be ((NO) ((IntT) as typeIR) "count" ?()))

              3. (Let routineTypeIR be (BuiltinMethodT [parameterTypeIR] ((IntT) as typeIR)))

              4. Result in routineTypeIR, [], []

            3. Else Phantom#1100

          2. Else Phantom#1101

      1. Else Phantom#1102

    2. Else Phantom#1103

    3. (Let (_expressionIR (( typeIR_base _ctk ))) be typedExpressionIR_base)

    4. (Let typeIR be $canon(typeIR_base))

    5. If ((typeIR has type externObjectTypeIR)), then

      1. (Let (ExternT _tid ({ (rid_f -> routineTypeDefIR_f)*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} })) be (typeIR as externObjectTypeIR))

      2. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR''*{argumentIR'' <- argumentIR''*}))

      3. (Let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} be $find_overloaded<routineTypeDefIR>(({ (rid_f -> routineTypeDefIR_f)*{rid_f <- rid_f*, routineTypeDefIR_f <- routineTypeDefIR_f*} }), name, id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

      4. If (((rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches pattern (_))), then

        1. (Let ?((rid, routineTypeDefIR, id_default*{id_default <- id_default*})) be (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?})

        2. (Let (routineTypeIR, tid_impl*{tid_impl <- tid_impl*}) be $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}))

        3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl*{tid_impl <- tid_impl*} })))

        4. If ((RoutineType_wf: bound |- routineTypeIR holds)), then

          1. Result in routineTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*}

        4. Else Phantom#1104

      4. Else Phantom#1105

    5. Else Phantom#1106

    6. If ((name = "apply")), then

      1. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

        1. Case analysis on typeIR

          1. Case (% has type parserObjectTypeIR)

            1. (Let (ParserT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR as parserObjectTypeIR))

            2. (Let routineTypeIR be (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            3. (Let (_direction _typeIR id_param value_param?{value_param <- value_param?}) be parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}

            4. (Let pid be (id_param (value_param?{value_param <- value_param?} =/= ?())))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}

            5. (Let rid be ("apply" pid*{pid <- pid*}))

            6. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR''*{argumentIR'' <- argumentIR''*}))

            7. (Let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} be $find_overloaded<routineTypeDefIR>(({ [(rid -> ((MonoTD routineTypeIR) as routineTypeDefIR))] }), "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

            8. If (((rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches pattern (_))), then

              1. (Let ?((rid', routineTypeDefIR, id_default*{id_default <- id_default*})) be (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?})

              2. If ((rid' = rid)), then

                1. If ((routineTypeDefIR = ((MonoTD routineTypeIR) as routineTypeDefIR))), then

                  1. Result in routineTypeIR, [], id_default*{id_default <- id_default*}

                1. Else Phantom#1107

              2. Else Phantom#1108

            8. Else Phantom#1109

          2. Case (% has type controlObjectTypeIR)

            1. (Let (ControlT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be (typeIR as controlObjectTypeIR))

            2. (Let routineTypeIR be (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

            3. (Let (_direction _typeIR id_param value_param?{value_param <- value_param?}) be parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, id_param <- id_param*, parameterTypeIR <- parameterTypeIR*, value_param? <- value_param?*}

            4. (Let pid be (id_param (value_param?{value_param <- value_param?} =/= ?())))*{id_param <- id_param*, pid <- pid*, value_param? <- value_param?*}

            5. (Let rid be ("apply" pid*{pid <- pid*}))

            6. (Let id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*} be $ids_arguments(argumentIR''*{argumentIR'' <- argumentIR''*}))

            7. (Let (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} be $find_overloaded<routineTypeDefIR>(({ [(rid -> ((MonoTD routineTypeIR) as routineTypeDefIR))] }), "apply", id_arg?{id_arg <- id_arg?}*{id_arg? <- id_arg?*}))

            8. If (((rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?} matches pattern (_))), then

              1. (Let ?((rid', routineTypeDefIR, id_default*{id_default <- id_default*})) be (rid, routineTypeDefIR, id*)?{(rid, routineTypeDefIR, id*) <- (rid, routineTypeDefIR, id*)?})

              2. If ((rid' = rid)), then

                1. If ((routineTypeDefIR = ((MonoTD routineTypeIR) as routineTypeDefIR))), then

                  1. Result in routineTypeIR, [], id_default*{id_default <- id_default*}

                1. Else Phantom#1110

              2. Else Phantom#1111

            8. Else Phantom#1112

        1. Else Phantom#1113

        2. If ((argumentIR''*{argumentIR'' <- argumentIR''*} matches pattern [])), then

          1. If ((typeIR has type tableObjectTypeIR)), then

            1. (Let (TableT _tid typeIR_table) be (typeIR as tableObjectTypeIR))

            2. (Let routineTypeIR be (TableApplyMethodT typeIR_table))

            3. Result in routineTypeIR, [], []

          1. Else Phantom#1114

        2. Else Phantom#1115

      1. Else Phantom#1116

    6. Else Phantom#1117

  3. Case (% matches pattern `TypeT%%`)

    1. (Let (TypeT prefixedName name) be routineTargetIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. If ((argumentIR''*{argumentIR'' <- argumentIR''*} matches pattern [])), then

        1. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

          1. (Let routineTypeIR be (BuiltinMethodT [] ((IntT) as typeIR)))

          2. Result in routineTypeIR, [], []

        1. Else Phantom#1118

      1. Else Phantom#1119

    2. Else Phantom#1120

;; ../../../../spec-concrete/5.04-typing-relation.watsup:325.1-329.35
relation Call_ok: p, TC, routineTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid'*{tid' <- tid'*}, argumentIR*{argumentIR <- argumentIR*}, id_default'*{id_default' <- id_default'*}

1. Case analysis on routineTypeIR

  1. Case (% matches pattern `BuiltinFuncT%%`)

    1. (Let (BuiltinFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((tid'*{tid' <- tid'*} matches pattern [])), then

      1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

      2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

        1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

        2. If ($callable_builtin_function(p, TC)), then

          1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

          2. Result in typeIR_ret, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

        2. Else Phantom#1121

      2. Else Phantom#1122

    2. Else Phantom#1123

  2. Case (% matches pattern `FuncT%%`)

    1. (Let (FuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

    3. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

      1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

      2. (Let inference'?{inference' <- inference'?} be $infer(tid'*{tid' <- tid'*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

      3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

        1. (Let ?(inference) be inference'?{inference' <- inference'?})

        2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid'))*{tid' <- tid'*, typeIR? <- typeIR?*}

        3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

          1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

          2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

          4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

          5. (Let routineTypeIR_inferred be (FuncT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_ret_inferred))

          6. If ((RoutineType_wf: $bound(p, TC) |- routineTypeIR_inferred holds)), then

            1. If ($callable_function(p, TC)), then

              1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

              2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

            1. Else Phantom#1124

          6. Else Phantom#1125

        3. Else Phantom#1126

      3. Else Phantom#1127

    3. Else Phantom#1128

  3. Case (% matches pattern `ExternFuncT%%`)

    1. (Let (ExternFuncT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

    3. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

      1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

      2. (Let inference'?{inference' <- inference'?} be $infer(tid'*{tid' <- tid'*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

      3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

        1. (Let ?(inference) be inference'?{inference' <- inference'?})

        2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid'))*{tid' <- tid'*, typeIR? <- typeIR?*}

        3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

          1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

          2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

          4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

          5. (Let routineTypeIR_inferred be (ExternFuncT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_ret_inferred))

          6. If ((RoutineType_wf: $bound(p, TC) |- routineTypeIR_inferred holds)), then

            1. If ($callable_extern_function(p, TC)), then

              1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

              2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

            1. Else Phantom#1129

          6. Else Phantom#1130

        3. Else Phantom#1131

      3. Else Phantom#1132

    3. Else Phantom#1133

  4. Case (% matches pattern `ActionT%`)

    1. (Let (ActionT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. If ((tid'*{tid' <- tid'*} matches pattern [])), then

        1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

        2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

          1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

          2. If ($callable_action(p, TC)), then

            1. (Call_convention_ok: p TC (ACTION) |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            2. Result in ((VoidT) as typeIR), [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

          2. Else Phantom#1134

        2. Else Phantom#1135

      1. Else Phantom#1136

    2. Else Phantom#1137

  5. Case (% matches pattern `BuiltinMethodT%%`)

    1. (Let (BuiltinMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. If ((tid'*{tid' <- tid'*} matches pattern [])), then

      1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

      2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

        1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

        2. If ($callable_builtin_method(p, TC)), then

          1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

          2. Result in typeIR_ret, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

        2. Else Phantom#1138

      2. Else Phantom#1139

    2. Else Phantom#1140

  6. Case (% matches pattern `ExternMethodT%%`)

    1. (Let (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

    3. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

      1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

      2. (Let inference'?{inference' <- inference'?} be $infer(tid'*{tid' <- tid'*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

      3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

        1. (Let ?(inference) be inference'?{inference' <- inference'?})

        2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid'))*{tid' <- tid'*, typeIR? <- typeIR?*}

        3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

          1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

          2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

          4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

          5. (Let routineTypeIR_inferred be (ExternMethodT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_ret_inferred))

          6. If ((RoutineType_wf: $bound(p, TC) |- routineTypeIR_inferred holds)), then

            1. If ($callable_extern_method(p, TC)), then

              1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

              2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

            1. Else Phantom#1141

          6. Else Phantom#1142

        3. Else Phantom#1143

      3. Else Phantom#1144

    3. Else Phantom#1145

  7. Case (% matches pattern `ExternAbstractMethodT%%`)

    1. (Let (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

    2. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

    3. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

      1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

      2. (Let inference'?{inference' <- inference'?} be $infer(tid'*{tid' <- tid'*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

      3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

        1. (Let ?(inference) be inference'?{inference' <- inference'?})

        2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid'))*{tid' <- tid'*, typeIR? <- typeIR?*}

        3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

          1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

          2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

          4. (Let typeIR_ret_inferred be $subst_type(inference, typeIR_ret))

          5. (Let routineTypeIR_inferred be (ExternAbstractMethodT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_ret_inferred))

          6. If ((RoutineType_wf: $bound(p, TC) |- routineTypeIR_inferred holds)), then

            1. If ($callable_extern_abstract_method(p, TC)), then

              1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

              2. Result in typeIR_ret_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

            1. Else Phantom#1146

          6. Else Phantom#1147

        3. Else Phantom#1148

      3. Else Phantom#1149

    3. Else Phantom#1150

  8. Case (% matches pattern `ParserApplyMethodT%`)

    1. (Let (ParserApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. If ((tid'*{tid' <- tid'*} matches pattern [])), then

        1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

        2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

          1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

          2. If ($callable_parser_apply_method(p, TC)), then

            1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            2. Result in ((VoidT) as typeIR), [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

          2. Else Phantom#1151

        2. Else Phantom#1152

      1. Else Phantom#1153

    2. Else Phantom#1154

  9. Case (% matches pattern `ControlApplyMethodT%`)

    1. (Let (ControlApplyMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}) be routineTypeIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. If ((tid'*{tid' <- tid'*} matches pattern [])), then

        1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default'*{id_default' <- id_default'*}))

        2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

          1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

          2. If ($callable_control_apply_method(p, TC)), then

            1. (Call_convention_ok: p TC (NOACTION) |- parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            2. Result in ((VoidT) as typeIR), [], argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

          2. Else Phantom#1155

        2. Else Phantom#1156

      1. Else Phantom#1157

    2. Else Phantom#1158

  10. Case (% matches pattern `TableApplyMethodT%`)

    1. (Let (TableApplyMethodT typeIR_table) be routineTypeIR)

    2. If ((typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} matches pattern [])), then

      1. If ((tid'*{tid' <- tid'*} matches pattern [])), then

        1. If ((argumentIR*{argumentIR <- argumentIR*} matches pattern [])), then

          1. If ((id_default'*{id_default' <- id_default'*} matches pattern [])), then

            1. If ($callable_table_apply_method(p, TC)), then

              1. Result in typeIR_table, [], []

            1. Else Phantom#1159

          1. Else Phantom#1160

        1. Else Phantom#1161

      1. Else Phantom#1162

    2. Else Phantom#1163

;; ../../../../spec-concrete/5.04-typing-relation.watsup:339.1-342.29
relation ConstructorType_ok: p, TC, prefixedName, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, argumentIR*{argumentIR <- argumentIR*}

1. (Let (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} be $find_constructor_overloaded(TC, prefixedName, argumentIR*{argumentIR <- argumentIR*}))

2. If (((rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?} matches pattern (_))), then

  1. (Let ?((cid, constructorTypeDefIR, id_default*{id_default <- id_default*})) be (rid, constructorTypeDefIR, id*)?{(rid, constructorTypeDefIR, id*) <- (rid, constructorTypeDefIR, id*)?})

  2. (Let (constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}) be $specialize_constructorTypeDef(constructorTypeDefIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}))

  3. (Let bound be $union_set<tid>($bound(p, TC), ({ tid_impl*{tid_impl <- tid_impl*} })))

  4. If ((ConstructorType_wf: bound |- constructorTypeIR holds)), then

    1. Result in constructorTypeIR, tid_impl*{tid_impl <- tid_impl*}, id_default*{id_default <- id_default*}

  4. Else Phantom#1164

2. Else Phantom#1165

;; ../../../../spec-concrete/5.04-typing-relation.watsup:349.19-349.31
syntax instctxt = 
   | `NAMED`()
   | `ANON`()

;; ../../../../spec-concrete/5.04-typing-relation.watsup:351.1-354.38
relation Inst_ok: cursor', TC, instctxt, constructorTypeIR, typeArgumentIR*{typeArgumentIR <- typeArgumentIR*}, tid_infer*{tid_infer <- tid_infer*}, argumentIR*{argumentIR <- argumentIR*}, id_default*{id_default <- id_default*}

1. If ((cursor' matches pattern `GLOBAL`)), then

  1. (Let (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_object) be constructorTypeIR)

  2. If ($is_package_object_typeIR($canon(typeIR_object))), then

    1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}))

    2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

      1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

      2. (Let inference'?{inference' <- inference'?} be $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

      3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

        1. (Let ?(inference) be inference'?{inference' <- inference'?})

        2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}

        3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

          1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

          2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

          3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

          4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

          5. (Let constructorTypeIR_inferred be (ConstructorT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_object_inferred))

          6. If ((ConstructorType_wf: $bound((GLOBAL), TC) |- constructorTypeIR_inferred holds)), then

            1. If ($instantiable((GLOBAL), TC, instctxt, typeIR_object_inferred)), then

              1. (Call_convention_ok: (BLOCK) TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

              2. Result in typeIR_object_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

            1. Else Phantom#1166

          6. Else Phantom#1167

        3. Else Phantom#1168

      3. Else Phantom#1169

    2. Else Phantom#1170

  2. Else Phantom#1171

1. Else Phantom#1172

2. (Let (ConstructorT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_object) be constructorTypeIR)

3. If (~$is_package_object_typeIR($canon(typeIR_object))), then

  1. (Let parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*} be $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*}))

  2. If ((|parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

    1. (Let parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*} be $align_parameters(parameterTypeIR_non_default*{parameterTypeIR_non_default <- parameterTypeIR_non_default*}, argumentIR*{argumentIR <- argumentIR*}))

    2. (Let inference'?{inference' <- inference'?} be $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}, argumentIR*{argumentIR <- argumentIR*}))

    3. If ((inference'?{inference' <- inference'?} matches pattern (_))), then

      1. (Let ?(inference) be inference'?{inference' <- inference'?})

      2. (Let typeIR?{typeIR <- typeIR?} be $find_map<tid, typeIR>(inference, tid_infer))*{tid_infer <- tid_infer*, typeIR? <- typeIR?*}

      3. If ((typeIR?{typeIR <- typeIR?} matches pattern (_)))*{typeIR? <- typeIR?*}, then

        1. (Let ?(typeIR_inferred) be typeIR?{typeIR <- typeIR?})*{typeIR? <- typeIR?*, typeIR_inferred <- typeIR_inferred*}

        2. (Let typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*} be typeArgumentIR*{typeArgumentIR <- typeArgumentIR*} ++ typeIR_inferred*{typeIR_inferred <- typeIR_inferred*})

        3. (Let parameterTypeIR_aligned_inferred be $subst_parameterType(inference, parameterTypeIR_aligned))*{parameterTypeIR_aligned <- parameterTypeIR_aligned*, parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*}

        4. (Let typeIR_object_inferred be $subst_type(inference, typeIR_object))

        5. (Let constructorTypeIR_inferred be (ConstructorT parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} typeIR_object_inferred))

        6. If ((ConstructorType_wf: $bound(cursor', TC) |- constructorTypeIR_inferred holds)), then

          1. If ($instantiable(cursor', TC, instctxt, typeIR_object_inferred)), then

            1. (Call_convention_ok: cursor' TC (NOACTION) |- parameterTypeIR_aligned_inferred*{parameterTypeIR_aligned_inferred <- parameterTypeIR_aligned_inferred*} argumentIR*{argumentIR <- argumentIR*} : argumentIR_cast*{argumentIR_cast <- argumentIR_cast*})

            2. Result in typeIR_object_inferred, typeArgumentIR_inferred*{typeArgumentIR_inferred <- typeArgumentIR_inferred*}, argumentIR_cast*{argumentIR_cast <- argumentIR_cast*}

          1. Else Phantom#1173

        6. Else Phantom#1174

      3. Else Phantom#1175

    3. Else Phantom#1176

  2. Else Phantom#1177

3. Else Phantom#1178

;; ../../../../spec-concrete/5.05.2-subtype.watsup:338.1-342.23
def $reduce_serenum_unary(typedExpressionIR, $check)

1. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on $check(typeIR)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. (Let typeIR' be typeIR)

    2. If ((typeIR' has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR' as enumTypeIR))

      2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _tid typeIR_underlying _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. (Let typedExpressionIR_cast be (((CastE typeIR_underlying typedExpressionIR) as expressionIR) (( typeIR_underlying _ctk ))))

        3. Return $reduce_serenum_unary(typedExpressionIR_cast, $check)

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:363.1-368.44
def $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r, $check)

1. (Let (_expressionIR (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on $check(typeIR_l, typeIR_r)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. (Let typeIR be typeIR_l)

    2. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _tid typeIR_l_underlying _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. (Let typedExpressionIR_l_cast be (((CastE typeIR_l_underlying typedExpressionIR_l) as expressionIR) (( typeIR_l_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r, $check)

    3. (Let typeIR be typeIR_r)

    4. If ((typeIR has type enumTypeIR)), then

      1. (Let enumTypeIR be (typeIR as enumTypeIR))

      2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

        1. (Let (SEnumT _tid typeIR_r_underlying _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. (Let typedExpressionIR_r_cast be (((CastE typeIR_r_underlying typedExpressionIR_r) as expressionIR) (( typeIR_r_underlying _ctk' ))))

        3. Return $reduce_serenum_binary(typedExpressionIR_l, typedExpressionIR_r_cast, $check)

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.05.2-subtype.watsup:408.1-408.66
def $coerce_unary(typedExpressionIR, typeIR_to)

1. (Let (_expressionIR (( typeIR _ctk ))) be typedExpressionIR)

2. Case analysis on (Type_alpha: typeIR ~~ typeIR_to holds)

  1. Case true

    1. Return ?(typedExpressionIR)

  2. Case false

    1. If ((Sub_impl: typeIR <: typeIR_to holds)), then

      1. (Let typedExpressionIR_cast be (((CastE typeIR_to typedExpressionIR) as expressionIR) (( typeIR_to _ctk ))))

      2. Return ?(typedExpressionIR_cast)

    1. Else Phantom#1179

;; ../../../../spec-concrete/5.05.2-subtype.watsup:423.1-424.44
def $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)

1. (Let (_expressionIR (( typeIR_l _ctk ))) be typedExpressionIR_l)

2. (Let (_expressionIR' (( typeIR_r _ctk' ))) be typedExpressionIR_r)

3. Case analysis on (Type_alpha: typeIR_l ~~ typeIR_r holds)

  1. Case true

    1. Return ?((typedExpressionIR_l, typedExpressionIR_r))

  2. Case false

    1. Case analysis on (Sub_impl: typeIR_l <: typeIR_r holds)

      1. Case true

        1. (Let typedExpressionIR_l_cast be (((CastE typeIR_r typedExpressionIR_l) as expressionIR) (( typeIR_r _ctk' ))))

        2. Return ?((typedExpressionIR_l_cast, typedExpressionIR_r))

      2. Case false

        1. If ((Sub_impl: typeIR_r <: typeIR_l holds)), then

          1. (Let typedExpressionIR_r_cast be (((CastE typeIR_l typedExpressionIR_r) as expressionIR) (( typeIR_l _ctk' ))))

          2. Return ?((typedExpressionIR_l, typedExpressionIR_r_cast))

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:57.1-57.32
def $compat_lnot(typeIR)

1. Return $compat'_lnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:58.1-58.33
def $compat'_lnot(typeIR)

1. If ((typeIR has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BoolT`)), then

    1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:79.1-79.32
def $compat_bnot(typeIR)

1. Return $compat'_bnot($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:80.1-80.33
def $compat'_bnot(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:102.1-102.38
def $compat_uplusminus(typeIR)

1. Return $compat'_uplusminus($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:103.1-103.39
def $compat'_uplusminus(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:131.1-131.48
def $compat_plusminusmul(typeIR_l, typeIR_r)

1. Return $compat'_plusminusmul($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:132.1-132.49
def $compat'_plusminusmul(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `IntT`)), then

          1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:169.1-169.48
def $compat_satplusminus(typeIR_l, typeIR_r)

1. Return $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:170.1-170.49
def $compat'_satplusminus(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:206.1-206.42
def $compat_divmod(typeIR_l, typeIR_r)

1. Return $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:207.1-207.43
def $compat'_divmod(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. If ((numberTypeIR matches pattern `IntT`)), then

    1. If ((typeIR''' has type numberTypeIR)), then

      1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

      2. If ((numberTypeIR' matches pattern `IntT`)), then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:275.1-275.41
def $compat_shift(typeIR_l, typeIR_r)

1. Return $compat'_shift($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:276.1-276.42
def $compat'_shift(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `IntT`)

            1. Return true

          2. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat) be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat) be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `IntT`)

            1. Return true

          2. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat') be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat') be numberTypeIR')

            2. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `IntT`)

            1. Return true

          2. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat') be numberTypeIR')

            2. Return true

          3. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat') be numberTypeIR')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:369.1-369.43
def $compat_compare(typeIR_l, typeIR_r)

1. Return $compat'_compare($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:370.1-370.44
def $compat'_compare(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `IntT`)), then

          1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:407.1-407.43
def $compat_bitwise(typeIR_l, typeIR_r)

1. Return $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:408.1-408.44
def $compat'_bitwise(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:444.1-444.42
def $compat_concat(typeIR_l, typeIR_r)

1. Return $compat'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:445.1-445.43
def $compat'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat') be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat') be numberTypeIR')

            2. Return true

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT _nat') be numberTypeIR')

            2. Return true

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT _nat') be numberTypeIR')

            2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:456.1-456.45
def $result_concat(typeIR_l, typeIR_r)

1. Return $result'_concat($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:457.1-457.46
def $result'_concat(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w_a) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT w_b) be numberTypeIR')

            2. Return ?(((FIntT (w_a + w_b)) as typeIR))

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT w_b) be numberTypeIR')

            2. Return ?(((FIntT (w_a + w_b)) as typeIR))

    2. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w_a) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. Case analysis on numberTypeIR'

          1. Case (% matches pattern `FIntT%`)

            1. (Let (FIntT w_b) be numberTypeIR')

            2. Return ?(((FBitT (w_a + w_b)) as typeIR))

          2. Case (% matches pattern `FBitT%`)

            1. (Let (FBitT w_b) be numberTypeIR')

            2. Return ?(((FBitT (w_a + w_b)) as typeIR))

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:495.1-495.43
def $compat_logical(typeIR_l, typeIR_r)

1. Return $compat'_logical($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:496.1-496.44
def $compat'_logical(typeIR'', typeIR''')

1. If ((typeIR'' has type primitiveTypeIR)), then

  1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

  2. If ((primitiveTypeIR matches pattern `BoolT`)), then

    1. If ((typeIR''' has type primitiveTypeIR)), then

      1. (Let primitiveTypeIR' be (typeIR''' as primitiveTypeIR))

      2. If ((primitiveTypeIR' matches pattern `BoolT`)), then

        1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:807.1-807.39
def $compat_array_index(typeIR)

1. Return $compat'_arrayindex($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:808.1-808.39
def $compat'_arrayindex(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:899.1-899.41
def $compat_bitslice_base(typeIR)

1. Return $compat'_bitslice_base($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:900.1-900.42
def $compat'_bitslice_base(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. Return (w > 0)

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:910.1-910.42
def $compat_bitslice_index(typeIR)

1. Return $compat'_bitslice_index($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:911.1-911.43
def $compat'_bitslice_index(typeIR)

1. If ((typeIR has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT _nat) be numberTypeIR)

      2. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT _nat) be numberTypeIR)

      2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:921.1-921.48
def $is_valid_bitslice(typeIR, n_lo, n_hi)

1. Return ((n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:922.1-922.49
def $is_valid_bitslice'(typeIR', _nat'', _nat''')

1. If ((typeIR' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. (Let int be ((_nat''' - _nat'') + (1 as int)))

      3. If ((int has type nat)), then

        1. (Let w_slice be (int as nat))

        2. Return ((_nat''' <= w) /\ (w_slice <= w))

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. (Let int be ((_nat''' - _nat'') + (1 as int)))

      3. If ((int has type nat)), then

        1. (Let w_slice be (int as nat))

        2. Return ((_nat''' <= w) /\ (w_slice <= w))

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:992.1-992.52
def $is_static_routineTarget(routineTargetIR')

1. Case analysis on routineTargetIR'

  1. Case (% matches pattern `MethodT%%`)

    1. (Let (MethodT _typedExpressionIR name) be routineTargetIR')

    2. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (LCTK)

  2. Case (% matches pattern `TypeT%%`)

    1. (Let (TypeT _prefixedName name) be routineTargetIR')

    2. If (name is in ["minSizeInBits", "minSizeInBytes", "maxSizeInBits", "maxSizeInBytes"]), then

      1. Return (LCTK)

2. Otherwise

  1. Return (DYN)

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1033.1-1033.46
def $is_concrete_extern_object(typeIR)

1. Return $is_concrete_extern_object'($canon(typeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1034.1-1034.47
def $is_concrete_extern_object'(typeIR)

1. If (~$is_extern_object_typeIR(typeIR)), then

  1. Return true

2. If ((typeIR has type externObjectTypeIR)), then

  1. (Let (ExternT _tid ({ (_rid -> routineTypeDefIR)*{_rid <- _rid*, routineTypeDefIR <- routineTypeDefIR*} })) be (typeIR as externObjectTypeIR))

  2. If ($is_concrete_extern_object''(routineTypeDefIR))*{routineTypeDefIR <- routineTypeDefIR*}, then

    1. Return true

3. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1035.1-1035.58
def $is_concrete_extern_object''(routineTypeDefIR)

1. Case analysis on routineTypeDefIR

  1. Case (% has type monoRoutineTypeDefIR)

    1. (Let (MonoTD routineTypeIR) be (routineTypeDefIR as monoRoutineTypeDefIR))

    2. Return $is_concrete_extern_object'''(routineTypeIR)

  2. Case (% has type polyRoutineTypeDefIR)

    1. (Let (PolyTD routineTypeIR _tid*{_tid <- _tid*} _tid'*{_tid' <- _tid'*}) be (routineTypeDefIR as polyRoutineTypeDefIR))

    2. Return (true = $is_concrete_extern_object'''(routineTypeIR))

;; ../../../../spec-concrete/5.06.2-typing-expression.watsup:1036.1-1036.56
def $is_concrete_extern_object'''(routineTypeIR')

1. If ((routineTypeIR' matches pattern `ExternAbstractMethodT%%`)), then

  1. (Let (ExternAbstractMethodT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*} _typeIR) be routineTypeIR')

  2. Return false

2. Otherwise

  1. Return true

;; ../../../../spec-concrete/5.10-typing-statement.watsup:57.1-57.46
def $compat_direct_application(typeIR)

1. Return $compat'_direct_application($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:58.1-58.47
def $compat'_direct_application(typeIR)

1. Case analysis on typeIR

  1. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as parserObjectTypeIR))

    2. Return true

  2. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as controlObjectTypeIR))

    2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.10-typing-statement.watsup:158.1-160.26
relation SwitchLabel_table_ok: TC, tid_table, bool', switchLabel

1. If ((bool' = true)), then

  1. If ((switchLabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1180

1. Else Phantom#1181

2. If ((switchLabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expression) be switchLabel)

  2. If ((expression has type referenceExpression)), then

    1. (Let (NameE prefixedName) be (expression as referenceExpression))

    2. (Let prefixedName' be prefixedName)

    3. If ((prefixedName' matches pattern `CURRENT%`)), then

      1. (Let (CURRENT name_label) be prefixedName')

      2. (Let tid_table_enum be "action_list(" ++ tid_table ++ ")")

      3. (Let id_label be tid_table_enum ++ "." ++ name_label)

      4. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_var((LOCAL), TC, (CURRENT id_label)))

      5. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

        1. (Let ?((_direction typeIR_label ctk_label value?{value <- value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

        2. If ((value?{value <- value?} matches pattern (_))), then

          1. (Let ?(value_label) be value?{value <- value?})

          2. If ((value_label = ((TableEnumV tid_table_enum name_label) as value))), then

            1. (Let typedExpressionIR_label be (((NameE (CURRENT name_label)) as expressionIR) (( typeIR_label ctk_label ))))

            2. Result in (ExprL typedExpressionIR_label)

          2. Else Phantom#1182

        2. Else Phantom#1183

      5. Else Phantom#1184

    3. Else Phantom#1185

  2. Else Phantom#1186

2. Else Phantom#1187

;; ../../../../spec-concrete/5.10-typing-statement.watsup:185.1-187.29
relation SwitchCase_table_ok: TC, f, tid_table, b_last, switchCase

1. Case analysis on switchCase

  1. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchLabel) be switchCase)

    2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    3. (Let switchCaseIR be (FallC switchLabelIR))

    4. Result in f, switchCaseIR, switchLabel

  2. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchLabel blockStatement) be switchCase)

    2. (SwitchLabel_table_ok: TC tid_table b_last |- switchLabel : switchLabelIR)

    3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    4. (Let switchCaseIR be (MatchC switchLabelIR blockStatementIR))

    5. Result in f_post, switchCaseIR, switchLabel

;; ../../../../spec-concrete/5.10-typing-statement.watsup:213.1-215.26
relation SwitchCases_table_ok: TC, f, tid_table, switchCase*{switchCase <- switchCase*}

1. Case analysis on switchCase*{switchCase <- switchCase*}

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} be switchCase*{switchCase <- switchCase*})

    2. (Let b_last be (switchCase_t*{switchCase_t <- switchCase_t*} = []))

    3. (SwitchCase_table_ok: TC f tid_table b_last |- switchCase_h : f_h switchCaseIR_h switchLabel_h)

    4. (SwitchCases_table_ok: TC f_h tid_table |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} switchLabel_t*{switchLabel_t <- switchLabel_t*})

    5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../spec-concrete/5.10-typing-statement.watsup:251.1-253.26
relation SwitchLabel_general_ok: TC, _typeIR', bool', switchLabel

1. If ((bool' = true)), then

  1. If ((switchLabel matches pattern `DefaultL`)), then

    1. Result in (DefaultL)

  1. Else Phantom#1188

1. Else Phantom#1189

2. If ((switchLabel matches pattern `ExprL%`)), then

  1. (Let (ExprL expression_label) be switchLabel)

  2. (Expr_ok: (LOCAL) TC |- expression_label : typedExpressionIR_label)

  3. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_label, _typeIR'))

  4. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

    1. (Let ?(typedExpressionIR_label_cast) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

    2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR_label_cast)

    3. If ((ctk matches pattern `LCTK`)), then

      1. Result in (ExprL typedExpressionIR_label_cast)

    3. Else Phantom#1190

  4. Else Phantom#1191

2. Else Phantom#1192

;; ../../../../spec-concrete/5.10-typing-statement.watsup:273.1-275.29
relation SwitchCase_general_ok: TC, f, typeIR_switch, b_last, switchCase

1. Case analysis on switchCase

  1. Case (% matches pattern `FallC%`)

    1. (Let (FallC switchLabel) be switchCase)

    2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    3. (Let switchCaseIR be (FallC switchLabelIR))

    4. Result in f, switchCaseIR, switchLabel

  2. Case (% matches pattern `MatchC%%`)

    1. (Let (MatchC switchLabel blockStatement) be switchCase)

    2. (SwitchLabel_general_ok: TC typeIR_switch b_last |- switchLabel : switchLabelIR)

    3. (Block_ok: TC f |- blockStatement : TC_post f_post blockStatementIR)

    4. (Let switchCaseIR be (MatchC switchLabelIR blockStatementIR))

    5. Result in f_post, switchCaseIR, switchLabel

;; ../../../../spec-concrete/5.10-typing-statement.watsup:301.1-303.26
relation SwitchCases_general_ok: TC, f, typeIR_switch, switchCase*{switchCase <- switchCase*}

1. Case analysis on switchCase*{switchCase <- switchCase*}

  1. Case (% matches pattern [])

    1. Result in f, [], []

  2. Case (% matches pattern _ :: _)

    1. (Let switchCase_h :: switchCase_t*{switchCase_t <- switchCase_t*} be switchCase*{switchCase <- switchCase*})

    2. (Let b_last be (switchCase_t*{switchCase_t <- switchCase_t*} = []))

    3. (SwitchCase_general_ok: TC f typeIR_switch b_last |- switchCase_h : f_h switchCaseIR_h switchLabel_h)

    4. (SwitchCases_general_ok: TC f_h typeIR_switch |- switchCase_t*{switchCase_t <- switchCase_t*} : f_t switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*} switchLabel_t*{switchLabel_t <- switchLabel_t*})

    5. Result in f_t, switchCaseIR_h :: switchCaseIR_t*{switchCaseIR_t <- switchCaseIR_t*}, switchLabel_h :: switchLabel_t*{switchLabel_t <- switchLabel_t*}

;; ../../../../spec-concrete/5.10-typing-statement.watsup:318.1-318.34
def $compat_switch(typeIR)

1. Return $compat'_switch($canon(typeIR))

;; ../../../../spec-concrete/5.10-typing-statement.watsup:319.1-319.35
def $compat'_switch(typeIR)

1. Case analysis on typeIR

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR as primitiveTypeIR))

    2. If ((primitiveTypeIR matches pattern `ErrT`)), then

      1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      2. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid _typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:73.1-76.29
relation Decl_object_ok: p, TC_0, frame, rdenv, objectDeclaration

1. Case analysis on objectDeclaration

  1. Case (% has type functionDeclaration)

    1. (Let (FuncD typeOrVoid name typeParameter*{typeParameter <- typeParameter*} parameter*{parameter <- parameter*} blockStatement) be (objectDeclaration as functionDeclaration))

    2. (Let TC_1 be TC_0[BLOCK.KIND = (EXTERN)])

    3. (Let TC_2 be TC_1[BLOCK.FRAME = frame])

    4. (Let tid_expl be typeParameter)*{tid_expl <- tid_expl*, typeParameter <- typeParameter*}

    5. (Let TC_3 be $add_types((LOCAL), TC_2, tid_expl*{tid_expl <- tid_expl*}, ((MonoTD ((NameT tid_expl) as typeIR)) as typeDefIR)*{tid_expl <- tid_expl*}))

    6. (Type_ok: (LOCAL) TC_3 |- typeOrVoid : typeIR_ret tid*{tid <- tid*})

    7. If ((tid*{tid <- tid*} matches pattern [])), then

      1. (Parameters_ok: (LOCAL) TC_3 |- parameter*{parameter <- parameter*} : parameterIR*{parameterIR <- parameterIR*} tid_impl*{tid_impl <- tid_impl*})

      2. (Let parameterTypeIR be $parameterIR(parameterIR))*{parameterIR <- parameterIR*, parameterTypeIR <- parameterTypeIR*}

      3. (Let TC_4 be $add_parameters((LOCAL), TC_3, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}))

      4. (Let TC_5 be TC_4[LOCAL.KIND = (EXTERNMETHOD typeIR_ret)])

      5. (Block_ok: TC_5 (CONT) |- blockStatement : _typingContext f blockStatementIR)

      6. If ((f matches pattern `RET`)), then

        1. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        2. (Let routineTypeIR be (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        3. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

          1. (Let rdenv_init be $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

          2. (Let functionDeclarationIR be (FuncD typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*} blockStatementIR))

          3. Result in frame, rdenv_init, (functionDeclarationIR as objectDeclarationIR)

        4. Else Phantom#1193

      6. Else Phantom#1194

      7. If ((typeIR_ret = ((VoidT) as typeIR))), then

        1. (Let rid be $rid(name, parameter*{parameter <- parameter*}))

        2. (Let routineTypeIR be (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret))

        3. (Let routineTypeDefIR be ((PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        4. If ((RoutineTypeDef_wf: $bound(p, TC_0) |- routineTypeDefIR holds)), then

          1. (Let rdenv_init be $update_map<rid, routineTypeDefIR>(rdenv, rid, routineTypeDefIR))

          2. (Let functionDeclarationIR be (FuncD typeIR_ret name tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*} parameterIR*{parameterIR <- parameterIR*} blockStatementIR))

          3. Result in frame, rdenv_init, (functionDeclarationIR as objectDeclarationIR)

        4. Else Phantom#1195

      7. Else Phantom#1196

    7. Else Phantom#1197

  2. Case (% has type instantiation)

    1. (Let instantiation be (objectDeclaration as instantiation))

    2. (Decl_ok: p TC_0 |- (instantiation as declaration) : TC_1 declarationIR)

    3. If ((declarationIR has type instantiationIR)), then

      1. (Let instantiationIR be (declarationIR as instantiationIR))

      2. (Let (InstD _typeIR _prefixedName _typeArgumentIR*{_typeArgumentIR <- _typeArgumentIR*} _argumentIR*{_argumentIR <- _argumentIR*} name _objectInitializerIR?{_objectInitializerIR <- _objectInitializerIR?}) be instantiationIR)

      3. (Let varTypeIR'?{varTypeIR' <- varTypeIR'?} be $find_var(p, TC_1, (CURRENT name)))

      4. If ((varTypeIR'?{varTypeIR' <- varTypeIR'?} matches pattern (_))), then

        1. (Let ?(varTypeIR) be varTypeIR'?{varTypeIR' <- varTypeIR'?})

        2. (Let frame_init be $update_map<id, varTypeIR>(frame, name, varTypeIR))

        3. Result in frame_init, rdenv, (instantiationIR as objectDeclarationIR)

      4. Else Phantom#1198

    3. Else Phantom#1199

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:129.1-132.29
relation Decls_object_ok: p, TC, frame', rdenv', objectDeclaration*{objectDeclaration <- objectDeclaration*}

1. Case analysis on objectDeclaration*{objectDeclaration <- objectDeclaration*}

  1. Case (% matches pattern [])

    1. Result in frame', rdenv', []

  2. Case (% matches pattern _ :: _)

    1. (Let objectDeclaration_h :: objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} be objectDeclaration*{objectDeclaration <- objectDeclaration*})

    2. (Decl_object_ok: p TC frame' rdenv' |- objectDeclaration_h : frame_1 rdenv_1 objectDeclarationIR_h)

    3. (Decls_object_ok: p TC frame_1 rdenv_1 |- objectDeclaration_t*{objectDeclaration_t <- objectDeclaration_t*} : frame_2 rdenv_2 objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*})

    4. Result in frame_2, rdenv_2, objectDeclarationIR_h :: objectDeclarationIR_t*{objectDeclarationIR_t <- objectDeclarationIR_t*}

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:147.1-147.46
def $subst_rdenv(theta, rdenv_extern, set<pair<rid, routineTypeDefIR>>')

1. If ((set<pair<rid, routineTypeDefIR>>' = ({ [] }))), then

  1. Return rdenv_extern

1. Else Phantom#1200

2. (Let ({ pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} }) be set<pair<rid, routineTypeDefIR>>')

3. If ((pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*} matches pattern _ :: _)), then

  1. (Let (rid_init_h -> routineTypeDefIR_init_h) :: (rid_init_t -> routineTypeDefIR_init_t)*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} be pair<rid, routineTypeDefIR>*{pair<rid, routineTypeDefIR> <- pair<rid, routineTypeDefIR>*})

  2. (Let (id_init_h _pid*{_pid <- _pid*}) be rid_init_h)

  3. (Let (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} be $find_non_overloaded<routineTypeDefIR>(rdenv_extern, id_init_h))

  4. If (((rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?} matches pattern (_))), then

    1. (Let ?((rid, routineTypeDefIR')) be (rid, routineTypeDefIR)?{(rid, routineTypeDefIR) <- (rid, routineTypeDefIR)?})

    2. If ((routineTypeDefIR' has type polyRoutineTypeDefIR)), then

      1. (Let (PolyTD routineTypeIR tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) be (routineTypeDefIR' as polyRoutineTypeDefIR))

      2. If ((routineTypeIR matches pattern `ExternAbstractMethodT%%`)), then

        1. (Let (ExternAbstractMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) be routineTypeIR)

        2. (Let routineTypeDefIR be ((PolyTD (ExternMethodT parameterTypeIR*{parameterTypeIR <- parameterTypeIR*} typeIR_ret) tid_expl*{tid_expl <- tid_expl*} tid_impl*{tid_impl <- tid_impl*}) as routineTypeDefIR))

        3. (Let routineTypeDefIR_subst be $subst_routineTypeDef(theta, routineTypeDefIR))

        4. If ((RoutineTypeDef_alpha: routineTypeDefIR_subst ~~ routineTypeDefIR_init_h holds)), then

          1. (Let rdenv_extern_subst be $update_map<rid, routineTypeDefIR>(rdenv_extern, rid, routineTypeDefIR_subst))

          2. Return $subst_rdenv(theta, rdenv_extern_subst, ({ (rid_init_t -> routineTypeDefIR_init_t)*{rid_init_t <- rid_init_t*, routineTypeDefIR_init_t <- routineTypeDefIR_init_t*} }))

        4. Else Phantom#1201

      2. Else Phantom#1202

    2. Else Phantom#1203

  4. Else Phantom#1204

3. Else Phantom#1205

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:369.1-369.81
def $split_constructors(methodPrototype*{methodPrototype <- methodPrototype*})

1. Case analysis on methodPrototype*{methodPrototype <- methodPrototype*}

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let methodPrototype_h :: methodPrototype_t*{methodPrototype_t <- methodPrototype_t*} be methodPrototype*{methodPrototype <- methodPrototype*})

    2. (Let methodPrototype' be methodPrototype_h)

    3. Case analysis on methodPrototype'

      1. Case (% matches pattern `ConsM%%`)

        1. (Let (ConsM _name _constructorParameter*{_constructorParameter <- _constructorParameter*}) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) be $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*}))

        3. Return (methodPrototype_h :: methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})

      2. Case (% matches pattern `MethodM%%%%`)

        1. (Let (MethodM _typeOrVoid _name _typeParameter*{_typeParameter <- _typeParameter*} _parameter*{_parameter <- _parameter*}) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) be $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*}))

        3. Return (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})

      3. Case (% matches pattern `AbstractMethodM%%%%`)

        1. (Let (AbstractMethodM _typeOrVoid _name _typeParameter*{_typeParameter <- _typeParameter*} _parameter*{_parameter <- _parameter*}) be methodPrototype')

        2. (Let (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*}) be $split_constructors(methodPrototype_t*{methodPrototype_t <- methodPrototype_t*}))

        3. Return (methodPrototype_t_constructor*{methodPrototype_t_constructor <- methodPrototype_t_constructor*}, methodPrototype_h :: methodPrototype_t_method*{methodPrototype_t_method <- methodPrototype_t_method*})

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:548.1-551.26
relation Enum_serializable_field_ok: TC_0, name_enum, typeIR, (name expression)

1. (Expr_ok: (BLOCK) TC_0 |- expression : typedExpressionIR)

2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $coerce_unary(typedExpressionIR, typeIR))

3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

  1. (Let ?(typedExpressionIR_cast) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

  2. (Let (_expressionIR (( _typeIR ctk ))) be typedExpressionIR_cast)

  3. If ((ctk matches pattern `LCTK`)), then

    1. (Eval_static: (BLOCK) TC_0 |- typedExpressionIR_cast ~> value)

    2. (Let typeIR_enum be ((SEnumT name_enum typeIR []) as typeIR))

    3. (Let value_enum be ((SEnumV name_enum name value) as value))

    4. (Let TC_1 be $add_var((BLOCK), TC_0, name, ((NO) typeIR_enum (LCTK) ?(value_enum))))

    5. Result in TC_1, (name typedExpressionIR_cast), value

  3. Else Phantom#1206

3. Else Phantom#1207

;; ../../../../spec-concrete/5.11-typing-declaration.watsup:569.1-572.26
relation Enum_serializable_fields_ok: TC', name_enum, typeIR, namedExpression*{namedExpression <- namedExpression*}

1. Case analysis on namedExpression*{namedExpression <- namedExpression*}

  1. Case (% matches pattern [])

    1. Result in TC', [], []

  2. Case (% matches pattern _ :: _)

    1. (Let namedExpression_h :: namedExpression_t*{namedExpression_t <- namedExpression_t*} be namedExpression*{namedExpression <- namedExpression*})

    2. (Enum_serializable_field_ok: TC' name_enum typeIR |- namedExpression_h : TC_1 namedExpressionIR_h value_field_h)

    3. (Enum_serializable_fields_ok: TC_1 name_enum typeIR |- namedExpression_t*{namedExpression_t <- namedExpression_t*} : TC_2 namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*} value_field_t*{value_field_t <- value_field_t*})

    4. (Let namedExpressionIR*{namedExpressionIR <- namedExpressionIR*} be namedExpressionIR_h :: namedExpressionIR_t*{namedExpressionIR_t <- namedExpressionIR_t*})

    5. (Let value_field*{value_field <- value_field*} be value_field_h :: value_field_t*{value_field_t <- value_field_t*})

    6. Result in TC_2, namedExpressionIR*{namedExpressionIR <- namedExpressionIR*}, value_field*{value_field <- value_field*}

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:21.1-23.23
relation SelectCase_keyset_ok: TC, typeIR_key, keysetExpression

1. Case analysis on keysetExpression

  1. Case (% matches pattern `ExprK%`)

    1. (Let (ExprK expression) be keysetExpression)

    2. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

    3. (Let (_expressionIR (( typeIR' _ctk ))) be typedExpressionIR)

    4. If ((typeIR' has type setTypeIR)), then

      1. (Let (SetT typeIR) be (typeIR' as setTypeIR))

      2. Case analysis on (Type_alpha: typeIR ~~ typeIR_key holds)

        1. Case true

          1. Result in (ExprK typedExpressionIR)

        2. Case false

          1. If ((Sub_impl: typeIR <: typeIR_key holds)), then

            1. (Let typeIR_cast be ((SetT typeIR_key) as typeIR))

            2. (Let typedExpressionIR_cast be (((CastE typeIR_cast typedExpressionIR) as expressionIR) (( typeIR_cast (DYN) ))))

            3. Result in (ExprK typedExpressionIR_cast)

          1. Else Phantom#1208

    4. Else Phantom#1209

    5. If (~$is_set_typeIR(typeIR')), then

      1. If ((Sub_impl: typeIR' <: typeIR_key holds)), then

        1. (Let typeIR_cast be ((SetT typeIR_key) as typeIR))

        2. (Let typedExpressionIR_cast be (((CastE typeIR_cast typedExpressionIR) as expressionIR) (( typeIR_cast (DYN) ))))

        3. Result in (ExprK typedExpressionIR_cast)

      1. Else Phantom#1210

    5. Else Phantom#1211

  2. Case (% matches pattern `MaskK%%`)

    1. (Let (MaskK expression_l expression_r) be keysetExpression)

    2. (Expr_ok: (LOCAL) TC |- expression_l : typedExpressionIR_l)

    3. (Expr_ok: (LOCAL) TC |- expression_r : typedExpressionIR_r)

    4. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    5. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

      2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

      3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

        2. (Let (_expressionIR (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

        4. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

          1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

          2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

          3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

            1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

            2. Result in (MaskK typedExpressionIR_l_coerced typedExpressionIR_r_coerced)

          3. Else Phantom#1212

        4. Else Phantom#1213

      3. Else Phantom#1214

    5. Else Phantom#1215

  3. Case (% matches pattern `RangeK%%`)

    1. (Let (RangeK expression_l expression_r) be keysetExpression)

    2. (Expr_ok: (LOCAL) TC |- expression_l : typedExpressionIR_l)

    3. (Expr_ok: (LOCAL) TC |- expression_r : typedExpressionIR_r)

    4. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

    5. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

      1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

      2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

      3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

        2. (Let (_expressionIR (( typeIR_reduced _ctk ))) be typedExpressionIR_l_reduced)

        3. (Let (_expressionIR' (( typeIR _ctk' ))) be typedExpressionIR_r_reduced)

        4. If ((typeIR = typeIR_reduced)), then

          1. (Let typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} be $coerce_unary(typedExpressionIR_l_reduced, typeIR_key))

          2. If ((typedExpressionIR?{typedExpressionIR <- typedExpressionIR?} matches pattern (_))), then

            1. (Let ?(typedExpressionIR_l_coerced) be typedExpressionIR?{typedExpressionIR <- typedExpressionIR?})

            2. (Let typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} be $coerce_unary(typedExpressionIR_r_reduced, typeIR_key))

            3. If ((typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?} matches pattern (_))), then

              1. (Let ?(typedExpressionIR_r_coerced) be typedExpressionIR'?{typedExpressionIR' <- typedExpressionIR'?})

              2. Result in (RangeK typedExpressionIR_l_coerced typedExpressionIR_r_coerced)

            3. Else Phantom#1216

          2. Else Phantom#1217

        4. Else Phantom#1218

      3. Else Phantom#1219

    5. Else Phantom#1220

  4. Case (% matches pattern `DefaultK`)

    1. Result in (DefaultK)

  5. Case (% matches pattern `AnyK`)

    1. Result in (AnyK)

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:64.1-64.40
def $compat_mask(typeIR_l, typeIR_r)

1. Return $compat'_mask($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:65.1-65.41
def $compat'_mask(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `IntT`)), then

          1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:101.1-101.41
def $compat_range(typeIR_l, typeIR_r)

1. Return $compat'_range($canon(typeIR_l), $canon(typeIR_r))

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:102.1-102.42
def $compat'_range(typeIR'', typeIR''')

1. If ((typeIR'' has type numberTypeIR)), then

  1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

  2. Case analysis on numberTypeIR

    1. Case (% matches pattern `IntT`)

      1. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `IntT`)), then

          1. Return true

    2. Case (% matches pattern `FIntT%`)

      1. (Let (FIntT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FIntT%`)), then

          1. (Let (FIntT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

    3. Case (% matches pattern `FBitT%`)

      1. (Let (FBitT w) be numberTypeIR)

      2. If ((typeIR''' has type numberTypeIR)), then

        1. (Let numberTypeIR' be (typeIR''' as numberTypeIR))

        2. If ((numberTypeIR' matches pattern `FBitT%`)), then

          1. (Let (FBitT w') be numberTypeIR')

          2. If ((w = w')), then

            1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:149.1-151.23
relation SelectCase_keysets_ok: TC, typeIR'*{typeIR' <- typeIR'*}, keysetExpression*{keysetExpression <- keysetExpression*}

1. If ((typeIR'*{typeIR' <- typeIR'*} matches pattern [])), then

  1. If ((keysetExpression*{keysetExpression <- keysetExpression*} = [(DefaultK)])), then

    1. Result in [(DefaultK)]

  1. Else Phantom#1221

1. Else Phantom#1222

2. Case analysis on keysetExpression*{keysetExpression <- keysetExpression*}

  1. Case (% = [(DefaultK)])

    1. If ((|typeIR'*{typeIR' <- typeIR'*}| > 1)), then

      1. (SelectCase_keyset_ok: TC ((SeqT typeIR'*{typeIR' <- typeIR'*}) as typeIR) |- (DefaultK) : keysetExpressionIR)

      2. Result in [keysetExpressionIR]

    1. Else Phantom#1223

  2. Case (% = [(AnyK)])

    1. If ((|typeIR'*{typeIR' <- typeIR'*}| > 1)), then

      1. (SelectCase_keyset_ok: TC ((SeqT typeIR'*{typeIR' <- typeIR'*}) as typeIR) |- (AnyK) : keysetExpressionIR)

      2. Result in [keysetExpressionIR]

    1. Else Phantom#1224

2. Else Phantom#1225

3. If ((|typeIR'*{typeIR' <- typeIR'*}| = |keysetExpression*{keysetExpression <- keysetExpression*}|)), then

  1. (SelectCase_keyset_ok: TC typeIR' |- keysetExpression : keysetExpressionIR)*{keysetExpression <- keysetExpression*, keysetExpressionIR <- keysetExpressionIR*, typeIR' <- typeIR'*}

  2. Result in keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*}

3. Else Phantom#1226

;; ../../../../spec-concrete/5.13.1-typing-parser-statement.watsup:184.1-186.26
relation SelectCase_ok: TC, name_state*{name_state <- name_state*}, typeIR_key*{typeIR_key <- typeIR_key*}, (keysetExpression*{keysetExpression <- keysetExpression*} name)

1. (SelectCase_keysets_ok: TC typeIR_key*{typeIR_key <- typeIR_key*} |- keysetExpression*{keysetExpression <- keysetExpression*} : keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*})

2. If (name is in name_state*{name_state <- name_state*}), then

  1. Result in (keysetExpressionIR*{keysetExpressionIR <- keysetExpressionIR*} name)

2. Else Phantom#1227

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:7.1-7.52
def $compat_table_exact_optional_key(typeIR)

1. Return $compat'_table_exact_optional_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:8.1-8.53
def $compat'_table_exact_optional_key(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type primitiveTypeIR)

    1. (Let primitiveTypeIR be (typeIR'' as primitiveTypeIR))

    2. Case analysis on primitiveTypeIR

      1. Case (% matches pattern `BoolT`)

        1. Return true

      2. Case (% matches pattern `ErrT`)

        1. Return true

  2. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Return true

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $compat_table_exact_optional_key(typeIR)

  4. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. Case analysis on enumTypeIR

      1. Case (% matches pattern `EnumT%%`)

        1. (Let (EnumT _tid _id*{_id <- _id*}) be enumTypeIR)

        2. Return true

      2. Case (% matches pattern `SEnumT%%%`)

        1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

        2. Return $compat_table_exact_optional_key(typeIR)

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:23.1-23.55
def $compat_table_lpm_ternary_range_key(typeIR)

1. Return $compat'_table_lpm_ternary_range_key($canon(typeIR))

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:24.1-24.56
def $compat'_table_lpm_ternary_range_key(typeIR'')

1. Case analysis on typeIR''

  1. Case (% has type numberTypeIR)

    1. (Let numberTypeIR be (typeIR'' as numberTypeIR))

    2. Case analysis on numberTypeIR

      1. Case (% matches pattern `IntT`)

        1. Return true

      2. Case (% matches pattern `FIntT%`)

        1. (Let (FIntT _nat) be numberTypeIR)

        2. Return true

      3. Case (% matches pattern `FBitT%`)

        1. (Let (FBitT _nat) be numberTypeIR)

        2. Return true

  2. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. If ((aliasTypeIR matches pattern `NewT%%`)), then

      1. (Let (NewT _tid typeIR) be aliasTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR)

  3. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((enumTypeIR matches pattern `SEnumT%%%`)), then

      1. (Let (SEnumT _tid typeIR _valueFieldIR*{_valueFieldIR <- _valueFieldIR*}) be enumTypeIR)

      2. Return $compat_table_lpm_ternary_range_key(typeIR)

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:38.1-38.43
def $compat_table_key(name, typeIR)

1. Case analysis on name

  1. Case (% = "exact")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  2. Case (% = "optional")

    1. If ($compat_table_exact_optional_key(typeIR)), then

      1. Return true

  3. Case (% = "lpm")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  4. Case (% = "ternary")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

  5. Case (% = "range")

    1. If ($compat_table_lpm_ternary_range_key(typeIR)), then

      1. Return true

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:90.1-91.41
def $split_dataplane_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

1. Case analysis on parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

  1. Case (% matches pattern [])

    1. Return ([], [])

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} be parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

    2. (Let (direction _typeIR _id _value?{_value <- _value?}) be parameterTypeIR_h)

    3. Case analysis on (direction matches pattern `NO`)

      1. Case true

        1. (Let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) be $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}))

        2. Return (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_h :: parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})

      2. Case false

        1. (Let (parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*}) be $split_dataplane_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}))

        2. Return (parameterTypeIR_h :: parameterTypeIR_data*{parameterTypeIR_data <- parameterTypeIR_data*}, parameterTypeIR_control*{parameterTypeIR_control <- parameterTypeIR_control*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:214.1-217.26
relation TableEntry_keyset_ok: TC, TBLC, (typeIR_key, text'), keysetExpression

1. Case analysis on text'

  1. Case (% = "lpm")

    1. Case analysis on keysetExpression

      1. Case (% matches pattern `ExprK%`)

        1. (Let (ExprK expression) be keysetExpression)

        2. (Let matchMode be TBLC.MODE)

        3. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM n) be matchMode)

          2. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

          3. (Let (_expressionIR (( typeIR ctk ))) be typedExpressionIR)

          4. If ((Sub_impl: typeIR <: typeIR_key holds)), then

            1. (Let typeIR_set be ((SetT typeIR_key) as typeIR))

            2. (Let typedExpressionIR_set be (((CastE typeIR_set typedExpressionIR) as expressionIR) (( typeIR_set ctk ))))

            3. Result in (LPM n), (ExprK typedExpressionIR_set)

          4. Else Phantom#1228

        3. Else Phantom#1229

      2. Case (% matches pattern `MaskK%%`)

        1. (Let (MaskK expression_l expression_r) be keysetExpression)

        2. (Let matchMode be TBLC.MODE)

        3. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM n) be matchMode)

          2. (Expr_ok: (LOCAL) TC |- expression_l : typedExpressionIR_l)

          3. (Expr_ok: (LOCAL) TC |- expression_r : typedExpressionIR_r)

          4. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

          5. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

            1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

            2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

            3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

              1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

              2. (Let (_expressionIR (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

              3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

                1. If ((ctk_r_reduced matches pattern `LCTK`)), then

                  1. (Eval_static: (LOCAL) TC |- typedExpressionIR_r_reduced ~> value_r)

                  2. (Let int?{int <- int?} be $to_number(value_r))

                  3. If ((int?{int <- int?} matches pattern (_))), then

                    1. (Let ?(i_r) be int?{int <- int?})

                    2. (Let n_prefix be $tableEntry_lpm_prefix(((FBitV n $to_bitstr((n as int), i_r)) as value)))

                    3. Result in (LPM n_prefix), (MaskK typedExpressionIR_l_reduced typedExpressionIR_r_reduced)

                  3. Else Phantom#1230

                1. Else Phantom#1231

              3. Else Phantom#1232

            3. Else Phantom#1233

          5. Else Phantom#1234

        3. Else Phantom#1235

      3. Case (% matches pattern `DefaultK`)

        1. (Let matchMode be TBLC.MODE)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM n) be matchMode)

          2. Result in (LPM n), (DefaultK)

        2. Else Phantom#1236

      4. Case (% matches pattern `AnyK`)

        1. (Let matchMode be TBLC.MODE)

        2. If ((matchMode matches pattern `NOPRILPM%`)), then

          1. (Let (NOPRILPM _nat) be matchMode)

          2. Result in (LPM 0), (AnyK)

        2. Else Phantom#1237

    1. Else Phantom#1238

  2. Case (% = "ternary")

    1. If ((keysetExpression matches pattern `MaskK%%`)), then

      1. (Let (MaskK expression_l expression_r) be keysetExpression)

      2. (Expr_ok: (LOCAL) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (LOCAL) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

        2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_mask))

        3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

          2. (Let (_expressionIR (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

            1. Result in (NOLPM), (MaskK typedExpressionIR_l_reduced typedExpressionIR_r_reduced)

          3. Else Phantom#1239

        3. Else Phantom#1240

      5. Else Phantom#1241

    1. Else Phantom#1242

  3. Case (% = "range")

    1. If ((keysetExpression matches pattern `RangeK%%`)), then

      1. (Let (RangeK expression_l expression_r) be keysetExpression)

      2. (Expr_ok: (LOCAL) TC |- expression_l : typedExpressionIR_l)

      3. (Expr_ok: (LOCAL) TC |- expression_r : typedExpressionIR_r)

      4. (Let (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} be $coerce_binary(typedExpressionIR_l, typedExpressionIR_r))

      5. If (((typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?} matches pattern (_))), then

        1. (Let ?((typedExpressionIR_l_cast, typedExpressionIR_r_cast)) be (typedExpressionIR, typedExpressionIR)?{(typedExpressionIR, typedExpressionIR) <- (typedExpressionIR, typedExpressionIR)?})

        2. (Let (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} be $reduce_serenum_binary(typedExpressionIR_l_cast, typedExpressionIR_r_cast, $compat_range))

        3. If (((typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?} matches pattern (_))), then

          1. (Let ?((typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)) be (typedExpressionIR, typedExpressionIR)'?{(typedExpressionIR, typedExpressionIR)' <- (typedExpressionIR, typedExpressionIR)'?})

          2. (Let (_expressionIR (( typeIR_reduced ctk_r_reduced ))) be typedExpressionIR_r_reduced)

          3. If ((Sub_impl: typeIR_reduced <: typeIR_key holds)), then

            1. Result in (NOLPM), (RangeK typedExpressionIR_l_reduced typedExpressionIR_r_reduced)

          3. Else Phantom#1243

        3. Else Phantom#1244

      5. Else Phantom#1245

    1. Else Phantom#1246

1. Else Phantom#1247

2. Case analysis on keysetExpression

  1. Case (% matches pattern `ExprK%`)

    1. (Let (ExprK expression) be keysetExpression)

    2. If ((text' =/= "lpm")), then

      1. (Expr_ok: (LOCAL) TC |- expression : typedExpressionIR)

      2. (Let (_expressionIR (( typeIR ctk ))) be typedExpressionIR)

      3. If ((Sub_impl: typeIR <: typeIR_key holds)), then

        1. (Let typeIR_set be ((SetT typeIR_key) as typeIR))

        2. (Let typedExpressionIR_set be (((CastE typeIR_set typedExpressionIR) as expressionIR) (( typeIR_set ctk ))))

        3. Result in (NOLPM), (ExprK typedExpressionIR_set)

      3. Else Phantom#1248

    2. Else Phantom#1249

  2. Case (% matches pattern `DefaultK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (DefaultK)

    1. Else Phantom#1250

  3. Case (% matches pattern `AnyK`)

    1. If ((text' =/= "exact")), then

      1. Result in (NOLPM), (AnyK)

    1. Else Phantom#1251

2. Else Phantom#1252

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:356.1-359.29
relation TableEntry_keysets_ok': TC, TBLC, TBLS', matchKey*{matchKey <- matchKey*}, keysetExpression*{keysetExpression <- keysetExpression*}

1. Case analysis on matchKey*{matchKey <- matchKey*}

  1. Case (% matches pattern [])

    1. If ((keysetExpression*{keysetExpression <- keysetExpression*} matches pattern [])), then

      1. Result in TBLS', []

    1. Else Phantom#1253

  2. Case (% matches pattern _ :: _)

    1. (Let matchKey_h :: matchKey_t*{matchKey_t <- matchKey_t*} be matchKey*{matchKey <- matchKey*})

    2. If ((keysetExpression*{keysetExpression <- keysetExpression*} matches pattern _ :: _)), then

      1. (Let keysetExpression_h :: keysetExpression_t*{keysetExpression_t <- keysetExpression_t*} be keysetExpression*{keysetExpression <- keysetExpression*})

      2. (TableEntry_keyset_ok: TC TBLC |- matchKey_h keysetExpression_h : TBLS_1 keysetExpressionIR_h)

      3. (Let TBLS_2 be $join_tableEntryState(TBLS', TBLS_1))

      4. (TableEntry_keysets_ok': TC TBLC TBLS_2 |- matchKey_t*{matchKey_t <- matchKey_t*} keysetExpression_t*{keysetExpression_t <- keysetExpression_t*} : TBLS_3 keysetExpressionIR_t*{keysetExpressionIR_t <- keysetExpressionIR_t*})

      5. Result in TBLS_3, keysetExpressionIR_h :: keysetExpressionIR_t*{keysetExpressionIR_t <- keysetExpressionIR_t*}

    2. Else Phantom#1254

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:708.1-708.44
def $count_table_keys(tableProperty''*{tableProperty'' <- tableProperty''*})

1. Case analysis on tableProperty''*{tableProperty'' <- tableProperty''*}

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} be tableProperty''*{tableProperty'' <- tableProperty''*})

    2. Case analysis on tableProperty

      1. Case (% matches pattern `KeyP%`)

        1. (Let (KeyP _tableKey*{_tableKey <- _tableKey*}) be tableProperty)

        2. Return (1 + $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*}))

      2. Case (% matches pattern `ActionP%`)

        1. (Let (ActionP _tableAction*{_tableAction <- _tableAction*}) be tableProperty)

        2. Return $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})

      3. Case (% matches pattern `EntryP%%`)

        1. (Let (EntryP _const?{_const <- _const?} _tableEntry*{_tableEntry <- _tableEntry*}) be tableProperty)

        2. Return $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})

      4. Case (% matches pattern `CustomP%%%`)

        1. (Let (CustomP _const?{_const <- _const?} _name _initializer) be tableProperty)

        2. Return $count_table_keys(tableProperty_t*{tableProperty_t <- tableProperty_t*})

;; ../../../../spec-concrete/5.14.1-typing-control-table.watsup:728.1-728.47
def $count_table_actions(tableProperty''*{tableProperty'' <- tableProperty''*})

1. Case analysis on tableProperty''*{tableProperty'' <- tableProperty''*}

  1. Case (% matches pattern [])

    1. Return 0

  2. Case (% matches pattern _ :: _)

    1. (Let tableProperty :: tableProperty_t*{tableProperty_t <- tableProperty_t*} be tableProperty''*{tableProperty'' <- tableProperty''*})

    2. Case analysis on tableProperty

      1. Case (% matches pattern `ActionP%`)

        1. (Let (ActionP _tableAction*{_tableAction <- _tableAction*}) be tableProperty)

        2. Return (1 + $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*}))

      2. Case (% matches pattern `KeyP%`)

        1. (Let (KeyP _tableKey*{_tableKey <- _tableKey*}) be tableProperty)

        2. Return $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})

      3. Case (% matches pattern `EntryP%%`)

        1. (Let (EntryP _const?{_const <- _const?} _tableEntry*{_tableEntry <- _tableEntry*}) be tableProperty)

        2. Return $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})

      4. Case (% matches pattern `CustomP%%%`)

        1. (Let (CustomP _const?{_const <- _const?} _name _initializer) be tableProperty)

        2. Return $count_table_actions(tableProperty_t*{tableProperty_t <- tableProperty_t*})

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:7.1-7.73
def $filter_default_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, id_default*{id_default <- id_default*})

1. Case analysis on parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}

  1. Case (% matches pattern [])

    1. Return []

  2. Case (% matches pattern _ :: _)

    1. (Let parameterTypeIR_h :: parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*} be parameterTypeIR*{parameterTypeIR <- parameterTypeIR*})

    2. (Let (_direction _typeIR id_h _value?{_value <- _value?}) be parameterTypeIR_h)

    3. Case analysis on id_h is in id_default*{id_default <- id_default*}

      1. Case true

        1. Return $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})

      2. Case false

        1. Return parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*{parameterTypeIR_t <- parameterTypeIR_t*}, id_default*{id_default <- id_default*})

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:27.1-27.71
def $align_parameters(parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*})

1. (Let (_direction _typeIR id _value?{_value <- _value?}) be parameterTypeIR)*{_direction <- _direction*, _typeIR <- _typeIR*, _value? <- _value?*, id <- id*, parameterTypeIR <- parameterTypeIR*}

2. (Let parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} be $align_parameters'(({ (id -> parameterTypeIR)*{id <- id*, parameterTypeIR <- parameterTypeIR*} }), parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, parameterTypeIR <- parameterTypeIR*, parameterTypeIR'? <- parameterTypeIR'?*}

3. If ((parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?} matches pattern (_)))*{parameterTypeIR'? <- parameterTypeIR'?*}, then

  1. (Let ?(parameterTypeIR_aligned) be parameterTypeIR'?{parameterTypeIR' <- parameterTypeIR'?})*{parameterTypeIR'? <- parameterTypeIR'?*, parameterTypeIR_aligned <- parameterTypeIR_aligned*}

  2. Return parameterTypeIR_aligned*{parameterTypeIR_aligned <- parameterTypeIR_aligned*}

3. Else Phantom#1255

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:28.1-28.96
def $align_parameters'(_map<id, parameterTypeIR>', parameterTypeIR', argumentIR)

1. If ((argumentIR matches pattern `ExprA%`)), then

  1. (Let (ExprA _typedExpressionIR) be argumentIR)

  2. Return ?(parameterTypeIR')

1. Else Phantom#1256

2. (Let ({ (id_param -> parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }) be _map<id, parameterTypeIR>')

3. Case analysis on argumentIR

  1. Case (% matches pattern `NameA%%`)

    1. (Let (NameA name _typedExpressionIR) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param -> parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }), name)

  2. Case (% matches pattern `NameAnyA%`)

    1. (Let (NameAnyA name) be argumentIR)

    2. Return $find_map<id, parameterTypeIR>(({ (id_param -> parameterTypeIR)*{id_param <- id_param*, parameterTypeIR <- parameterTypeIR*} }), name)

  3. Case (% matches pattern `AnyA`)

    1. Return ?(parameterTypeIR')

3. Else Phantom#1257

;; ../../../../spec-concrete/5.15.1-typing-call-convention.watsup:61.1-63.23
relation Expr_lvalue_ok: p, TC, (expressionIR (( _typeIR _ctk )))

1. Case analysis on expressionIR

  1. Case (% has type referenceExpression)

    1. (Let (NameE prefixedName) be (expressionIR as referenceExpression))

    2. (Let varTypeIR?{varTypeIR <- varTypeIR?} be $find_var(p, TC, prefixedName))

    3. If ((varTypeIR?{varTypeIR <- varTypeIR?} matches pattern (_))), then

      1. (Let ?((direction _typeIR' ctk _value?{_value <- _value?})) be varTypeIR?{varTypeIR <- varTypeIR?})

      2. If ((ctk matches pattern `DYN`)), then

        1. Case analysis on direction

          1. Case (% matches pattern `OUT`)

            1. The relation holds

          2. Case (% matches pattern `INOUT`)

            1. The relation holds

        1. Else Phantom#1258

      2. Else Phantom#1259

    3. Else Phantom#1260

  2. Case (% has type memberAccessExpressionIR)

    1. (Let memberAccessExpressionIR be (expressionIR as memberAccessExpressionIR))

    2. If ((memberAccessExpressionIR matches pattern `ExprAccE%%`)), then

      1. (Let (ExprAccE typedExpressionIR_base name) be memberAccessExpressionIR)

      2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

        1. (Let (_expressionIR (( typeIR_base _ctk' ))) be typedExpressionIR_base)

        2. (Let typeIR' be $canon(typeIR_base))

        3. If ((typeIR' has type headerStackTypeIR)), then

          1. (Let (HeaderStackT typeIR _nat) be (typeIR' as headerStackTypeIR))

          2. Case analysis on name

            1. Case (% = "next")

              1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

                1. The relation holds

              1. Else Phantom#1261

              2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

                1. The relation holds

              2. Else Phantom#1262

            2. Case (% = "last")

              1. If (((p = (BLOCK)) /\ $is_parser_blockKind(TC.BLOCK.KIND))), then

                1. The relation holds

              1. Else Phantom#1263

              2. If (((p = (LOCAL)) /\ $is_parser_state_localKind(TC.LOCAL.KIND))), then

                1. The relation holds

              2. Else Phantom#1264

          2. Else Phantom#1265

        3. Else Phantom#1266

        4. If (~$is_headerStackTypeIR($canon(typeIR_base))), then

          1. The relation holds

        4. Else Phantom#1267

      2. Else Phantom#1268

    2. Else Phantom#1269

  3. Case (% has type indexAccessExpressionIR)

    1. (Let indexAccessExpressionIR be (expressionIR as indexAccessExpressionIR))

    2. Case analysis on indexAccessExpressionIR

      1. Case (% matches pattern `ArrAccE%%`)

        1. (Let (ArrAccE typedExpressionIR_base typedExpressionIR_index) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

        2. Else Phantom#1270

      2. Case (% matches pattern `BitAccE%%%`)

        1. (Let (BitAccE typedExpressionIR_base typedExpressionIR_hi typedExpressionIR_lo) be indexAccessExpressionIR)

        2. If ((Expr_lvalue_ok: p TC |- typedExpressionIR_base holds)), then

          1. The relation holds

        2. Else Phantom#1271

1. Else Phantom#1272

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:6.1-7.12
syntax infer = 
   | `KNOWN%`(typeIR)
   | `UNKNOWN`()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:9.21-9.36
syntax constraint = map<tid, infer>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:11.1-11.41
def $empty_constraint(tid*{tid <- tid*})

1. Return ({ (tid -> (UNKNOWN))*{tid <- tid*} })

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:14.20-14.36
syntax inference = map<tid, typeIR>

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:20.1-20.61
def $infer(tid_infer*{tid_infer <- tid_infer*}, parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}, argumentIR*{argumentIR <- argumentIR*})

1. (Let constraint_init be $empty_constraint(tid_infer*{tid_infer <- tid_infer*}))

2. If ((|parameterTypeIR*{parameterTypeIR <- parameterTypeIR*}| = |argumentIR*{argumentIR <- argumentIR*}|)), then

  1. (Let constraint?{constraint <- constraint?} be $infer'(constraint_init, parameterTypeIR, argumentIR))*{argumentIR <- argumentIR*, constraint? <- constraint?*, parameterTypeIR <- parameterTypeIR*}

  2. If ((constraint?{constraint <- constraint?} matches pattern (_)))*{constraint? <- constraint?*}, then

    1. (Let ?(constraint_pair) be constraint?{constraint <- constraint?})*{constraint? <- constraint?*, constraint_pair <- constraint_pair*}

    2. (Let constraint'?{constraint' <- constraint'?} be $merge_constraints(constraint_init, constraint_pair*{constraint_pair <- constraint_pair*}))

    3. If ((constraint'?{constraint' <- constraint'?} matches pattern (_))), then

      1. (Let ?(constraint_inferred) be constraint'?{constraint' <- constraint'?})

      2. Return $resolve_constraint(constraint_inferred)

3. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:21.1-21.67
def $infer'(constraint, parameterTypeIR, argumentIR)

1. Case analysis on argumentIR

  1. Case (% matches pattern `ExprA%`)

    1. (Let (ExprA typedExpressionIR) be argumentIR)

    2. (Let (_direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR)

    3. (Let (_expressionIR (( typeIR_arg _ctk ))) be typedExpressionIR)

    4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

  2. Case (% matches pattern `NameA%%`)

    1. (Let (NameA name typedExpressionIR) be argumentIR)

    2. (Let (_direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR)

    3. (Let (_expressionIR (( typeIR_arg _ctk ))) be typedExpressionIR)

    4. Return $gen_constraint_type(constraint, typeIR_param, typeIR_arg)

  3. Case (% matches pattern `NameAnyA%`)

    1. (Let (NameAnyA name) be argumentIR)

    2. Return ?(constraint)

  4. Case (% matches pattern `AnyA`)

    1. Return ?(constraint)

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:23.1-23.67
def $gen_constraint_type(constraint'', typeIR'', typeIR''')

1. Case analysis on typeIR''

  1. Case (% has type baseTypeIR)

    1. (Let baseTypeIR be (typeIR'' as baseTypeIR))

    2. If ((typeIR''' has type baseTypeIR)), then

      1. (Let baseTypeIR' be (typeIR''' as baseTypeIR))

      2. If ((baseTypeIR = baseTypeIR')), then

        1. Return ?(constraint'')

  2. Case (% has type namedTypeIR)

    1. (Let namedTypeIR be (typeIR'' as namedTypeIR))

    2. Case analysis on namedTypeIR

      1. Case (% matches pattern `NameT%`)

        1. (Let (NameT tid_param) be namedTypeIR)

        2. If ($in_set<tid>(tid_param, $dom_map<tid, infer>(constraint''))), then

          1. Return ?($update_map<tid, infer>(constraint'', tid_param, (KNOWN typeIR''')))

      2. Case (% matches pattern `SpecT%%`)

        1. (Let (SpecT polyTypeDefIR_param typeIR_param*{typeIR_param <- typeIR_param*}) be namedTypeIR)

        2. If ((typeIR''' has type namedTypeIR)), then

          1. (Let namedTypeIR' be (typeIR''' as namedTypeIR))

          2. If ((namedTypeIR' matches pattern `SpecT%%`)), then

            1. (Let (SpecT polyTypeDefIR_arg typeIR_arg*{typeIR_arg <- typeIR_arg*}) be namedTypeIR')

            2. (Let typeIR_specialized_param be $specialize_typeDef((polyTypeDefIR_param as typeDefIR), typeIR_param*{typeIR_param <- typeIR_param*}))

            3. (Let typeIR_specialized_arg be $specialize_typeDef((polyTypeDefIR_arg as typeDefIR), typeIR_arg*{typeIR_arg <- typeIR_arg*}))

            4. If (($is_nominal_typeIR(typeIR_specialized_param) /\ $is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint?{constraint <- constraint?} be $gen_constraint_type(constraint'', typeIR_specialized_param, typeIR_specialized_arg))

              2. If ((constraint?{constraint <- constraint?} matches pattern (_))), then

                1. (Let ?(constraint_1) be constraint?{constraint <- constraint?})

                2. (Let constraint'?{constraint' <- constraint'?} be $gen_constraint_types(constraint_1, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}))

                3. If ((constraint'?{constraint' <- constraint'?} matches pattern (_))), then

                  1. (Let ?(constraint_2) be constraint'?{constraint' <- constraint'?})

                  2. Return ?(constraint_2)

            5. If ((~$is_nominal_typeIR(typeIR_specialized_param) /\ ~$is_nominal_typeIR(typeIR_specialized_arg))), then

              1. (Let constraint?{constraint <- constraint?} be $gen_constraint_type(constraint'', typeIR_specialized_param, typeIR_specialized_arg))

              2. If ((constraint?{constraint <- constraint?} matches pattern (_))), then

                1. (Let ?(constraint_1) be constraint?{constraint <- constraint?})

                2. Return ?(constraint_1)

  3. Case (% has type aliasTypeIR)

    1. (Let aliasTypeIR be (typeIR'' as aliasTypeIR))

    2. Case analysis on aliasTypeIR

      1. Case (% matches pattern `DefT%%`)

        1. (Let (DefT _tid typeIR_param) be aliasTypeIR)

        2. Return $gen_constraint_type(constraint'', typeIR_param, typeIR''')

      2. Case (% matches pattern `NewT%%`)

        1. (Let (NewT tid typeIR_param) be aliasTypeIR)

        2. If ((typeIR''' has type aliasTypeIR)), then

          1. (Let aliasTypeIR' be (typeIR''' as aliasTypeIR))

          2. If ((aliasTypeIR' matches pattern `NewT%%`)), then

            1. (Let (NewT tid' typeIR_arg) be aliasTypeIR')

            2. If ((tid = tid')), then

              1. Return $gen_constraint_type(constraint'', typeIR_param, typeIR_arg)

  4. Case (% has type listTypeIR)

    1. (Let (ListT typeIR_param) be (typeIR'' as listTypeIR))

    2. If ((typeIR''' has type listTypeIR)), then

      1. (Let (ListT typeIR_arg) be (typeIR''' as listTypeIR))

      2. Return $gen_constraint_type(constraint'', typeIR_param, typeIR_arg)

  5. Case (% has type tupleTypeIR)

    1. (Let (TupleT typeIR_param*{typeIR_param <- typeIR_param*}) be (typeIR'' as tupleTypeIR))

    2. If ((typeIR''' has type tupleTypeIR)), then

      1. (Let (TupleT typeIR_arg*{typeIR_arg <- typeIR_arg*}) be (typeIR''' as tupleTypeIR))

      2. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  6. Case (% has type headerStackTypeIR)

    1. (Let (HeaderStackT typeIR_param n_size) be (typeIR'' as headerStackTypeIR))

    2. If ((typeIR''' has type headerStackTypeIR)), then

      1. (Let (HeaderStackT typeIR_arg n_size') be (typeIR''' as headerStackTypeIR))

      2. If ((n_size = n_size')), then

        1. Return $gen_constraint_type(constraint'', typeIR_param, typeIR_arg)

  7. Case (% has type structTypeIR)

    1. (Let (StructT tid (typeIR_param id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) be (typeIR'' as structTypeIR))

    2. If ((typeIR''' has type structTypeIR)), then

      1. (Let (StructT tid' (typeIR_arg id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) be (typeIR''' as structTypeIR))

      2. If ((id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  8. Case (% has type headerTypeIR)

    1. (Let (HeaderT tid (typeIR_param id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) be (typeIR'' as headerTypeIR))

    2. If ((typeIR''' has type headerTypeIR)), then

      1. (Let (HeaderT tid' (typeIR_arg id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) be (typeIR''' as headerTypeIR))

      2. If ((id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  9. Case (% has type headerUnionTypeIR)

    1. (Let (HeaderUnionT tid (typeIR_param id_field)*{id_field <- id_field*, typeIR_param <- typeIR_param*}) be (typeIR'' as headerUnionTypeIR))

    2. If ((typeIR''' has type headerUnionTypeIR)), then

      1. (Let (HeaderUnionT tid' (typeIR_arg id_field')*{id_field' <- id_field'*, typeIR_arg <- typeIR_arg*}) be (typeIR''' as headerUnionTypeIR))

      2. If ((id_field = id_field'))*{id_field <- id_field*, id_field' <- id_field'*}, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  10. Case (% has type enumTypeIR)

    1. (Let enumTypeIR be (typeIR'' as enumTypeIR))

    2. If ((typeIR''' has type enumTypeIR)), then

      1. (Let enumTypeIR' be (typeIR''' as enumTypeIR))

      2. If ((enumTypeIR = enumTypeIR')), then

        1. Return ?(constraint'')

  11. Case (% has type externObjectTypeIR)

    1. (Let (ExternT tid ({ (rid -> routineTypeDefIR_param)*{rid <- rid*, routineTypeDefIR_param <- routineTypeDefIR_param*} })) be (typeIR'' as externObjectTypeIR))

    2. If ((typeIR''' has type externObjectTypeIR)), then

      1. (Let (ExternT tid' ({ (rid' -> routineTypeDefIR_arg)*{rid' <- rid'*, routineTypeDefIR_arg <- routineTypeDefIR_arg*} })) be (typeIR''' as externObjectTypeIR))

      2. If ((rid = rid'))*{rid <- rid*, rid' <- rid'*}, then

        1. If ((tid = tid')), then

          1. Return $gen_constraint_routines(constraint'', routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})

  12. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}) be (typeIR'' as parserObjectTypeIR))

    2. If ((typeIR''' has type parserObjectTypeIR)), then

      1. (Let (ParserT parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}) be (typeIR''' as parserObjectTypeIR))

      2. (Let (direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}

      3. (Let (direction' typeIR_arg _id' _value'?{_value' <- _value'?}) be parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}

      4. If ((direction' = direction))*{direction <- direction*, direction' <- direction'*}, then

        1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  13. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*}) be (typeIR'' as controlObjectTypeIR))

    2. If ((typeIR''' has type controlObjectTypeIR)), then

      1. (Let (ControlT parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*}) be (typeIR''' as controlObjectTypeIR))

      2. (Let (direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}

      3. (Let (direction' typeIR_arg _id' _value'?{_value' <- _value'?}) be parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}

      4. If ((direction' = direction))*{direction <- direction*, direction' <- direction'*}, then

        1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  14. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT tid typeIR_param*{typeIR_param <- typeIR_param*}) be (typeIR'' as packageObjectTypeIR))

    2. If ((typeIR''' has type packageObjectTypeIR)), then

      1. (Let (PackageT tid' typeIR_arg*{typeIR_arg <- typeIR_arg*}) be (typeIR''' as packageObjectTypeIR))

      2. If ((tid = tid')), then

        1. Return $gen_constraint_types(constraint'', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

  15. Case (% has type tableObjectTypeIR)

    1. (Let tableObjectTypeIR be (typeIR'' as tableObjectTypeIR))

    2. If ((typeIR''' has type tableObjectTypeIR)), then

      1. (Let tableObjectTypeIR' be (typeIR''' as tableObjectTypeIR))

      2. If ((tableObjectTypeIR = tableObjectTypeIR')), then

        1. Return ?(constraint'')

2. If ((typeIR''' has type aliasTypeIR)), then

  1. (Let aliasTypeIR be (typeIR''' as aliasTypeIR))

  2. If ((aliasTypeIR matches pattern `DefT%%`)), then

    1. (Let (DefT _tid typeIR_arg) be aliasTypeIR)

    2. Return $gen_constraint_type(constraint'', typeIR'', typeIR_arg)

3. Otherwise

  1. Return ?(constraint'')

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:24.1-24.70
def $gen_constraint_types(constraint, typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*})

1. If ((|typeIR_param*{typeIR_param <- typeIR_param*}| = |typeIR_arg*{typeIR_arg <- typeIR_arg*}|)), then

  1. (Let constraint'?{constraint' <- constraint'?} be $gen_constraint_type(constraint, typeIR_param, typeIR_arg))*{constraint'? <- constraint'?*, typeIR_arg <- typeIR_arg*, typeIR_param <- typeIR_param*}

  2. If ((constraint'?{constraint' <- constraint'?} matches pattern (_)))*{constraint'? <- constraint'?*}, then

    1. (Let ?(constraint_pair) be constraint'?{constraint' <- constraint'?})*{constraint'? <- constraint'?*, constraint_pair <- constraint_pair*}

    2. Return $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:25.1-28.16
def $gen_constraint_routine(constraint_0', routineTypeDefIR'', routineTypeDefIR''')

1. If ((routineTypeDefIR'' has type polyRoutineTypeDefIR)), then

  1. (Let (PolyTD routineTypeIR _tid*{_tid <- _tid*} _tid'*{_tid' <- _tid'*}) be (routineTypeDefIR'' as polyRoutineTypeDefIR))

  2. Case analysis on routineTypeIR

    1. Case (% matches pattern `ExternMethodT%%`)

      1. (Let (ExternMethodT parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} typeIR_ret_param) be routineTypeIR)

      2. If ((routineTypeDefIR''' has type polyRoutineTypeDefIR)), then

        1. (Let (PolyTD routineTypeIR' _tid''*{_tid'' <- _tid''*} _tid'''*{_tid''' <- _tid'''*}) be (routineTypeDefIR''' as polyRoutineTypeDefIR))

        2. If ((routineTypeIR' matches pattern `ExternMethodT%%`)), then

          1. (Let (ExternMethodT parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} typeIR_ret_arg) be routineTypeIR')

          2. (Let (direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}

          3. (Let (direction' typeIR_arg _id' _value'?{_value' <- _value'?}) be parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}

          4. If ((direction' = direction))*{direction <- direction*, direction' <- direction'*}, then

            1. (Let constraint?{constraint <- constraint?} be $gen_constraint_types(constraint_0', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}))

            2. If ((constraint?{constraint <- constraint?} matches pattern (_))), then

              1. (Let ?(constraint_1) be constraint?{constraint <- constraint?})

              2. (Let constraint'?{constraint' <- constraint'?} be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

              3. If ((constraint'?{constraint' <- constraint'?} matches pattern (_))), then

                1. (Let ?(constraint_2) be constraint'?{constraint' <- constraint'?})

                2. Return ?(constraint_2)

    2. Case (% matches pattern `ExternAbstractMethodT%%`)

      1. (Let (ExternAbstractMethodT parameterTypeIR_param*{parameterTypeIR_param <- parameterTypeIR_param*} typeIR_ret_param) be routineTypeIR)

      2. If ((routineTypeDefIR''' has type polyRoutineTypeDefIR)), then

        1. (Let (PolyTD routineTypeIR' _tid''*{_tid'' <- _tid''*} _tid'''*{_tid''' <- _tid'''*}) be (routineTypeDefIR''' as polyRoutineTypeDefIR))

        2. If ((routineTypeIR' matches pattern `ExternAbstractMethodT%%`)), then

          1. (Let (ExternAbstractMethodT parameterTypeIR_arg*{parameterTypeIR_arg <- parameterTypeIR_arg*} typeIR_ret_arg) be routineTypeIR')

          2. (Let (direction typeIR_param _id _value?{_value <- _value?}) be parameterTypeIR_param)*{_id <- _id*, _value? <- _value?*, direction <- direction*, parameterTypeIR_param <- parameterTypeIR_param*, typeIR_param <- typeIR_param*}

          3. (Let (direction' typeIR_arg _id' _value'?{_value' <- _value'?}) be parameterTypeIR_arg)*{_id' <- _id'*, _value'? <- _value'?*, direction' <- direction'*, parameterTypeIR_arg <- parameterTypeIR_arg*, typeIR_arg <- typeIR_arg*}

          4. If ((direction' = direction))*{direction <- direction*, direction' <- direction'*}, then

            1. (Let constraint?{constraint <- constraint?} be $gen_constraint_types(constraint_0', typeIR_param*{typeIR_param <- typeIR_param*}, typeIR_arg*{typeIR_arg <- typeIR_arg*}))

            2. If ((constraint?{constraint <- constraint?} matches pattern (_))), then

              1. (Let ?(constraint_1) be constraint?{constraint <- constraint?})

              2. (Let constraint'?{constraint' <- constraint'?} be $gen_constraint_type(constraint_1, typeIR_ret_param, typeIR_ret_arg))

              3. If ((constraint'?{constraint' <- constraint'?} matches pattern (_))), then

                1. (Let ?(constraint_2) be constraint'?{constraint' <- constraint'?})

                2. Return ?(constraint_2)

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:29.1-32.16
def $gen_constraint_routines(constraint, routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}, routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*})

1. If ((|routineTypeDefIR_param*{routineTypeDefIR_param <- routineTypeDefIR_param*}| = |routineTypeDefIR_arg*{routineTypeDefIR_arg <- routineTypeDefIR_arg*}|)), then

  1. (Let constraint'?{constraint' <- constraint'?} be $gen_constraint_routine(constraint, routineTypeDefIR_param, routineTypeDefIR_arg))*{constraint'? <- constraint'?*, routineTypeDefIR_arg <- routineTypeDefIR_arg*, routineTypeDefIR_param <- routineTypeDefIR_param*}

  2. If ((constraint'?{constraint' <- constraint'?} matches pattern (_)))*{constraint'? <- constraint'?*}, then

    1. (Let ?(constraint_pair) be constraint'?{constraint' <- constraint'?})*{constraint'? <- constraint'?*, constraint_pair <- constraint_pair*}

    2. Return $merge_constraints(constraint, constraint_pair*{constraint_pair <- constraint_pair*})

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:34.1-34.60
def $merge_constraint(constraint_pre, constraint_post)

1. (Let ({ tid_pre*{tid_pre <- tid_pre*} }) be $dom_map<tid, infer>(constraint_pre))

2. (Let ({ tid_post*{tid_post <- tid_post*} }) be $dom_map<tid, infer>(constraint_post))

3. If ($eq_set<tid>(({ tid_pre*{tid_pre <- tid_pre*} }), ({ tid_post*{tid_post <- tid_post*} }))), then

  1. Return $merge_constraint'(constraint_pre, constraint_post, tid_pre*{tid_pre <- tid_pre*}, ({ [] }))

4. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:35.1-35.79
def $merge_constraint'(constraint_pre, constraint_post, tid*{tid <- tid*}, constraint)

1. Case analysis on tid*{tid <- tid*}

  1. Case (% matches pattern [])

    1. Return ?(constraint)

  2. Case (% matches pattern _ :: _)

    1. (Let tid_h :: tid_t*{tid_t <- tid_t*} be tid*{tid <- tid*})

    2. If ((?((UNKNOWN)) = $find_map<tid, infer>(constraint_pre, tid_h))), then

      1. If ((?((UNKNOWN)) = $find_map<tid, infer>(constraint_post, tid_h))), then

        1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (UNKNOWN)))

        2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)

      2. (Let infer'?{infer' <- infer'?} be $find_map<tid, infer>(constraint_post, tid_h))

      3. If ((infer'?{infer' <- infer'?} matches pattern (_))), then

        1. (Let ?(infer) be infer'?{infer' <- infer'?})

        2. If ((infer matches pattern `KNOWN%`)), then

          1. (Let (KNOWN typeIR_post) be infer)

          2. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (KNOWN typeIR_post)))

          3. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)

    3. (Let infer'?{infer' <- infer'?} be $find_map<tid, infer>(constraint_pre, tid_h))

    4. If ((infer'?{infer' <- infer'?} matches pattern (_))), then

      1. (Let ?(infer) be infer'?{infer' <- infer'?})

      2. If ((infer matches pattern `KNOWN%`)), then

        1. (Let (KNOWN typeIR_pre) be infer)

        2. If ((?((UNKNOWN)) = $find_map<tid, infer>(constraint_post, tid_h))), then

          1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (KNOWN typeIR_pre)))

          2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)

        3. (Let infer'''?{infer''' <- infer'''?} be $find_map<tid, infer>(constraint_post, tid_h))

        4. If ((infer'''?{infer''' <- infer'''?} matches pattern (_))), then

          1. (Let ?(infer'') be infer'''?{infer''' <- infer'''?})

          2. If ((infer'' matches pattern `KNOWN%`)), then

            1. (Let (KNOWN typeIR_post) be infer'')

            2. Case analysis on (Sub_impl: typeIR_pre <: typeIR_post holds)

              1. Case true

                1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (KNOWN typeIR_post)))

                2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)

              2. Case false

                1. If ((Sub_impl: typeIR_post <: typeIR_pre holds)), then

                  1. (Let constraint_updated be $update_map<tid, infer>(constraint, tid_h, (KNOWN typeIR_pre)))

                  2. Return $merge_constraint'(constraint_pre, constraint_post, tid_t*{tid_t <- tid_t*}, constraint_updated)

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:36.1-36.62
def $merge_constraints(constraint_pre', constraint'''*{constraint''' <- constraint'''*})

1. Case analysis on constraint'''*{constraint''' <- constraint'''*}

  1. Case (% matches pattern [])

    1. Return ?(constraint_pre')

  2. Case (% matches pattern _ :: _)

    1. (Let constraint_post_h :: constraint_post_t*{constraint_post_t <- constraint_post_t*} be constraint'''*{constraint''' <- constraint'''*})

    2. (Let constraint'?{constraint' <- constraint'?} be $merge_constraint(constraint_pre', constraint_post_h))

    3. If ((constraint'?{constraint' <- constraint'?} matches pattern (_))), then

      1. (Let ?(constraint_pre_1) be constraint'?{constraint' <- constraint'?})

      2. (Let constraint''?{constraint'' <- constraint''?} be $merge_constraints(constraint_pre_1, constraint_post_t*{constraint_post_t <- constraint_post_t*}))

      3. If ((constraint''?{constraint'' <- constraint''?} matches pattern (_))), then

        1. (Let ?(constraint_pre_2) be constraint''?{constraint'' <- constraint''?})

        2. Return ?(constraint_pre_2)

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.2-typing-call-inference.watsup:38.1-38.49
def $resolve_constraint(({ (tid -> infer)*{infer <- infer*, tid <- tid*} }))

1. If ((infer matches pattern `KNOWN%`))*{infer <- infer*}, then

  1. (Let (KNOWN typeIR) be infer)*{infer <- infer*, typeIR <- typeIR*}

  2. Return ?(({ (tid -> typeIR)*{tid <- tid*, typeIR <- typeIR*} }))

2. Otherwise

  1. Return ?()

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:21.1-21.65
def $instantiable_extern(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:27.1-27.65
def $instantiable_parser(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (ANON))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_parser_blockKind(TC.BLOCK.KIND)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.LOCAL.KIND)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:36.1-36.66
def $instantiable_control(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return (instctxt = (ANON))

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.BLOCK.KIND)

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.LOCAL.KIND)

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:45.1-45.66
def $instantiable_package(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_package_blockKind(TC.BLOCK.KIND)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:52.1-52.64
def $instantiable_table(cursor, TC, instctxt)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return $is_control_blockKind(TC.BLOCK.KIND)

  3. Case (% matches pattern `LOCAL`)

    1. Return false

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:59.1-59.66
def $instantiable(p, TC, instctxt, typeIR)

1. Return $instantiable'(p, TC, instctxt, $canon(typeIR))

;; ../../../../spec-concrete/5.15.3-typing-constructor-call.watsup:60.1-60.67
def $instantiable'(p, TC, instctxt, typeIR)

1. Case analysis on typeIR

  1. Case (% has type externObjectTypeIR)

    1. (Let (ExternT _tid _map<rid, routineTypeDefIR>) be (typeIR as externObjectTypeIR))

    2. Return $instantiable_extern(p, TC, instctxt)

  2. Case (% has type parserObjectTypeIR)

    1. (Let (ParserT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as parserObjectTypeIR))

    2. Return $instantiable_parser(p, TC, instctxt)

  3. Case (% has type controlObjectTypeIR)

    1. (Let (ControlT _parameterTypeIR*{_parameterTypeIR <- _parameterTypeIR*}) be (typeIR as controlObjectTypeIR))

    2. Return $instantiable_control(p, TC, instctxt)

  4. Case (% has type packageObjectTypeIR)

    1. (Let (PackageT _tid _typeIR*{_typeIR <- _typeIR*}) be (typeIR as packageObjectTypeIR))

    2. Return $instantiable_package(p, TC, instctxt)

  5. Case (% has type tableObjectTypeIR)

    1. (Let (TableT _tid _typeIR) be (typeIR as tableObjectTypeIR))

    2. Return $instantiable_table(p, TC, instctxt)

2. Otherwise

  1. Return false

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:37.1-37.47
def $lvalue_as_expression(lvalue)

1. Case analysis on lvalue

  1. Case (% matches pattern `NameL%`)

    1. (Let (NameL prefixedName) be lvalue)

    2. Return ((NameE prefixedName) as expression)

  2. Case (% matches pattern `LvalueAccL%%`)

    1. (Let (LvalueAccL lvalue_base name) be lvalue)

    2. (Let expression_base be $lvalue_as_expression(lvalue_base))

    3. Return ((ExprAccE expression_base name) as expression)

  3. Case (% matches pattern `ArrAccL%%`)

    1. (Let (ArrAccL lvalue_base expression_index) be lvalue)

    2. (Let expression_base be $lvalue_as_expression(lvalue_base))

    3. Return ((ArrAccE expression_base expression_index) as expression)

  4. Case (% matches pattern `BitAccL%%%`)

    1. (Let (BitAccL lvalue_base expression_hi expression_lo) be lvalue)

    2. (Let expression_base be $lvalue_as_expression(lvalue_base))

    3. Return ((BitAccE expression_base expression_hi expression_lo) as expression)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:220.1-220.61
def $callable_builtin_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:247.1-247.53
def $callable_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))

  3. Case (% matches pattern `LOCAL`)

    1. Return (~$is_extern_method_localKind(TC.LOCAL.KIND) /\ ~$is_extern_abstract_method_localKind(TC.LOCAL.KIND))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:291.1-291.60
def $callable_extern_function(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:333.1-333.51
def $callable_action(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_action_localKind(TC.LOCAL.KIND) \/ $is_control_apply_method_localKind(TC.LOCAL.KIND))

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:364.1-364.59
def $callable_builtin_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return true

  2. Case (% matches pattern `BLOCK`)

    1. Return true

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:391.1-391.58
def $callable_extern_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:433.1-433.67
def $callable_extern_abstract_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return ($is_parser_blockKind(TC.BLOCK.KIND) \/ $is_control_blockKind(TC.BLOCK.KIND))

  3. Case (% matches pattern `LOCAL`)

    1. Return true

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:475.1-475.64
def $callable_parser_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_parser_state_localKind(TC.LOCAL.KIND)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:502.1-502.65
def $callable_control_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return $is_control_apply_method_localKind(TC.LOCAL.KIND)

;; ../../../../spec-concrete/5.15.4-typing-routine-call.watsup:529.1-529.63
def $callable_table_apply_method(cursor, TC)

1. Case analysis on cursor

  1. Case (% matches pattern `GLOBAL`)

    1. Return false

  2. Case (% matches pattern `BLOCK`)

    1. Return false

  3. Case (% matches pattern `LOCAL`)

    1. Return ($is_control_apply_method_localKind(TC.LOCAL.KIND) \/ $is_table_apply_method_localKind(TC.LOCAL.KIND))
