;;
;; L-value typing
;;
;; syntax lvalue
;;

;;; NameL prefixedName

rule Lvalue_ok/nameL:
  p TC |- NameL prefixedName : (NameL prefixedName) `( typeIR )
  -- if direction typeIR DYN eps = $find_var(p, TC, prefixedName)
  -- if direction = OUT \/ direction = INOUT

;;; LvalueAccL lvalue name

rule Lvalue_ok/lvalueaccL-stack-next-last:
  p TC |- LvalueAccL lvalue_base name : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header stack
  -- if HeaderStackT typeIR _ = $canon(typeIR_base)
  ---- ;; check that the field is "next" or "last"
  -- if name = "next" \/ name = "last"
  ---- ;; "next" and "last" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (LvalueAccL typedLvalueIR_base name) `( typeIR )

rule Lvalue_ok/lvalueaccL-struct:
  p TC |- LvalueAccL lvalue_base name : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a struct
  -- if StructT _ (typeIR_f name_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (LvalueAccL typedLvalueIR_base name) `( typeIR )

rule Lvalue_ok/lvalueaccL-header:
  p TC |- LvalueAccL lvalue_base name : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header
  -- if HeaderT _ (typeIR_f name_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (LvalueAccL typedLvalueIR_base name) `( typeIR )

rule Lvalue_ok/lvalueaccL-union:
  p TC |- LvalueAccL lvalue_base name : typedLvalueIR
  ---- ;; check base lvaue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header
  -- if HeaderUnionT _ (typeIR_f name_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (name_f, typeIR_f)*)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (LvalueAccL typedLvalueIR_base name) `( typeIR )

;;; ArrAccL lvalue expression

rule Lvalue_ok/arraccL-stack-lctk:
  p TC |- ArrAccL lvalue_base expression_index : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; check index expression
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  -- if _ `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; if the index is local compile-time known, then it must be in range
  -- if ctk_index = LCTK
  -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
  -- if n_index = $to_number(value_index)
  -- if $(n_index < n_size)
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (ArrAccL typedLvalueIR_base typedExpressionIR_index_reduced)
          `( typeIR )

rule Lvalue_ok/arraccL-stack-non-lctk:
  p TC |- ArrAccL lvalue_base expression_index : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the lvalue is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; check index expression
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  -- if _ `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; if the index is not local compile-time known, no range check is done
  -- if ctk_index =/= LCTK
  ---- ;; create typed lvalue
  -- if typedLvalueIR
      = (ArrAccL typedLvalueIR_base typedExpressionIR_index_reduced)
          `( typeIR )

;;; BitAccL lvalue expression expression

rule Lvalue_ok/bitaccL:
  p TC |- BitAccL lvalue_base expression_hi expression_lo : typedLvalueIR
  ---- ;; check base lvalue
  -- Lvalue_ok: p TC |- lvalue_base : typedLvalueIR_base
  -- if _ `( typeIR_base ) = typedLvalueIR_base
  ---- ;; check that the base lvalue is compatible
  -- if $compat_bitslice_base(typeIR_base)
  ---- ;; check index expressions
  -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
  -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
  ---- ;; check that the indices are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_hi_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_hi,
          def $compat_bitslice_index
        )
  -- if typedExpressionIR_lo_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_lo,
          def $compat_bitslice_index
        )
  ---- ;; fetch index annotations
  -- if _ `( typeIR_hi_reduced ctk_hi_reduced )
      = typedExpressionIR_hi_reduced
  -- if _ `( typeIR_lo_reduced ctk_lo_reduced )
      = typedExpressionIR_lo_reduced
  ---- ;; check that the indices are local compile-time known
  -- if ctk_hi_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
  -- if n_hi = $to_number(value_hi)
  -- if ctk_lo_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
  -- if n_lo = $to_number(value_lo)
  ---- ;; check that the slice is valid
  -- if $is_valid_bitslice(typeIR_base, n_lo, n_hi)
  ---- ;; create typed lvalue
  -- if n' = $(n_hi - n_lo + 1)
  -- if typeIR = FBitT n'
  -- if typedLvalueIR
      = (BitAccL typedLvalueIR_base
          typedExpressionIR_hi_reduced typedExpressionIR_lo_reduced)
          `( typeIR )
