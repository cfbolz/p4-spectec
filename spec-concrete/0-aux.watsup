;;
;; Metavariables for int, nat, bool, and text
;;

var b : bool

var i : int

var n : nat
var w : nat

var t : text

;;
;; General nat functions
;;

dec $sum(nat*) : nat

dec $max(nat*) : nat

dec $min(nat*) : nat

;;
;; General text functions
;;

dec $int_to_text(int) : text

dec $concat_text(text*) : text
def $concat_text(eps) = ""
def $concat_text(t :: t'*) = t ++ $concat_text(t'*)

dec $strip_prefix(text, text) : text
dec $strip_suffix(text, text) : text

;;
;; General sequence functions
;;

dec $init_(nat) : nat*
def $init_(0) = eps
def $init_(n) = n' :: $init_(n')
  -- if n =/= 0
  -- if n' = $(n - 1)

dec $repeat_<X>(X, nat) : X*
def $repeat_<X>(X, 0) = eps
def $repeat_<X>(X, n) = X ++ $repeat_<X>(X, n')
  -- if n =/= 0
  -- if n' = $(n - 1)

dec $rev_<X>(X*) : X*

dec $concat_<X>((X*)*) : X*

dec $partition_<X>(X*, nat) : (X*, X*)

dec $assoc_<X, Y>(X, (X, Y)*) : Y?

dec $distinct_<K>(K*) : bool

;;
;; General set functions
;;

syntax set<K> = `{ K* }

dec $empty_set<K> : set<K>
def $empty_set<K> = `{ eps }

dec $in_set<K>(K, set<K>) : bool
def $in_set<K>(K, `{ K'* }) = K <- K'*

dec $intersect_set<K>(set<K>, set<K>) : set<K>

dec $union_set<K>(set<K>, set<K>) : set<K>

dec $unions_set<K>(set<K>*) : set<K>

dec $diff_set<K>(set<K>, set<K>) : set<K>

dec $sub_set<K>(set<K>, set<K>) : bool

dec $eq_set<K>(set<K>, set<K>) : bool

;;
;; General map functions
;;

syntax pair<K, V> = K -> V

;; (TODO) parser fails to recognize set<pair<K, V>>
syntax map<K, V> = set< pair<K, V> >

dec $empty_map<K, V> : map<K, V>
def $empty_map<K, V> = `{ eps }

dec $dom_map<K, V>(map<K, V>) : set<K>
def $dom_map<K, V>(`{ (K -> V)* }) = `{ K* }

dec $find_map<K, V>(map<K, V>, K) : V?

dec $find_maps<K, V>(map<K, V>*, K) : V?

dec $add_map<K, V>(map<K, V>, K, V) : map<K, V>

dec $adds_map<K, V>(map<K, V>, K*, V*) : map<K, V>

dec $update_map<K, V>(map<K, V>, K, V) : map<K, V>
