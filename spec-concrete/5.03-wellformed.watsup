;;
;; Relations for well-formedness
;;

relation Type_wf:
  bound |- typeIR
  hint(input %0 %1)

relation TypeDef_wf:
  bound |- typeDefIR
  hint(input %0 %1)

relation ParameterType_wf:
  bound |- parameterTypeIR
  hint(input %0 %1)

relation ParameterTypes_wf:
  bound |- parameterTypeIR*
  hint(input %0 %1)

relation RoutineType_wf:
  bound |- routineTypeIR
  hint(input %0 %1)

relation RoutineTypeDef_wf:
  bound |- routineTypeDefIR
  hint(input %0 %1)

relation ConstructorParameterType_wf:
  bound |- parameterTypeIR
  hint(input %0 %1)

relation ConstructorParameterTypes_wf:
  bound |- parameterTypeIR*
  hint(input %0 %1)

relation ConstructorType_wf:
  bound |- constructorTypeIR
  hint(input %0 %1)

relation ConstructorTypeDef_wf:
  bound |- constructorTypeDefIR
  hint(input %0 %1)

;;
;;;; Well-formedness of parameter types
;;

rule ParameterType_wf/default-empty-extern:
  bound |- NO typeIR _ eps
  -- Type_wf: bound |- typeIR
  -- if $is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-none-not-extern:
  bound |- direction typeIR _ eps
  -- Type_wf: bound |- typeIR
  -- if ~$is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-some-extern:
  bound |- NO typeIR _ value
  -- Type_wf: bound |- typeIR
  -- if $is_extern_object_typeIR($canon(typeIR))

rule ParameterType_wf/default-some-not-extern:
  bound |- direction typeIR _ value
  -- Type_wf: bound |- typeIR
  -- if ~$is_extern_object_typeIR($canon(typeIR))
  -- if direction = IN \/ direction = NO

rule ParameterTypes_wf:
  bound |- parameterTypeIR*
  -- if (_ _ id _ = parameterTypeIR)*
  -- if $distinct_<id>(id*)
  -- (ParameterType_wf: bound |- parameterTypeIR)*

;;
;;;; Well-formedness of types
;;

;;; Base types

rule Type_wf/basetype:
  bound |- baseTypeIR

;;; Named types

rule Type_wf/tid:
  bound |- NameT tid
  -- if $in_set<tid>(tid, bound)

rule Type_wf/spectype:
  bound |- SpecT polyTypeDefIR typeIR_arg*
  -- if typeIR = $specialize_typeDef(polyTypeDefIR, typeIR_arg*)
  -- Type_wf: bound |- typeIR

;;; Alias types

dec $nestable_typedef(typeIR) : bool
dec $nestable'_typedef(typeIR) : bool

def $nestable_typedef(typeIR) = $nestable'_typedef($canon(typeIR))
def $nestable'_typedef(BoolT) = true
def $nestable'_typedef(ErrT) = true
def $nestable'_typedef(StrT) = true
def $nestable'_typedef(numberTypeIR) = true
def $nestable'_typedef(NameT _) = true
def $nestable'_typedef(NewT _ _) = true
def $nestable'_typedef(dataTypeIR) = true
def $nestable'_typedef(objectTypeIR) = ~$is_table_object_typeIR(objectTypeIR)
def $nestable'_typedef(_) = false
  -- otherwise

rule Type_wf/typedeftype:
  bound |- DefT _ typeIR
  -- if $nestable_typedef(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_new(typeIR) : bool
dec $nestable'_new(typeIR) : bool

def $nestable_new(typeIR) = $nestable'_new($canon(typeIR))
def $nestable'_new(BoolT) = true
def $nestable'_new(FBitT _) = true
def $nestable'_new(FIntT _) = true
def $nestable'_new(NameT _) = true
def $nestable'_new(NewT _ _) = true
def $nestable'_new(_) = false
  -- otherwise

rule Type_wf/newtype:
  bound |- NewT _ typeIR
  -- if $nestable_new(typeIR)
  -- Type_wf: bound |- typeIR 

;;; Data types

dec $nestable_list(typeIR) : bool
dec $nestable'_list(typeIR) : bool

def $nestable_list(typeIR) = $nestable'_list($canon(typeIR))
def $nestable'_list(BoolT) = true
def $nestable'_list(ErrT) = true
def $nestable'_list(MatchKindT) = true
def $nestable'_list(StrT) = true
def $nestable'_list(numberTypeIR) = true
def $nestable'_list(NameT _) = true
def $nestable'_list(NewT _ _) = true
def $nestable'_list(dataTypeIR) = true
def $nestable'_list(_) = false
  -- otherwise

rule Type_wf/listttype:
  bound |- ListT typeIR
  -- if $nestable_list(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_tuple(typeIR) : bool
dec $nestable'_tuple(typeIR) : bool

def $nestable_tuple(typeIR) = $nestable'_tuple($canon(typeIR))
def $nestable'_tuple(BoolT) = true
def $nestable'_tuple(ErrT) = true
def $nestable'_tuple(FIntT _) = true
def $nestable'_tuple(FBitT _) = true
def $nestable'_tuple(VBitT _) = true
def $nestable'_tuple(NameT _) = true
def $nestable'_tuple(NewT _ _) = true
def $nestable'_tuple(TupleT _) = true
def $nestable'_tuple(HeaderStackT typeIR _) = true
def $nestable'_tuple(StructT _ _) = true
def $nestable'_tuple(HeaderT _ _) = true
def $nestable'_tuple(HeaderUnionT _ _) = true
def $nestable'_tuple(EnumT _ _) = true
def $nestable'_tuple(SEnumT _ _ _) = true
def $nestable'_tuple(_) = false
  -- otherwise

rule Type_wf/tupletype:
  bound |- TupleT typeIR*
  -- if $nestable_tuple(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_headerstack(typeIR) : bool
dec $nestable'_headerstack(typeIR) : bool

def $nestable_headerstack(typeIR) = $nestable'_headerstack($canon(typeIR))
def $nestable'_headerstack(NameT _) = true
def $nestable'_headerstack(HeaderT _ _) = true
def $nestable'_headerstack(HeaderUnionT _ _) = true
def $nestable'_headerstack(_) = false
  -- otherwise

rule Type_wf/stacktype:
  bound |- HeaderStackT typeIR _
  -- if $nestable_headerstack(typeIR)
  -- Type_wf: bound |- typeIR

dec $nestable_struct(typeIR) : bool
dec $nestable'_struct(typeIR) : bool

def $nestable_struct(typeIR) = $nestable'_struct($canon(typeIR))
def $nestable'_struct(BoolT) = true
def $nestable'_struct(ErrT) = true
def $nestable'_struct(FIntT _) = true
def $nestable'_struct(FBitT _) = true
def $nestable'_struct(VBitT _) = true
def $nestable'_struct(NameT _) = true
def $nestable'_struct(NewT _ _) = true
def $nestable'_struct(TupleT _) = true
def $nestable'_struct(HeaderStackT typeIR _) = true
def $nestable'_struct(StructT _ _) = true
def $nestable'_struct(HeaderT _ _) = true
def $nestable'_struct(HeaderUnionT _ _) = true
def $nestable'_struct(EnumT _ _) = true
def $nestable'_struct(SEnumT _ _ _) = true
def $nestable'_struct(_) = false
  -- otherwise

rule Type_wf/structtype:
  bound |- StructT _ (typeIR id)*
  -- if $distinct_<id>(id*)
  -- if $nestable_struct(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_header(typeIR) : bool
dec $nestable'_header(typeIR) : bool
dec $nestable_struct_in_header(typeIR) : bool
dec $nestable'_struct_in_header(typeIR) : bool

def $nestable_header(typeIR) = $nestable'_header($canon(typeIR))
def $nestable'_header(BoolT) = true
def $nestable'_header(FIntT _) = true
def $nestable'_header(FBitT _) = true
def $nestable'_header(VBitT _) = true
def $nestable'_header(NameT _) = true
def $nestable'_header(NewT _ _) = true
def $nestable'_header(SEnumT _ _ _) = true
def $nestable'_header(StructT _ (typeIR _)*) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_header(_) = false
  -- otherwise

def $nestable_struct_in_header(typeIR)
  = $nestable'_struct_in_header($canon(typeIR))
def $nestable'_struct_in_header(BoolT) = true
def $nestable'_struct_in_header(FIntT _) = true
def $nestable'_struct_in_header(FBitT _) = true
def $nestable'_struct_in_header(NameT _) = true
def $nestable'_struct_in_header(NewT _ _) = true
def $nestable'_struct_in_header(SEnumT _ _ _) = true
def $nestable'_struct_in_header(StructT _ (typeIR _)*) = true
  -- if $nestable_struct_in_header(typeIR)*
def $nestable'_struct_in_header(_) = false
  -- otherwise

rule Type_wf/headertype:
  bound |- HeaderT _ (typeIR id)*
  -- if $distinct_<id>(id*)
  -- if $nestable_header(typeIR)*
  -- (Type_wf: bound |- typeIR)*

dec $nestable_headerunion(typeIR) : bool
dec $nestable'_headerunion(typeIR) : bool

def $nestable_headerunion(typeIR)
  = $nestable'_headerunion($canon(typeIR))
def $nestable'_headerunion(NameT _) = true
def $nestable'_headerunion(NewT _ _) = true
def $nestable'_headerunion(HeaderT _ _) = true
def $nestable'_headerunion(_) = false
  -- otherwise

rule Type_wf/headeruniontype:
  bound |- HeaderUnionT _ (typeIR id)*
  -- if $distinct_<id>(id*)
  -- if $nestable_headerunion(typeIR)*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/enumtype:
  bound |- EnumT _ id*
  -- if $distinct_<id>(id*)

dec $nestable_serenum(typeIR) : bool
dec $nestable'_serenum(typeIR) : bool
dec $nestable_new_in_serenum(typeIR) : bool
dec $nestable_new_in_serenum'(typeIR) : bool

def $nestable_serenum(typeIR)
  = $nestable'_serenum($canon(typeIR))
def $nestable'_serenum(FIntT _) = true
def $nestable'_serenum(FBitT _) = true
def $nestable'_serenum(NameT _) = true
def $nestable'_serenum(NewT _ typeIR)
  = $nestable_new_in_serenum(typeIR)
def $nestable'_serenum(_) = false
  -- otherwise

def $nestable_new_in_serenum(typeIR)
  = $nestable_new_in_serenum'($canon(typeIR))
def $nestable_new_in_serenum'(FIntT _) = true
def $nestable_new_in_serenum'(FBitT _) = true
def $nestable_new_in_serenum'(NameT _) = true
def $nestable_new_in_serenum'(NewT _ _) = true
def $nestable_new_in_serenum'(_) = false
  -- otherwise

rule Type_wf/serenumtype:
  bound |- SEnumT _ typeIR (id _)*
  -- if $distinct_<id>(id*)
  -- if $nestable_serenum(typeIR)
  -- Type_wf: bound |- typeIR

;;; Object types

rule Type_wf/externtype:
  bound |- ExternT _ (`{ (_ -> routineTypeDefIR)* })
  -- (RoutineTypeDef_wf: bound |- routineTypeDefIR)*

rule Type_wf/parsertype:
  bound |- ParserT parameterTypeIR*
  -- ParameterTypes_wf: bound |- parameterTypeIR*

rule Type_wf/controltype:
  bound |- ControlT parameterTypeIR*
  -- ParameterTypes_wf: bound |- parameterTypeIR*

rule Type_wf/packagetype:
  bound |- PackageT tid typeIR*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/tabletype:
  bound |- TableT _ typeIR
  -- if TableStructT _ _ = $canon(typeIR)
  -- Type_wf: bound |- typeIR

;;; Synthesized types

rule Type_wf/defaulttype:
  bound |- DefaultT

rule Type_wf/sequencetype:
  bound |- SeqT typeIR*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/sequencedefaulttype:
  bound |- SeqDefaultT typeIR*
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recordtype:
  bound |- RecordT (typeIR id)*
  -- if $distinct_<id>(id*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/recorddefaulttype:
  bound |- RecordDefaultT (typeIR id)*
  -- if $distinct_<id>(id*)
  -- (Type_wf: bound |- typeIR)*

rule Type_wf/invalidtype:
  bound |- InvalidHeaderT

dec $nestable_set(typeIR) : bool
dec $nestable'_set(typeIR) : bool
dec $nestable_tuple_in_set(typeIR) : bool
dec $nestable'_tuple_in_set(typeIR) : bool
dec $nestable_sequence_in_set(typeIR) : bool
dec $nestable'_sequence_in_set(typeIR) : bool

def $nestable_set(typeIR) = $nestable'_set($canon(typeIR))
def $nestable'_set(BoolT) = true
def $nestable'_set(ErrT) = true
def $nestable'_set(FIntT _) = true
def $nestable'_set(FBitT _) = true
def $nestable'_set(NameT _) = true
def $nestable'_set(NewT _ _) = true
def $nestable'_set(TupleT typeIR*) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_set(EnumT _ _) = true
def $nestable'_set(SEnumT _ _ _) = true
def $nestable'_set(SeqT typeIR*) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_set(_) = false
  -- otherwise

def $nestable_tuple_in_set(typeIR)
  = $nestable'_tuple_in_set($canon(typeIR))
def $nestable'_tuple_in_set(BoolT) = true
def $nestable'_tuple_in_set(FIntT _) = true
def $nestable'_tuple_in_set(FBitT _) = true
def $nestable'_tuple_in_set(NameT _) = true
def $nestable'_tuple_in_set(NewT _ _) = true
def $nestable'_tuple_in_set(TupleT typeIR*) = true
  -- if $nestable_tuple_in_set(typeIR)*
def $nestable'_tuple_in_set(EnumT _ _) = true
def $nestable'_tuple_in_set(SEnumT _ _ _) = true
def $nestable'_tuple_in_set(_) = false
  -- otherwise

def $nestable_sequence_in_set(typeIR)
  = $nestable'_sequence_in_set($canon(typeIR))
def $nestable'_sequence_in_set(BoolT) = true
def $nestable'_sequence_in_set(FIntT _) = true
def $nestable'_sequence_in_set(FBitT _) = true
def $nestable'_sequence_in_set(NameT _) = true
def $nestable'_sequence_in_set(NewT _ _) = true
def $nestable'_sequence_in_set(TupleT typeIR*) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(EnumT _ _) = true
def $nestable'_sequence_in_set(SEnumT _ _ _) = true
def $nestable'_sequence_in_set(SeqT typeIR*) = true
  -- if $nestable_sequence_in_set(typeIR)*
def $nestable'_sequence_in_set(_) = false
  -- otherwise

rule Type_wf/settype:
  bound |- SetT typeIR
  -- if $nestable_set(typeIR)
  -- Type_wf: bound |- typeIR

rule Type_wf/tableenumtype:
  bound |- TableEnumT _ id*
  -- if $distinct_<id>(id*)

rule Type_wf/tablestructtype:
  bound |- TableStructT _ _

;;
;;;; Well-formedness of type definitions
;;

dec $definable_type_mono(typeIR) : bool

def $definable_type_mono(NameT _) = true
def $definable_type_mono(aliasTypeIR) = true
def $definable_type_mono(EnumT _ _) = true
def $definable_type_mono(SEnumT _ _ _) = true
def $definable_type_mono(TableT _ _) = true
def $definable_type_mono(_) = false
  -- otherwise

rule TypeDef_wf/mono:
  bound |- MonoTD typeIR
  -- if $definable_type_mono(typeIR)
  -- Type_wf: bound |- typeIR

dec $definable_type_poly(typeIR) : bool

def $definable_type_poly(TupleT _) = true
def $definable_type_poly(HeaderStackT _ _) = true
def $definable_type_poly(HeaderT _ _) = true
def $definable_type_poly(HeaderUnionT _ _) = true
def $definable_type_poly(StructT _ _) = true
def $definable_type_poly(ExternT _ _) = true
def $definable_type_poly(ParserT _) = true
def $definable_type_poly(ControlT _) = true
def $definable_type_poly(PackageT _ _) = true
def $definable_type_poly(_) = false
  -- otherwise

rule TypeDef_wf/poly:
  bound |- PolyTD typeIR tid_expl* tid_impl*
  -- if $definable_type_poly(typeIR)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- Type_wf: bound_inner |- typeIR

;;
;;;; Well-formedness of routine types
;;

;;; Function types

rule RoutineType_wf/builtinfunction:
  bound |- BuiltinFuncT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_function(direction, typeIR) : bool
dec $nestable_function'(direction, typeIR) : bool

def $nestable_function(direction, typeIR)
  = $nestable_function'(direction, $canon(typeIR))
def $nestable_function'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_function'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_function'(direction, objectTypeIR) = false
def $nestable_function'(_, _) = true
  -- otherwise

rule RoutineType_wf/functiontype:
  bound |- FuncT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_function(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $directionless_trailing(direction*) : bool
dec $directionless_trailing'(direction*, bool) : bool

def $directionless_trailing(direction*)
  = $directionless_trailing'($rev_<direction>(direction*), true)

def $directionless_trailing'(eps, _) = true
def $directionless_trailing'(NO :: direction_t*, true)
  = $directionless_trailing'(direction_t*, true)
def $directionless_trailing'(NO :: direction_t*, false) = false
def $directionless_trailing'(direction_h :: direction_t*, _)
  = $directionless_trailing'(direction_t*, false)
  -- if direction_h =/= NO

dec $nestable_action(direction, typeIR) : bool
dec $nestable_action'(direction, typeIR) : bool

def $nestable_action(direction, typeIR)
  = $nestable_action'(direction, $canon(typeIR))
def $nestable_action'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_action'(_, IntT) = false
def $nestable_action'(_, objectTypeIR) = false
def $nestable_action'(_, _) = true
  -- otherwise

rule RoutineType_wf/actiontype:
  bound |- ActionT parameterTypeIR*
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)*
  -- if $directionless_trailing(direction*)
  -- if $nestable_action(direction, typeIR)*

dec $nestable_externfunction(direction, typeIR) : bool
dec $nestable_externfunction'(direction, typeIR) : bool

def $nestable_externfunction(direction, typeIR)
  = $nestable_externfunction'(direction, $canon(typeIR))
def $nestable_externfunction'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_externfunction'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_externfunction'(direction, ParserT _) = false
def $nestable_externfunction'(direction, ControlT _) = false
def $nestable_externfunction'(direction, PackageT _ _) = false
def $nestable_externfunction'(direction, TableT _ _) = false
def $nestable_externfunction'(_, _) = true
  -- otherwise

rule RoutineType_wf/externfunctiontype:
  bound |- ExternFuncT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externfunction(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

;;; Method types

rule RoutineType_wf/builtinmethod:
  bound |- BuiltinMethodT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externmethod(direction, typeIR) : bool
dec $nestable_externmethod'(direction, typeIR) : bool

def $nestable_externmethod(direction, typeIR)
  = $nestable_externmethod'(direction, $canon(typeIR))
def $nestable_externmethod'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_externmethod'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_externmethod'(direction, ParserT _) = false
def $nestable_externmethod'(direction, ControlT _) = false
def $nestable_externmethod'(direction, PackageT _ _) = false
def $nestable_externmethod'(direction, TableT _ _) = false
def $nestable_externmethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/externmethod:
  bound |- ExternMethodT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_externabstractmethod(direction, typeIR) : bool
dec $nestable_externabstractmethod'(direction, typeIR) : bool

def $nestable_externabstractmethod(direction, typeIR)
  = $nestable_externabstractmethod'(direction, $canon(typeIR))
def $nestable_externabstractmethod'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_externabstractmethod'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_externabstractmethod'(direction, ParserT _) = false
def $nestable_externabstractmethod'(direction, ControlT _) = false
def $nestable_externabstractmethod'(direction, PackageT _ _) = false
def $nestable_externabstractmethod'(direction, TableT _ _) = false
def $nestable_externabstractmethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/externabstractmethod:
  bound |- ExternAbstractMethodT parameterTypeIR* typeIR_ret
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_externabstractmethod(direction, typeIR)*
  -- Type_wf: bound |- typeIR_ret

dec $nestable_parserapplymethod(direction, typeIR) : bool
dec $nestable_parserapplymethod'(direction, typeIR) : bool

def $nestable_parserapplymethod(direction, typeIR)
  = $nestable_parserapplymethod'(direction, $canon(typeIR))
def $nestable_parserapplymethod'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_parserapplymethod'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_parserapplymethod'(direction, ParserT _) = false
def $nestable_parserapplymethod'(direction, ControlT _) = false
def $nestable_parserapplymethod'(direction, PackageT _ _) = false
def $nestable_parserapplymethod'(direction, TableT _ _) = false
def $nestable_parserapplymethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/parserapplymethod:
  bound |- ParserApplyMethodT parameterTypeIR*
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_parserapplymethod(direction, typeIR)*

dec $nestable_controlapplymethod(direction, typeIR) : bool
dec $nestable_controlapplymethod'(direction, typeIR) : bool

def $nestable_controlapplymethod(direction, typeIR)
  = $nestable_controlapplymethod'(direction, $canon(typeIR))
def $nestable_controlapplymethod'(direction, StrT) = false
  -- if direction =/= NO
def $nestable_controlapplymethod'(direction, IntT) = false
  -- if direction =/= NO
def $nestable_controlapplymethod'(direction, ParserT _) = false
def $nestable_controlapplymethod'(direction, PackageT _ _) = false
def $nestable_controlapplymethod'(direction, TableT _ _) = false
def $nestable_controlapplymethod'(_, _) = true
  -- otherwise

rule RoutineType_wf/controlapplymethod:
  bound |- ControlApplyMethodT parameterTypeIR*
  -- ParameterTypes_wf: bound |- parameterTypeIR*
  -- if (direction typeIR _ _ = parameterTypeIR)* 
  -- if $nestable_controlapplymethod(direction, typeIR)*

rule RoutineType_wf/tableapplymethod:
  bound |- TableApplyMethodT (TableStructT _ _)

;;
;;;; Well-formedness of routine type definitions
;;

dec $definable_routine_mono(routineTypeIR) : bool

def $definable_routine_mono(BuiltinFuncT _ _) = true
def $definable_routine_mono(ActionT _) = true
def $definable_routine_mono(BuiltinMethodT _ _) = true
def $definable_routine_mono(ParserApplyMethodT _ ) = true
def $definable_routine_mono(ControlApplyMethodT _ ) = true
def $definable_routine_mono(TableApplyMethodT _) = true
def $definable_routine_mono(_) = false
  -- otherwise

rule RoutineTypeDef_wf/mono:
  bound |- MonoTD routineTypeIR
  -- if $definable_routine_mono(routineTypeIR)
  -- RoutineType_wf: bound |- routineTypeIR

dec $definable_routine_poly(routineTypeIR) : bool

def $definable_routine_poly(FuncT _ _) = true
def $definable_routine_poly(ExternFuncT _ _) = true
def $definable_routine_poly(ExternMethodT _ _) = true
def $definable_routine_poly(ExternAbstractMethodT _ _) = true
def $definable_routine_poly(_) = false
  -- otherwise

rule RoutineTypeDef_wf/poly:
  bound |- PolyTD routineTypeIR tid_expl* tid_impl*
  -- if $definable_routine_poly(routineTypeIR)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- RoutineType_wf: bound_inner |- routineTypeIR

;;
;;;; Well-formedness of constructor paramter types
;;

rule ConstructorParameterType_wf:
  bound |- NO typeIR _ _
  -- Type_wf: bound |- typeIR

rule ConstructorParameterTypes_wf:
  bound |- parameterTypeIR*
  -- if (_ _ id _ = parameterTypeIR)*
  -- if $distinct_<id>(id*)
  -- (ConstructorParameterType_wf: bound |- parameterTypeIR)*

;;
;;;; Well-formedness of constructor types
;;

dec $nestable_constructor_extern(typeIR) : bool
dec $nestable'_constructor_extern(typeIR) : bool

def $nestable_constructor_extern(typeIR)
  = $nestable'_constructor_extern($canon(typeIR))
def $nestable_constructor_extern(ParserT _) = false
def $nestable'_constructor_extern(ControlT _) = false
def $nestable'_constructor_extern(PackageT _ _) = false
def $nestable'_constructor_extern(TableT _ _) = false
def $nestable'_constructor_extern(_) = true
  -- otherwise

rule ConstructorType_wf/externtype:
  bound |- ConstructorT parameterTypeIR* typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if ExternT _ _ = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_extern(typeIR)*

dec $nestable_constructor_parser(typeIR) : bool
dec $nestable'_constructor_parser(typeIR) : bool

def $nestable_constructor_parser(typeIR)
  = $nestable'_constructor_parser($canon(typeIR))
def $nestable'_constructor_parser(ControlT _) = false
def $nestable'_constructor_parser(PackageT _ _) = false
def $nestable'_constructor_parser(TableT _ _) = false
def $nestable'_constructor_parser(_) = true
  -- otherwise

rule ConstructorType_wf/parsertype:
  bound |- ConstructorT parameterTypeIR* typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if ParserT _ = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_parser(typeIR)*

dec $nestable_constructor_control(typeIR) : bool
dec $nestable'_constructor_control(typeIR) : bool

def $nestable_constructor_control(typeIR)
  = $nestable'_constructor_control($canon(typeIR))
def $nestable'_constructor_control(ParserT _) = false
def $nestable'_constructor_control(PackageT _ _) = false
def $nestable'_constructor_control(TableT _ _) = false
def $nestable'_constructor_control(_) = true
  -- otherwise

rule ConstructorType_wf/controltype:
  bound |- ConstructorT parameterTypeIR* typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if ControlT _ = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_control(typeIR)*

dec $nestable_constructor_package(typeIR) : bool
dec $nestable'_constructor_package(typeIR) : bool

def $nestable_constructor_package(typeIR)
  = $nestable'_constructor_package($canon(typeIR))
def $nestable'_constructor_package(TableT _ _) = false
def $nestable'_constructor_package(_) = true
  -- otherwise

rule ConstructorType_wf/packagetype:
  bound |- ConstructorT parameterTypeIR* typeIR_object
  -- ConstructorParameterTypes_wf: bound |- parameterTypeIR*
  -- Type_wf: bound |- typeIR_object
  -- if PackageT _ _ = $canon(typeIR_object)
  -- if (_ typeIR _ _ = parameterTypeIR)*
  -- if $nestable_constructor_package(typeIR)*

;;
;;;; Well-formedness of constructor definitions
;;

dec $definable_constructor(typeIR) : bool
dec $definable'_constructor(typeIR) : bool

def $definable_constructor(typeIR)
  = $definable'_constructor($canon(typeIR))
def $definable'_constructor(ExternT _ _) = true
def $definable'_constructor(ParserT _) = true
def $definable'_constructor(ControlT _) = true
def $definable'_constructor(PackageT _ _) = true
def $definable'_constructor(_) = false
  -- otherwise

rule ConstructorTypeDef_wf:
  bound |- PolyTD constructorTypeIR tid_expl* tid_impl*
  -- if ConstructorT _ typeIR_object = constructorTypeIR
  -- if $definable_constructor(typeIR_object)
  -- if $distinct_<tid>(tid_expl* ++ tid_impl*)
  -- if bound_inner
      = $union_set<tid>(bound, `{ tid_expl* ++ tid_impl* })
  -- ConstructorType_wf: bound_inner |- constructorTypeIR
