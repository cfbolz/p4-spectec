;;
;; Expression typing
;;
;; syntax expression
;;

;;; literalExpression
;;; syntax literalExpression

;;;; BoolE bool

rule Expr_ok/literalExpression-boolE:
  p TC |- BoolE b : (BoolE b) expressionNoteIR
  -- if expressionNoteIR = `( BoolT LCTK )

;;;; NumE number

rule Expr_ok/literalExpression-numE-arbint:
  p TC |- NumE (INT i) : (NumE (INT i)) expressionNoteIR
  -- if expressionNoteIR = `( IntT LCTK )

rule Expr_ok/literalExpression-numE-fixint:
  p TC |- NumE (FINT n i) : (NumE (FINT n i)) expressionNoteIR
  -- if expressionNoteIR = `( (FIntT n) LCTK )

rule Expr_ok/literalExpression-numE-fixbit:
  p TC |- NumE (FBIT n i) : (NumE (FBIT n i)) expressionNoteIR
  -- if expressionNoteIR = `( (FBitT n) LCTK )

;;;; StrE text

rule Expr_ok/literalExpression-strE:
  p TC |- StrE t : (StrE t) expressionNoteIR
  -- if expressionNoteIR = `( StrT LCTK )

;;; referenceExpression
;;; syntax referenceExpression = NameE prefixedName

rule Expr_ok/referenceExpression:
  p TC |- NameE prefixedName : (NameE prefixedName) expressionNoteIR
  -- if _ typeIR ctk _ = $find_var(p, TC, prefixedName)
  -- if expressionNoteIR = `( typeIR ctk )

;;; defaultExpression
;;; syntax defaultExpression = DefaultE

rule Expr_ok/defaultExpression:
  p TC |- DefaultE : DefaultE expressionNoteIR
  -- if expressionNoteIR = `( DefaultT LCTK )

;;; unaryExpression
;;; syntax unaryExpression = UnE unop expression
;;;; syntax unop

;;;;; LNOT

dec $compat_lnot(typeIR) : bool
dec $compat'_lnot(typeIR) : bool

def $compat_lnot(typeIR) = $compat'_lnot($canon(typeIR))
def $compat'_lnot(BoolT) = true
def $compat'_lnot(typeIR) = false
  --otherwise

rule Expr_ok/unaryExpression-lnot:
  p TC |- (UnE LNOT expression)
        : (UnE LNOT typedExpressionIR_reduced) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression : typedExpressionIR
  ---- ;; check that the type is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_reduced
      = $reduce_serenum_unary(typedExpressionIR, def $compat_lnot)
  ---- ;; create typed expression
  -- if _ expressionNoteIR = typedExpressionIR_reduced

;;;;; BNOT

dec $compat_bnot(typeIR) : bool
dec $compat'_bnot(typeIR) : bool

def $compat_bnot(typeIR) = $compat'_bnot($canon(typeIR))
def $compat'_bnot(FIntT _) = true
def $compat'_bnot(FBitT _) = true
def $compat'_bnot(typeIR) = false
  -- otherwise

rule Expr_ok/unaryExpression-bnot:
  p TC |- (UnE BNOT expression)
        : (UnE BNOT typedExpressionIR_reduced) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression : typedExpressionIR
  ---- ;; check that the type is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_reduced
      = $reduce_serenum_unary(typedExpressionIR, def $compat_bnot)
  ---- ;; create typed expression
  -- if _ expressionNoteIR = typedExpressionIR_reduced

;;;;; UPLUS | UMINUS

dec $compat_uplusminus(typeIR) : bool
dec $compat'_uplusminus(typeIR) : bool

def $compat_uplusminus(typeIR) = $compat'_uplusminus($canon(typeIR))
def $compat'_uplusminus(IntT) = true
def $compat'_uplusminus(FIntT _) = true
def $compat'_uplusminus(FBitT _) = true
def $compat'_uplusminus(typeIR) = false
  -- otherwise

rule Expr_ok/unaryExpression-uplusminus:
  p TC |- UnE unop expression
        : (UnE unop typedExpressionIR_reduced) expressionNoteIR
  -- if unop = UPLUS \/ unop = UMINUS 
  ---- ;; check expression
  -- Expr_ok: p TC |- expression : typedExpressionIR
  ---- ;; check that the type is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_reduced
      = $reduce_serenum_unary(typedExpressionIR, def $compat_uplusminus)
  ---- ;; create typed expression
  -- if _ expressionNoteIR = typedExpressionIR_reduced

;;; binaryExpression
;;; syntax binaryExpression = BinE expression binop expression
;;;; syntax binop

;;;;; PLUS | MINUS | MUL

dec $compat_plusminusmul(typeIR, typeIR) : bool
dec $compat'_plusminusmul(typeIR, typeIR) : bool

def $compat_plusminusmul(typeIR_l, typeIR_r)
  = $compat'_plusminusmul($canon(typeIR_l), $canon(typeIR_r))
def $compat'_plusminusmul(IntT, IntT) = true
def $compat'_plusminusmul(FIntT w, FIntT w) = true
def $compat'_plusminusmul(FBitT w, FBitT w) = true
def $compat'_plusminusmul(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-plusminusmult:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ PLUS, MINUS, MUL ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_plusminusmul
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;;;; SPLUS | SMINUS

dec $compat_satplusminus(typeIR, typeIR) : bool
dec $compat'_satplusminus(typeIR, typeIR) : bool

def $compat_satplusminus(typeIR_l, typeIR_r)
  = $compat'_satplusminus($canon(typeIR_l), $canon(typeIR_r))
def $compat'_satplusminus(FIntT w, FIntT w) = true
def $compat'_satplusminus(FBitT w, FBitT w) = true
def $compat'_satplusminus(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-satplusminus:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ SPLUS, SMINUS ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_satplusminus
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;;;; DIV | MOD

dec $compat_divmod(typeIR, typeIR) : bool
dec $compat'_divmod(typeIR, typeIR) : bool

def $compat_divmod(typeIR_l, typeIR_r)
  = $compat'_divmod($canon(typeIR_l), $canon(typeIR_r))
def $compat'_divmod(IntT, IntT) = true
def $compat'_divmod(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-divmod-lctk:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ DIV, MOD ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_divmod
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check that the divisor is local compile-time known and is positive
  -- if ctk_r_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_r_reduced ~> value_r
  -- if n_r = $to_number(value_r)
  -- if $(n_r > 0)
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

rule Expr_ok/binaryExpression-divmod-non-lctk:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ DIV, MOD ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_divmod
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check that the divisor is not local compile-time known
  ---- ;; may be target-specific, but let it slide
  -- if ctk_r_reduced =/= LCTK
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;;;; SHL | SHR

dec $compat_shift(typeIR, typeIR) : bool
dec $compat'_shift(typeIR, typeIR) : bool

def $compat_shift(typeIR_l, typeIR_r)
  = $compat'_shift($canon(typeIR_l), $canon(typeIR_r))
def $compat'_shift(IntT, IntT) = true
def $compat'_shift(IntT, FIntT _) = true
def $compat'_shift(IntT, FBitT _) = true
def $compat'_shift(FIntT _, IntT) = true
def $compat'_shift(FIntT _, FIntT _) = true
def $compat'_shift(FIntT _, FBitT _) = true
def $compat'_shift(FBitT _, IntT) = true
def $compat'_shift(FBitT _, FIntT _) = true
def $compat'_shift(FBitT _, FBitT _) = true
def $compat'_shift(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-shift-fixbit:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ SHL, SHR ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l,
            typedExpressionIR_r,
            def $compat_shift
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check that the right-hand side is fixed bit type
  -- if $is_fixed_bit_typeIR(typeIR_r_reduced)
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_l_reduced ctk_reduced )

rule Expr_ok/binaryExpression-shift-integer:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ SHL, SHR ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l,
            typedExpressionIR_r,
            def $compat_shift
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; check that the right-hand side is local compile-time known int type
  -- if ctk_r_reduced = LCTK
  -- if $is_arbitrary_int_typeIR(typeIR_r_reduced)
        \/ $is_fixed_int_typeIR(typeIR_r_reduced)
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_l_reduced ctk_reduced )

;;;;; EQ | NE

rule Expr_ok/binaryExpression-eq-ne:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_cast binop typedExpressionIR_r_cast)
            expressionNoteIR
  -- if binop <- [ EQ, NE ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  ---- ;; fetch annotations
  -- if _ `( typeIR_cast ctk_l_cast ) = typedExpressionIR_l_cast
  -- if _ `( _ ctk_r_cast ) = typedExpressionIR_r_cast
  ---- ;; check that the type supports equality
  -- if $is_equalable_typeIR(typeIR_cast)
  ---- ;; create typed expression
  -- if ctk_cast = $join_ctk(ctk_l_cast, ctk_r_cast)
  -- if expressionNoteIR = `( BoolT ctk_cast )

;;;;; LE | GE | LT | GT

dec $compat_compare(typeIR, typeIR) : bool
dec $compat'_compare(typeIR, typeIR) : bool

def $compat_compare(typeIR_l, typeIR_r)
  = $compat'_compare($canon(typeIR_l), $canon(typeIR_r))
def $compat'_compare(IntT, IntT) = true
def $compat'_compare(FIntT w, FIntT w) = true
def $compat'_compare(FBitT w, FBitT w) = true
def $compat'_compare(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-compare:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ LE, GE, LT, GT ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_compare
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( BoolT ctk_reduced )

;;;;; BAND | BXOR | BOR

dec $compat_bitwise(typeIR, typeIR) : bool
dec $compat'_bitwise(typeIR, typeIR) : bool

def $compat_bitwise(typeIR_l, typeIR_r)
  = $compat'_bitwise($canon(typeIR_l), $canon(typeIR_r))
def $compat'_bitwise(FIntT w, FIntT w) = true
def $compat'_bitwise(FBitT w, FBitT w) = true
def $compat'_bitwise(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-bitwise:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ BAND, BXOR, BOR ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_bitwise
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;;;; CONCAT

dec $compat_concat(typeIR, typeIR) : bool
dec $compat'_concat(typeIR, typeIR) : bool

def $compat_concat(typeIR_l, typeIR_r)
  = $compat'_concat($canon(typeIR_l), $canon(typeIR_r))
def $compat'_concat(FIntT _, FIntT _) = true
def $compat'_concat(FIntT _, FBitT _) = true
def $compat'_concat(FBitT _, FIntT _) = true
def $compat'_concat(FBitT _, FBitT _) = true
def $compat'_concat(typeIR_l, typeIR_r) = false
  -- otherwise

dec $result_concat(typeIR, typeIR) : typeIR?
dec $result'_concat(typeIR, typeIR) : typeIR?

def $result_concat(typeIR_l, typeIR_r)
  = $result'_concat($canon(typeIR_l), $canon(typeIR_r))
def $result'_concat(FIntT w_a, FIntT w_b) = FIntT $(w_a + w_b)
def $result'_concat(FIntT w_a, FBitT w_b) = FIntT $(w_a + w_b)
def $result'_concat(FBitT w_a, FIntT w_b) = FBitT $(w_a + w_b)
def $result'_concat(FBitT w_a, FBitT w_b) = FBitT $(w_a + w_b)
def $result'_concat(typeIR_l, typeIR_r) = eps
  -- otherwise

rule Expr_ok/binaryExpression-concat:
  p TC |- BinE expression_l CONCAT expression_r
        : (BinE typedExpressionIR_l_reduced CONCAT typedExpressionIR_r_reduced)
            expressionNoteIR
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l,
            typedExpressionIR_r,
            def $compat_concat
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_l_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( typeIR_r_reduced ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; compute the result type
  -- if typeIR_reduced
      = $result_concat(typeIR_l_reduced, typeIR_r_reduced)
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;;; LAND | LOR

dec $compat_logical(typeIR, typeIR) : bool
dec $compat'_logical(typeIR, typeIR) : bool

def $compat_logical(typeIR_l, typeIR_r)
  = $compat'_logical($canon(typeIR_l), $canon(typeIR_r))
def $compat'_logical(BoolT, BoolT) = true
def $compat'_logical(typeIR_l, typeIR_r) = false
  -- otherwise

rule Expr_ok/binaryExpression-logical:
  p TC |- BinE expression_l binop expression_r
        : (BinE typedExpressionIR_l_reduced binop typedExpressionIR_r_reduced)
            expressionNoteIR
  -- if binop <- [ LAND, LOR ]
  ---- ;; check both sides
  -- Expr_ok: p TC |- expression_l : typedExpressionIR_l
  -- Expr_ok: p TC |- expression_r : typedExpressionIR_r
  ---- ;; check that the types are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if (typedExpressionIR_l_cast, typedExpressionIR_r_cast)
        = $coerce_binary(typedExpressionIR_l, typedExpressionIR_r)
  -- if (typedExpressionIR_l_reduced, typedExpressionIR_r_reduced)
        = $reduce_serenum_binary(
            typedExpressionIR_l_cast,
            typedExpressionIR_r_cast,
            def $compat_logical
          )
  ---- ;; fetch annotations
  -- if _ `( typeIR_reduced ctk_l_reduced ) = typedExpressionIR_l_reduced
  -- if _ `( _ ctk_r_reduced ) = typedExpressionIR_r_reduced
  ---- ;; create typed expression
  -- if ctk_reduced = $join_ctk(ctk_l_reduced, ctk_r_reduced)
  -- if expressionNoteIR = `( typeIR_reduced ctk_reduced )

;;; ternaryExpression
;;; syntax ternaryExpression =
;;;   TernE expression expression expression

rule Expr_ok/ternaryExpression:
  p TC |- TernE expression_cond expression_true expression_false
        : (TernE typedExpressionIR_cond typedExpressionIR_true_cast typedExpressionIR_false_cast)
            expressionNoteIR
  ---- ;; check condition
  -- Expr_ok: p TC |- expression_cond : typedExpressionIR_cond
  -- if _ `( BoolT ctk_cond ) = typedExpressionIR_cond
  ---- ;; check both branches
  -- Expr_ok: p TC |- expression_true : typedExpressionIR_true
  -- Expr_ok: p TC |- expression_false : typedExpressionIR_false
  ---- ;; check that the types are compatible for the branches
  -- if (typedExpressionIR_true_cast, typedExpressionIR_false_cast)
        = $coerce_binary(typedExpressionIR_true, typedExpressionIR_false)
  ---- ;; fetch annotations
  -- if _ `( typeIR_cast ctk_true_cast ) = typedExpressionIR_true_cast
  -- if _ `( _ ctk_false_cast ) = typedExpressionIR_false_cast
  ---- ;; if both branches are arbitrary integer types,
  ---- ;; then the condition must be compile-time known
  -- if $is_arbitrary_int_typeIR(typeIR_cast) => (ctk_cond =/= DYN)
  ---- ;; create typed expression
  -- if ctk = $joins_ctk([ ctk_cond, ctk_true_cast, ctk_false_cast ])
  -- if expressionNoteIR = `( typeIR_cast ctk )

;;; castExpression
;;; syntax castExpression = CastE type expression

rule Expr_ok/castExpression:
  p TC |- CastE type_t expression
        : (CastE typeIR_t typedExpressionIR) expressionNoteIR
  ---- ;; check target type
  -- Type_ok: p TC |- type_t : typeIR_t eps
  -- Type_wf: $bound(p, TC) |- typeIR_t
  ---- ;; check expression
  -- Expr_ok: p TC |- expression : typedExpressionIR
  ---- ;; fetch annotation
  -- if _ `( typeIR ctk ) = typedExpressionIR
  ---- ;; check that explicit cast is defined
  -- Sub_expl: typeIR <: typeIR_t
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR_t ctk )

;;; dataExpression
;;; syntax dataExpression

;;;; InvalidE

rule Expr_ok/dataExpression-invalidE:
  p TC |- InvalidE : InvalidE expressionNoteIR
  -- if expressionNoteIR = `( InvalidHeaderT LCTK )

;;;; SeqE expression*

rule Expr_ok/dataExpression-seqE-no-default:
  p TC |- SeqE expression_e*
        : (SeqE typedExpressionIR_e*) expressionNoteIR
  ---- ;; when ... is not be used
  -- if ~(DefaultE <- expression_e*)
  ---- ;; check each expression
  -- (Expr_ok: p TC |- expression_e : typedExpressionIR_e)*
  ---- ;; fetch annotations
  -- if (_ `( typeIR_e ctk_e ) = typedExpressionIR_e)*
  ---- ;; create typed expression
  -- if typeIR = SeqT typeIR_e*
  -- if ctk = $joins_ctk(ctk_e*)
  -- if expressionNoteIR = `( typeIR ctk )

rule Expr_ok/dataExpression-seqE-default:
   p TC |- SeqE expression_e*
        : (SeqDefaultE typedExpressionIR_e_h*) expressionNoteIR
  ---- ;; when ... is used, it must be the last element
  -- if (DefaultE <- expression_e*) 
  -- if DefaultE :: expression_e_h_rev* = $rev_<expression>(expression_e*)
  -- if expression_e_h* = $rev_<expression>(expression_e_h_rev*)
  -- if ~(DefaultE <- expression_e_h*)
  ---- ;; check each expression
  -- (Expr_ok: p TC |- expression_e_h : typedExpressionIR_e_h)*
  ---- ;; fetch annotations
  -- if (_ `( typeIR_e_h ctk_e_h ) = typedExpressionIR_e_h)*
  ---- ;; create typed expression
  -- if typeIR = SeqDefaultT typeIR_e_h*
  -- if ctk = $joins_ctk(ctk_e_h*)
  -- if expressionNoteIR = `( typeIR ctk )

;;;; RecordE namedExpression*

rule Expr_ok/dataExpression-recordE:
  p TC |- RecordE (name_f expression_f)*
        : (RecordE (name_f typedExpressionIR_f)*) expressionNoteIR
  ---- ;; check expressions
  -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*
  ---- ;; fetch annotations
  -- if (_ `( typeIR_f ctk_f ) = typedExpressionIR_f)*
  ---- ;; create typed expression
  -- if typeIR = RecordT (typeIR_f name_f)*
  -- if ctk = $joins_ctk(ctk_f*)
  -- if expressionNoteIR = `( typeIR ctk )

;;;; RecordDefaultE namedExpression*

rule Expr_ok/dataExpression-recorddefaultE:
  p TC |- RecordDefaultE (name_f expression_f)*
        : (RecordDefaultE (name_f typedExpressionIR_f)*) expressionNoteIR
  ---- ;; check expressions
  -- (Expr_ok: p TC |- expression_f : typedExpressionIR_f)*
  ---- ;; fetch annotations
  -- if (_ `( typeIR_f ctk_f ) = typedExpressionIR_f)*
  ---- ;; create typed expression
  -- if typeIR = RecordT (typeIR_f name_f)*
  -- if ctk = $joins_ctk(ctk_f*)
  -- if expressionNoteIR = `( typeIR ctk )

;;; accessExpression
;;; syntax accessExpression

;;;; errorAccessExpression
;;;; syntax errorAccessExpression = ErrAccE name

rule Expr_ok/accessExpression-errorAccessExpression:
  p TC |- ErrAccE name : (ErrAccE name) expressionNoteIR
  ---- ;; check that error member is defined
  -- if name_error = "error." ++ name
  -- if ErrV name = $find_value(p, TC, CURRENT name_error)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( ErrT LCTK )

;;;; memberAccessExpression
;;;; syntax memberAccessExpression

;;;;; TypeAccE prefixedName name

rule Expr_ok/accessExpression-memberAccessExpression-typeaccE-enum:
  p TC |- TypeAccE prefixedName_base name
        : (TypeAccE prefixedName_base name) expressionNoteIR
  ---- ;; find the type
  -- if MonoTD typeIR_base = $find_type(p, TC, prefixedName_base)
  ---- ;; check that the type is an enum
  -- if EnumT _ id_f* = $canon(typeIR_base)
  ---- ;; check that the member is defined
  -- if name <- id_f*
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR_base LCTK )

rule Expr_ok/accessExpression-memberAccessExpression-typeaccE-senum:
  p TC |- TypeAccE prefixedName_base name
       : (TypeAccE prefixedName_base name) expressionNoteIR
  ---- ;; find the type
  -- if MonoTD typeIR_base = $find_type(p, TC, prefixedName_base)
  ---- ;; check that the type is an enum
  -- if SEnumT _ _ (id_f _)* = $canon(typeIR_base)
  ---- ;; check that the member is defined
  -- if name <- id_f*
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR_base LCTK )

;;;;; ExprAccE expression name

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-stack-size:
  p TC |- ExprAccE expression_base "size"
        : (ExprAccE typedExpressionIR_base "size") expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( (FBitT 32) LCTK )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-stack-lastIndex:
  p TC |- ExprAccE expression_base "lastIndex"
        : (ExprAccE typedExpressionIR_base "lastIndex") expressionNoteIR
  ---- ;; "lastIndex" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( (FBitT 32) DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-stack-last:
  p TC |- ExprAccE expression_base "last"
        : (ExprAccE typedExpressionIR_base "last") expressionNoteIR
  ---- ;; "last" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-stack-next:
  p TC |- ExprAccE expression_base "next"
        : (ExprAccE typedExpressionIR_base "next") expressionNoteIR
  ---- ;; "next" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header stack
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-struct:
  p TC |- ExprAccE expression_base name
        : (ExprAccE typedExpressionIR_base name) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a struct
  -- if StructT _ (typeIR_f id_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-header:
  p TC |- ExprAccE expression_base name
        : (ExprAccE typedExpressionIR_base name) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header
  -- if HeaderT _ (typeIR_f id_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-union:
  p TC |- ExprAccE expression_base name
        : (ExprAccE typedExpressionIR_base name) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a header union
  -- if HeaderUnionT _ (typeIR_f id_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/accessExpression-memberAccessExpression-expraccE-tablestruct:
  p TC |- ExprAccE expression_base name
        : (ExprAccE typedExpressionIR_base name) expressionNoteIR
  ---- ;; check expression
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  ---- ;; fetch annotation
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; check that the expression is a table struct
  -- if TableStructT _ (typeIR_f id_f)* = $canon(typeIR_base)
  ---- ;; find the field
  -- if typeIR = $assoc_<name, typeIR>(name, (id_f, typeIR_f)*)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

;;;; indexAccessExpression
;;;; syntax indexAccessExpression

;;;;; ArrAccE expression expression

dec $compat_array_index(typeIR) : bool
dec $compat'_arrayindex(typeIR) : bool

def $compat_array_index(typeIR)
  = $compat'_arrayindex($canon(typeIR))
def $compat'_arrayindex(IntT) = true
def $compat'_arrayindex(FIntT _) = true
def $compat'_arrayindex(FBitT _) = true
def $compat'_arrayindex(typeIR) = false
  -- otherwise

rule Expr_ok/indexAccessExpression-arraccE-tuple:
  p TC |- ArrAccE expression_base expression_index
        : (ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced)
            expressionNoteIR
  ---- ;; check expressions
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  ---- ;; fetch annotations
  -- if _ `( typeIR_base ctk_base ) = typedExpressionIR_base
  -- if _ `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; check that the base expression is a tuple
  ---- ;; then, index must be local compile-time known and in range
  -- if TupleT typeIR_e* = $canon(typeIR_base)
  -- if ctk_index = LCTK
  -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
  -- if n_index = $to_number(value_index)
  -- if $(n_index < |typeIR_e*|)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR_e*[n_index] DYN )

rule Expr_ok/indexAccessExpression-arraccE-stack-lctk:
  p TC |- ArrAccE expression_base expression_index
        : (ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced)
            expressionNoteIR
  ---- ;; check expressions
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  ---- ;; fetch annotations
  -- if _ `( typeIR_base ctk_base ) = typedExpressionIR_base
  -- if _ `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; check that the base expression is a stack
  ---- ;; if the index is local compile-time known, then it must be in range
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  -- if ctk_index = LCTK
  -- Eval_static: p TC |- typedExpressionIR_index_reduced ~> value_index
  -- if n_index = $to_number(value_index)
  -- if $(n_index < n_size)
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

rule Expr_ok/indexAccessExpression-arraccE-stack-non-lctk:
  p TC |- ArrAccE expression_base expression_index
        : (ArrAccE typedExpressionIR_base typedExpressionIR_index_reduced)
            expressionNoteIR
  ---- ;; check expressions
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  -- Expr_ok: p TC |- expression_index : typedExpressionIR_index
  ---- ;; fetch annotations
  -- if _ `( typeIR_base ctk_base ) = typedExpressionIR_base
  -- if _ `( typeIR_index ctk_index ) = typedExpressionIR_index
  ---- ;; check that the index is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_index_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_index,
          def $compat_array_index
        )
  ---- ;; check that the base expression is a stack
  ---- ;; if the index is not local compile-time known, no range check is done
  -- if HeaderStackT typeIR n_size = $canon(typeIR_base)
  -- if ctk_index =/= LCTK
  ---- ;; create typed expression
  -- if expressionNoteIR = `( typeIR DYN )

;;;;; BitAccE expression expression expression

dec $compat_bitslice_base(typeIR) : bool
dec $compat'_bitslice_base(typeIR) : bool

def $compat_bitslice_base(typeIR)
  = $compat'_bitslice_base($canon(typeIR))
def $compat'_bitslice_base(IntT) = true
def $compat'_bitslice_base(FIntT w) = $(w > 0)
def $compat'_bitslice_base(FBitT _) = true
def $compat'_bitslice_base(typeIR) = false
  -- otherwise

dec $compat_bitslice_index(typeIR) : bool
dec $compat'_bitslice_index(typeIR) : bool

def $compat_bitslice_index(typeIR)
  = $compat'_bitslice_index($canon(typeIR))
def $compat'_bitslice_index(IntT) = true
def $compat'_bitslice_index(FIntT _) = true
def $compat'_bitslice_index(FBitT _) = true
def $compat'_bitslice_index(typeIR) = false
  -- otherwise

dec $is_valid_bitslice(typeIR, nat, nat) : bool
dec $is_valid_bitslice'(typeIR, nat, nat) : bool

def $is_valid_bitslice(typeIR, n_lo, n_hi)
  = $(n_lo <= n_hi) /\ $is_valid_bitslice'($canon(typeIR), n_lo, n_hi)
def $is_valid_bitslice'(IntT, _, _) = true
def $is_valid_bitslice'(FIntT w, n_lo, n_hi)
  = $(n_hi <= w) /\ $(w_slice <= w)
  -- if w_slice = $(n_hi - n_lo + 1)
def $is_valid_bitslice'(FBitT w, n_lo, n_hi)
  = $(n_hi <= w) /\ $(w_slice <= w)
  -- if w_slice = $(n_hi - n_lo + 1)
def $is_valid_bitslice'(_, _, _) = false
  -- otherwise

rule Expr_ok/indexAccessExpression-bitaccE:
  p TC |- BitAccE expression_base expression_hi expression_lo
        : (BitAccE typedExpressionIR_base
            typedExpressionIR_hi_reduced typedExpressionIR_lo_reduced)
            expressionNoteIR
  ---- ;; check expressions
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base
  -- Expr_ok: p TC |- expression_hi : typedExpressionIR_hi
  -- Expr_ok: p TC |- expression_lo : typedExpressionIR_lo
  ---- ;; check that the base expression is compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_base_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_base,
          def $compat_bitslice_base
        )
  ---- ;; fetch base annotation
  -- if _ `( typeIR_base_reduced ctk_base_reduced )
      = typedExpressionIR_base_reduced
  ---- ;; check that the indices are compatible
  ---- ;; while inserting implicit casts if necessary
  -- if typedExpressionIR_hi_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_hi,
          def $compat_bitslice_index
        )
  -- if typedExpressionIR_lo_reduced
      = $reduce_serenum_unary(
          typedExpressionIR_lo,
          def $compat_bitslice_index
        )
  ---- ;; fetch index annotations
  -- if _ `( typeIR_hi_reduced ctk_hi_reduced )
      = typedExpressionIR_hi_reduced
  -- if _ `( typeIR_lo_reduced ctk_lo_reduced )
      = typedExpressionIR_lo_reduced
  ---- ;; check that the indices are local compile-time known
  -- if ctk_hi_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_hi_reduced ~> value_hi
  -- if n_hi = $to_number(value_hi)
  -- if ctk_lo_reduced = LCTK
  -- Eval_static: p TC |- typedExpressionIR_lo_reduced ~> value_lo
  -- if n_lo = $to_number(value_lo)
  ---- ;; check that the slice is valid
  -- if $is_valid_bitslice(typeIR_base_reduced, n_lo, n_hi)
  ---- ;; create typed expression
  -- if typeIR = FBitT $(n_hi - n_lo + 1)
  -- if expressionNoteIR = `( typeIR ctk_base_reduced )

;;; callExpression
;;; syntax callExpression

;;;; CallE routineTarget typeArgument* argumentList
;;;;; syntax routineTarget

dec $is_static_routineTarget(routineTargetIR) : ctk

def $is_static_routineTarget(MethodT _ name) = LCTK
  -- if name <- [ "minSizeInBits", "minSizeInBytes",
                  "maxSizeInBits", "maxSizeInBytes" ]
def $is_static_routineTarget(TypeT _ name) = LCTK
  -- if name <- [ "minSizeInBits", "minSizeInBytes",
                  "maxSizeInBits", "maxSizeInBytes" ]
def $is_static_routineTarget(_) = DYN
  -- otherwise

rule Expr_ok/callExpression-callE:
  p TC |- CallE routineTarget typeArgument* argument*
        : callExpressionIR expressionNoteIR
  ---- ;; check routine target
  -- RoutineTarget_ok: p TC |- routineTarget : routineTargetIR
  ---- ;; check type arguments
  -- TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* tid_impl*
  ---- ;; check arguments
  -- (Argument_ok: p TC |- argument : argumentIR)*
  ---- ;; check routine
  -- RoutineType_ok:
      p TC |- routineTargetIR typeArgumentIR* argumentIR*
           : routineTypeIR tid_inserted* id_default*
  ---- ;; check calling convention
  -- if tid_infer* = tid_impl* ++ tid_inserted*
  -- Call_ok:
      p TC |- routineTypeIR typeArgumentIR* tid_infer* argumentIR* id_default*
            : typeIR_ret typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; call must not return void on expression level
  -- if typeIR_ret =/= VoidT
  ---- ;; check whether the call is static
  -- if ctk = $is_static_routineTarget(routineTargetIR)
  ---- ;; create IR
  -- if callExpressionIR
      = CallE routineTargetIR typeArgumentIR_inferred* argumentIR_cast*
  -- if expressionNoteIR = `( typeIR_ret ctk )

;;;; InstE namedType argument*
;;;;; syntax namedType

dec $is_concrete_extern_object(typeIR) : bool
dec $is_concrete_extern_object'(typeIR) : bool
dec $is_concrete_extern_object''(routineTypeDefIR) : bool
dec $is_concrete_extern_object'''(routineTypeIR) : bool

def $is_concrete_extern_object(typeIR)
    = $is_concrete_extern_object'($canon(typeIR))

def $is_concrete_extern_object'(typeIR) = true
  -- if ~$is_extern_object_typeIR(typeIR)
def $is_concrete_extern_object'(ExternT _ `{ (_ -> routineTypeDefIR)* }) = true
  -- if ($is_concrete_extern_object''(routineTypeDefIR))*
def $is_concrete_extern_object'(typeIR) = false
  -- otherwise

def $is_concrete_extern_object''(MonoTD routineTypeIR)
  = $is_concrete_extern_object'''(routineTypeIR)
def $is_concrete_extern_object''(PolyTD routineTypeIR _ _) = true
   = $is_concrete_extern_object'''(routineTypeIR) 

def $is_concrete_extern_object'''(ExternAbstractMethodT _ _) = false
def $is_concrete_extern_object'''(_) = true
  -- otherwise

;;;;;;; nameType

rule Expr_ok/callExpression-instE-nameType:
  p TC |- InstE (NameT prefixedName) argument*
        : callExpressionIR expressionNoteIR
  ---- ;; check arguments
  -- (Argument_ok: p TC |- argument : argumentIR)*
  ---- ;; check constructor type
  -- ConstructorType_ok: p TC |- prefixedName eps argumentIR*
                               : constructorTypeIR tid_impl* id_default*
  ---- ;; check instantiation convention
  -- Inst_ok:
      p TC ANON |- constructorTypeIR eps tid_impl* argumentIR* id_default*
                 : typeIR_object typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; constructed object may not contain an abstract method
  -- if $is_concrete_extern_object(typeIR_object)
  ---- ;; create IR
  -- if callExpressionIR
      = InstE prefixedName typeArgumentIR_inferred* argumentIR_cast*
  -- if expressionNoteIR = `( typeIR_object CTK )

;;;;;;; specializedType

rule Expr_ok/callExpression-instE-specializedType:
  p TC |- InstE (SpecT prefixedName typeArgument*) argument*
        : callExpressionIR expressionNoteIR
  ---- ;; check type arguments
  -- TypeArguments_ok: p TC |- typeArgument* : typeArgumentIR* tid_impl*
  ---- ;; check arguments
  -- (Argument_ok: p TC |- argument : argumentIR)*
  ---- ;; check constructor type
  -- ConstructorType_ok:
      p TC |- prefixedName typeArgumentIR* argumentIR*
           : constructorTypeIR tid_inserted* id_default*
  ---- ;; check instantiation convention
  -- if tid_infer* = tid_impl* ++ tid_inserted*
  -- Inst_ok:
      p TC ANON |- constructorTypeIR typeArgumentIR* tid_infer* argumentIR* id_default*
                 : typeIR_object typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; constructed object may not contain an abstract method
  -- if $is_concrete_extern_object(typeIR_object)
  ---- ;; create IR
  -- if callExpressionIR
      = InstE prefixedName typeArgumentIR_inferred* argumentIR_cast*
  -- if expressionNoteIR = `( typeIR_object CTK )
