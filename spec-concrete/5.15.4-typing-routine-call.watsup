;;
;; Routine target typing
;;
;; syntax routineTarget = expression
;;

;;; referenceExpression
;;; syntax referenceExpression

rule RoutineTarget_ok/referenceExpression:
  p TC |- NameE prefixedName : FuncT prefixedName
  ---- ;; call to "verify" is only allowed in parsers
  -- if ((prefixedName = CURRENT "verify") \/ (prefixedName = TOP "verify"))
        => ((p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
             \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND)))

;;; memberAccessExpression
;;; syntax memberAccessExpression

;;;; TypeAccE prefixedName name

rule RoutineTarget_ok/typeaccE:
  p TC |- TypeAccE prefixedName name : TypeT prefixedName name

;;;; ExprAccE expression name

rule RoutineTarget_ok/expraccE:
  p TC |- ExprAccE expression_base name : MethodT typedExpressionIR_base name
  -- Expr_ok: p TC |- expression_base : typedExpressionIR_base

;;
;; Routine target typing (when used as a lvalue)
;;
;; syntax lvalue
;;

dec $lvalue_as_expression(lvalue) : expression
def $lvalue_as_expression(NameL prefixedName) = NameE prefixedName
def $lvalue_as_expression(LvalueAccL lvalue_base name)
  = ExprAccE expression_base name
  -- if expression_base = $lvalue_as_expression(lvalue_base)
def $lvalue_as_expression(ArrAccL lvalue_base expression_index)
  = ArrAccE expression_base expression_index
  -- if expression_base = $lvalue_as_expression(lvalue_base)
def $lvalue_as_expression(BitAccL lvalue_base expression_hi expression_lo)
  = BitAccE expression_base expression_hi expression_lo 
  -- if expression_base = $lvalue_as_expression(lvalue_base)

rule RoutineTarget_lvalue_ok:
  p TC |- lvalue : routineTargetIR
  -- if expression = $lvalue_as_expression(lvalue)
  -- RoutineTarget_ok: p TC |- expression : routineTargetIR

;;
;; Routine call typing
;; 
;; syntax routineTargetIR
;;

;;; FuncT prefixedName

rule RoutineType_ok/funcT:
  p TC |- (FuncT prefixedName) typeArgumentIR* argumentIR*
        : functionTypeIR tid_impl* id_default*
  ---- ;; find and specialize the function type definition
  -- if (rid, routineTypeDefIR, id_default*)
      = $find_routine_overloaded(p, TC, prefixedName, argumentIR*)
  -- if (functionTypeIR, tid_impl*)
      = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*)
  ---- ;; check that the function type is well-formed
  -- if bound = $union_set<tid>($bound(p, TC), `{ tid_impl* })
  -- RoutineType_wf: bound |- functionTypeIR

;;; MethodT typedExpressionIR nameIR

rule RoutineType_ok/methodT-builtin-minmax-SizeIn-BitsBytes:
  p TC |- (MethodT typedExpressionIR_base name) eps eps
        : methodTypeIR eps eps
  ---- ;; if the method is min/maxSizeInBits/Bytes builtin
  -- if name <- [ "minSizeInBits", "minSizeInBytes",
                  "maxSizeInBits", "maxSizeInBytes" ]
  ---- ;; create routine type
  -- if methodTypeIR = BuiltinMethodT eps IntT

rule RoutineType_ok/methodT-builtin-stack-push-pop-front:
  p TC |- (MethodT typedExpressionIR_base name) eps argumentIR
        : methodTypeIR eps eps
  ---- ;; if the method is push/pop_front builtin
  -- if name <- [ "push_front", "pop_front" ]
  ---- ;; check that the base type is a stack
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if HeaderStackT typeIR _ = $canon(typeIR_base)
  ---- ;; (TODO) check if the argument is named
  ---- ;; create routine type
  -- if parameterTypeIR = NO IntT "count" eps
  -- if methodTypeIR = BuiltinMethodT parameterTypeIR IntT

rule RoutineType_ok/methodT-builtin-header-isValid:
  p TC |- (MethodT typedExpressionIR_base name) eps eps
        : methodTypeIR eps eps
  ---- ;; if the method is isValid builtin
  -- if name <- [ "isValid" ]
  ---- ;; check that the base type is a header
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if HeaderT _ _ = $canon(typeIR_base)
  ---- ;; create routine type
  -- if methodTypeIR = BuiltinMethodT eps BoolT

rule RoutineType_ok/methodT-builtin-union-isValid:
  p TC |- (MethodT typedExpressionIR_base name) eps eps
        : methodTypeIR eps eps
  ---- ;; if the method is isValid builtin
  -- if name <- [ "isValid" ]
  ---- ;; check that the base type is a header
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if HeaderUnionT _ _ = $canon(typeIR_base)
  ---- ;; create routine type
  -- if methodTypeIR = BuiltinMethodT eps BoolT

rule RoutineType_ok/methodT-builtin-header-set-ValidInvalid:
  p TC |- (MethodT typedExpressionIR_base name) eps eps
        : methodTypeIR eps eps
  ---- ;; if the method is setValid/Invalid builtin
  -- if name <- [ "setValid", "setInvalid" ]
  ---- ;; check that the base type is a header
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if HeaderT _ _ = $canon(typeIR_base)
  ---- ;; create routine type
  -- if methodTypeIR = BuiltinMethodT eps VoidT

rule RoutineType_ok/methodT-extern:
  p TC |- (MethodT typedExpressionIR_base name) typeArgumentIR* argumentIR*
        : routineTypeIR tid_impl* id_default*
  ---- ;; if the base type is an extern
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if ExternT _ `{ (rid_f -> routineTypeDefIR_f)* } = $canon(typeIR_base)
  ---- ;; find method type
  -- if (id_arg?)* = $ids_arguments(argumentIR*)
  -- if (rid, routineTypeDefIR, id_default*)
      = $find_overloaded<routineTypeDefIR>(
          `{ (rid_f -> routineTypeDefIR_f)* },
          name,
          (id_arg?)*)
  ---- ;; specialize routine type
  -- if (routineTypeIR, tid_impl*)
      = $specialize_routineTypeDef(routineTypeDefIR, typeArgumentIR*)
  ---- ;; check that the routine type is well-formed
  -- if bound = $union_set<tid>($bound(p, TC), `{ tid_impl* })
  -- RoutineType_wf: bound |- routineTypeIR

rule RoutineType_ok/methodT-parser-apply:
  p TC |- (MethodT typedExpressionIR_base "apply") eps argumentIR*
        : methodTypeIR eps id_default*
  ---- ;; if the base type is a parser 
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if ParserT parameterTypeIR* = $canon(typeIR_base)
  ---- ;; create method type
  -- if methodTypeIR = ParserApplyMethodT parameterTypeIR*
  ---- ;; create routine id
  -- if (_ _ id_param value_param? = parameterTypeIR)*
  -- if (pid = id_param (value_param? =/= eps))*
  -- if rid = "apply" pid*
  ---- ;; perform overload resoultion
  -- if (id_arg?)* = $ids_arguments(argumentIR*)
  -- if (rid, MonoTD methodTypeIR, id_default*)
      = $find_overloaded<routineTypeDefIR>(
          `{ (rid -> MonoTD methodTypeIR) },
          "apply",
          (id_arg?)*)

rule RoutineType_ok/methodT-control-apply:
  p TC |- (MethodT typedExpressionIR_base "apply") eps argumentIR*
        : methodTypeIR eps id_default*
  ---- ;; if the base type is a control 
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if ControlT parameterTypeIR* = $canon(typeIR_base)
  ---- ;; create method type
  -- if methodTypeIR = ControlApplyMethodT parameterTypeIR*
  ---- ;; create routine id
  -- if (_ _ id_param value_param? = parameterTypeIR)*
  -- if (pid = id_param (value_param? =/= eps))*
  -- if rid = "apply" pid*
  ---- ;; perform overload resoultion
  -- if (id_arg?)* = $ids_arguments(argumentIR*)
  -- if (rid, MonoTD methodTypeIR, id_default*)
      = $find_overloaded<routineTypeDefIR>(
          `{ (rid -> MonoTD methodTypeIR) },
          "apply",
          (id_arg?)*)

rule RoutineType_ok/methodT-table-apply:
  p TC |- (MethodT typedExpressionIR_base "apply") eps eps
        : methodTypeIR eps eps
  ---- ;; if the base type is a table
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if TableT _ typeIR_table = $canon(typeIR_base)
  ---- ;; create method type
  -- if methodTypeIR = TableApplyMethodT typeIR_table

;;; TypeT prefixedName name

rule RoutineType_ok/typeT-builtin-minmax-SizeIn-BitsBytes:
  p TC |- (TypeT prefixedName name) eps eps
        : methodTypeIR eps eps
  ---- ;; if the method is min/maxSizeInBits/Bytes builtin
  -- if name <- [ "minSizeInBits", "minSizeInBytes",
                  "maxSizeInBits", "maxSizeInBytes" ]
  ---- ;; create routine type
  -- if methodTypeIR = BuiltinMethodT eps IntT

;;
;; Call typing
;;

;;; Function call
;;; syntax functionTypeIR

;;;; BuiltinFuncT parameterTypeIR* typeIR

dec $callable_builtin_function(cursor, typingContext) : bool

def $callable_builtin_function(GLOBAL, TC) = true
def $callable_builtin_function(BLOCK, TC) = true
def $callable_builtin_function(LOCAL, TC) = true

rule Call_ok/builtin-function:
  p TC |- (BuiltinFuncT parameterTypeIR* typeIR_ret)
            typeArgumentIR* eps argumentIR* id_default*
        : typeIR_ret typeArgumentIR* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; check call site
  -- if $callable_builtin_function(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned* argumentIR*
                     : argumentIR_cast*

;;;; FuncT parameterTypeIR* typeIR

dec $callable_function(cursor, typingContext) : bool

def $callable_function(GLOBAL, TC) = false
def $callable_function(BLOCK, TC)
  = $is_parser_blockKind(TC.BLOCK.KIND)
    \/ $is_control_blockKind(TC.BLOCK.KIND)
def $callable_function(LOCAL, TC)
  = ~$is_extern_method_localKind(TC.LOCAL.KIND)
    /\ ~$is_extern_abstract_method_localKind(TC.LOCAL.KIND)

rule Call_ok/function:
  p TC |- (FuncT parameterTypeIR* typeIR_ret)
            typeArgumentIR* tid_infer* argumentIR* id_default*
        : typeIR_ret_inferred typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
        = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_ret_inferred
      = $subst_type(inference, typeIR_ret)
  ---- ;; check that the substituted function is still well-formed
  -- if functionTypeIR_inferred
      = FuncT parameterTypeIR_aligned_inferred* typeIR_ret_inferred
  -- RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred
  ---- ;; check call site
  -- if $callable_function(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned_inferred* argumentIR*
                     : argumentIR_cast*

;;;; ExternFuncT parameterTypeIR* typeIR

dec $callable_extern_function(cursor, typingContext) : bool

def $callable_extern_function(GLOBAL, TC) = false
def $callable_extern_function(BLOCK, TC)
  = $is_parser_blockKind(TC.BLOCK.KIND)
    \/ $is_control_blockKind(TC.BLOCK.KIND)
def $callable_extern_function(LOCAL, TC) = true

rule Call_ok/externfunction:
  p TC |- (ExternFuncT parameterTypeIR* typeIR_ret)
            typeArgumentIR* tid_infer* argumentIR* id_default*
        : typeIR_ret_inferred typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
        = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_ret_inferred
      = $subst_type(inference, typeIR_ret)
  ---- ;; check that the substituted function is still well-formed
  -- if functionTypeIR_inferred
      = ExternFuncT parameterTypeIR_aligned_inferred* typeIR_ret_inferred
  -- RoutineType_wf: $bound(p, TC) |- functionTypeIR_inferred
  ---- ;; check call site
  -- if $callable_extern_function(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned_inferred* argumentIR*
                     : argumentIR_cast*

;;;; ActionT parameterTypeIR*

dec $callable_action(cursor, typingContext) : bool

def $callable_action(GLOBAL, TC) = false
def $callable_action(BLOCK, TC) = false
def $callable_action(LOCAL, TC)
  = $is_action_localKind(TC.LOCAL.KIND)
    \/ $is_control_apply_method_localKind(TC.LOCAL.KIND)

rule Call_ok/action:
  p TC |- (ActionT parameterTypeIR*) eps eps argumentIR* id_default*
        : VoidT eps argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; check call site
  -- if $callable_action(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC ACTION |- parameterTypeIR_aligned* argumentIR*
                   : argumentIR_cast*

;;; Method call
;;; syntax methodTypeIR

;;;; BuiltinMethodT parameterTypeIR* typeIR

dec $callable_builtin_method(cursor, typingContext) : bool

def $callable_builtin_method(GLOBAL, TC) = true
def $callable_builtin_method(BLOCK, TC) = true
def $callable_builtin_method(LOCAL, TC) = true

rule Call_ok/builtin-method:
  p TC |- (BuiltinMethodT parameterTypeIR* typeIR_ret)
            typeArgumentIR* eps argumentIR* id_default*
        : typeIR_ret typeArgumentIR* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; check call site
  -- if $callable_builtin_method(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned* argumentIR*
                     : argumentIR_cast*

;;;; ExternMethodT parameterTypeIR* typeIR

dec $callable_extern_method(cursor, typingContext) : bool

def $callable_extern_method(GLOBAL, TC) = false
def $callable_extern_method(BLOCK, TC)
  = $is_parser_blockKind(TC.BLOCK.KIND)
    \/ $is_control_blockKind(TC.BLOCK.KIND)
def $callable_extern_method(LOCAL, TC) = true

rule Call_ok/extern-method:
  p TC |- (ExternMethodT parameterTypeIR* typeIR_ret)
            typeArgumentIR* tid_infer* argumentIR* id_default*
        : typeIR_ret_inferred typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
        = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_ret_inferred
      = $subst_type(inference, typeIR_ret)
  ---- ;; check that the substituted method is still well-formed
  -- if methodTypeIR_inferred
      = ExternMethodT parameterTypeIR_aligned_inferred* typeIR_ret_inferred
  -- RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred
  ---- ;; check call site
  -- if $callable_extern_method(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned_inferred* argumentIR*
                     : argumentIR_cast*

;;;; ExternAbstractMethodT parameterTypeIR* typeIR

dec $callable_extern_abstract_method(cursor, typingContext) : bool

def $callable_extern_abstract_method(GLOBAL, TC) = false
def $callable_extern_abstract_method(BLOCK, TC)
  = $is_parser_blockKind(TC.BLOCK.KIND)
    \/ $is_control_blockKind(TC.BLOCK.KIND)
def $callable_extern_abstract_method(LOCAL, TC) = true

rule Call_ok/extern-abstract-method:
  p TC |- (ExternAbstractMethodT parameterTypeIR* typeIR_ret)
            typeArgumentIR* tid_infer* argumentIR* id_default*
        : typeIR_ret_inferred typeArgumentIR_inferred* argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; perform type inference
  -- if inference = $infer(tid_infer*, parameterTypeIR_aligned*, argumentIR*)
  -- if (typeIR_inferred = $find_map<tid, typeIR>(inference, tid_infer))*
  -- if typeArgumentIR_inferred* = typeArgumentIR* ++ typeIR_inferred*
  ---- ;; substitute inferred types
  -- if (parameterTypeIR_aligned_inferred
        = $subst_parameterType(inference, parameterTypeIR_aligned))*
  -- if typeIR_ret_inferred
      = $subst_type(inference, typeIR_ret)
  ---- ;; check that the substituted method is still well-formed
  -- if methodTypeIR_inferred
      = ExternAbstractMethodT parameterTypeIR_aligned_inferred* typeIR_ret_inferred
  -- RoutineType_wf: $bound(p, TC) |- methodTypeIR_inferred
  ---- ;; check call site
  -- if $callable_extern_abstract_method(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned_inferred* argumentIR*
                     : argumentIR_cast*

;;;; ParserApplyMethodT parameterTypeIR*

dec $callable_parser_apply_method(cursor, typingContext) : bool

def $callable_parser_apply_method(GLOBAL, TC) = false
def $callable_parser_apply_method(BLOCK, TC) = false
def $callable_parser_apply_method(LOCAL, TC)
  = $is_parser_state_localKind(TC.LOCAL.KIND)

rule Call_ok/parser-apply-method:
  p TC |- (ParserApplyMethodT parameterTypeIR*) eps eps argumentIR* id_default*
        : VoidT eps argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; check call site
  -- if $callable_parser_apply_method(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned* argumentIR*
                     : argumentIR_cast*

;;;; ControlApplyMethodT parameterTypeIR*

dec $callable_control_apply_method(cursor, typingContext) : bool

def $callable_control_apply_method(GLOBAL, TC) = false
def $callable_control_apply_method(BLOCK, TC) = false
def $callable_control_apply_method(LOCAL, TC)
  = $is_control_apply_method_localKind(TC.LOCAL.KIND)

rule Call_ok/control-apply-method:
  p TC |- (ControlApplyMethodT parameterTypeIR*) eps eps argumentIR* id_default*
        : VoidT eps argumentIR_cast*
  ---- ;; filter default arguments
  -- if parameterTypeIR_non_default*
      = $filter_default_parameters(parameterTypeIR*, id_default*)
  ---- ;; check arity
  -- if $(|parameterTypeIR_non_default*| = |argumentIR*|)
  ---- ;; align parameters and arguments if named
  -- if parameterTypeIR_aligned*
      = $align_parameters(parameterTypeIR_non_default*, argumentIR*)
  ---- ;; check call site
  -- if $callable_control_apply_method(p, TC)
  ---- ;; check call convention
  -- Call_convention_ok:
      p TC NOACTION |- parameterTypeIR_aligned* argumentIR*
                     : argumentIR_cast*

;;;; TableApplyMethodT typeIR

dec $callable_table_apply_method(cursor, typingContext) : bool

def $callable_table_apply_method(GLOBAL, TC) = false
def $callable_table_apply_method(BLOCK, TC) = false
def $callable_table_apply_method(LOCAL, TC)
  = $is_control_apply_method_localKind(TC.LOCAL.KIND)
    \/ $is_table_apply_method_localKind(TC.LOCAL.KIND)

rule Call_ok/table-apply-method:
  p TC |- (TableApplyMethodT typeIR_table) eps eps eps eps
        : typeIR_table eps eps
  ---- ;; check call site
  -- if $callable_table_apply_method(p, TC)
