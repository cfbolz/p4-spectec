;;
;; Helpers
;;

;;; Filtering out default parameters

dec $filter_default_parameters(parameterTypeIR*, id*) : parameterTypeIR*

def $filter_default_parameters(eps, id_default*) = eps
def $filter_default_parameters(
    parameterTypeIR_h :: parameterTypeIR_t*,
    id_default*
  )
  = $filter_default_parameters(parameterTypeIR_t*, id_default*)
  -- if _ _ id_h _ = parameterTypeIR_h
  -- if id_h <- id_default*
def $filter_default_parameters(
    parameterTypeIR_h :: parameterTypeIR_t*,
    id_default*
  )
  = parameterTypeIR_h :: $filter_default_parameters(parameterTypeIR_t*, id_default*)
  -- if _ _ id_h _ = parameterTypeIR_h
  -- if ~(id_h <- id_default*)

;;; Aligning parameters if the arguments are named

dec $align_parameters(parameterTypeIR*, argumentIR*): parameterTypeIR*
dec $align_parameters'(map<id, parameterTypeIR>, parameterTypeIR, argumentIR): parameterTypeIR?

def $align_parameters(parameterTypeIR*, argumentIR*) = parameterTypeIR_aligned*
  -- if (_ _ id _ = parameterTypeIR)*
  -- (if parameterTypeIR_aligned
       = $align_parameters'(`{ (id -> parameterTypeIR)* }, parameterTypeIR, argumentIR))*

def $align_parameters'(_, parameterTypeIR, ExprA _)
  = parameterTypeIR
def $align_parameters'(`{ (id_param -> parameterTypeIR)* }, _, NameA name _)
  = $find_map<id, parameterTypeIR>(`{ (id_param -> parameterTypeIR)* }, name)
def $align_parameters'(`{ (id_param -> parameterTypeIR)* }, _, NameAnyA name)
  = $find_map<id, parameterTypeIR>(`{ (id_param -> parameterTypeIR)* }, name)
def $align_parameters'(_, parameterTypeIR, AnyA)
  = parameterTypeIR

;;
;; Calling convention (single argument)
;;

;; syntax direction

;;; IN

rule Call_convention_expr_ok/in:
  p TC actctxt |- (IN typeIR_param _ _) typedExpressionIR_arg
                : typedExpressionIR_arg_cast
  ---- ;; may insert implicit casts for direction in
  -- if typedExpressionIR_arg_cast
      = $coerce_unary(typedExpressionIR_arg, typeIR_param)

;;; OUT | INOUT

relation Expr_lvalue_ok:
  cursor typingContext |- typedExpressionIR
  hint(input %0 %1 %2)

rule Expr_lvalue_ok/nameE:
  p TC |- (NameE prefixedName) `( _ _ )
  -- if direction _ DYN _ = $find_var(p, TC, prefixedName)
  -- if direction = OUT \/ direction = INOUT

rule Expr_lvalue_ok/expraccE-stack:
  p TC |- (ExprAccE typedExpressionIR_base name) `( _ _ )
  -- Expr_lvalue_ok: p TC |- typedExpressionIR_base
  ---- ;; if the base expressionis a haeder stack
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  -- if HeaderStackT typeIR _ = $canon(typeIR_base)
  ---- ;; if accessing "next" or "last"
  -- if name = "next" \/ name = "last"
  ---- ;; "next" and "last" can be only used within a parser
  -- if (p = BLOCK /\ $is_parser_blockKind(TC.BLOCK.KIND))
        \/ (p = LOCAL /\ $is_parser_state_localKind(TC.LOCAL.KIND))

rule Expr_lvalue_ok/expraccE-non-stack:
  p TC |- (ExprAccE typedExpressionIR_base name) `( _ _ )
  -- Expr_lvalue_ok: p TC |- typedExpressionIR_base
  -- if _ `( typeIR_base _ ) = typedExpressionIR_base
  ---- ;; if the base expression is not a header stack
  -- if ~$is_headerStackTypeIR($canon(typeIR_base))

rule Expr_lvalue_ok/arraccE:
  p TC |- (ArrAccE typedExpressionIR_base typedExpressionIR_index) `( _ _ )
  -- Expr_lvalue_ok: p TC |- typedExpressionIR_base

rule Expr_lvalue_ok/bitaccE:
  p TC |- (BitAccE typedExpressionIR_base typedExpressionIR_hi
                                          typedExpressionIR_lo) `( _ _ )
  -- Expr_lvalue_ok: p TC |- typedExpressionIR_base

rule Call_convention_expr_ok/out-inout:
  p TC actctxt |- (direction typeIR_param _ _) typedExpressionIR_arg
                : typedExpressionIR_arg
  -- if direction = OUT \/ direction = INOUT
  ---- ;; may not insert implicit casts for direction out or inout
  -- if _ `( typeIR_arg _ ) = typedExpressionIR_arg
  -- Type_alpha: typeIR_param ~~ typeIR_arg
  ---- ;; for copy-out, the expression must be a l-value
  -- Expr_lvalue_ok: p TC |- typedExpressionIR_arg

;;; NO

rule Call_convention_expr_ok/no-action:
  p TC ACTION |- (NO typeIR_param _ _) typedExpressionIR_arg
               : typedExpressionIR_arg_cast
  ---- ;; insert implicit casts for directionless action argument
  -- if typedExpressionIR_arg_cast
      = $coerce_unary(typedExpressionIR_arg, typeIR_param) 
  
rule Call_convention_expr_ok/no-not-action:
  p TC NOACTION |- (NO typeIR_param _ _) typedExpressionIR_arg
                 : typedExpressionIR_arg_cast
  ---- ;; insert implicit casts for direction out or inout
  -- if typedExpressionIR_arg_cast
      = $coerce_unary(typedExpressionIR_arg, typeIR_param) 
  -- if _ `( _ ctk_arg_cast ) = typedExpressionIR_arg_cast
  ---- ;; the argument must be compile-time known
  -- if ctk_arg_cast =/= DYN

;; syntax argumentIR

;;; ExprA typedExpressionIR

rule Call_convention_argument_ok/exprA:
  p TC actctxt |- parameterTypeIR (ExprA typedExpressionIR)
                : ExprA typedExpressionIR_cast
  -- Call_convention_expr_ok:
      p TC actctxt |- parameterTypeIR typedExpressionIR
                    : typedExpressionIR_cast

;;; NameA name typedExpressionIR

rule Call_convention_argument_ok/name-typedExpression:
  p TC actctxt |- parameterTypeIR (NameA name typedExpressionIR)
                : NameA name typedExpressionIR_cast
  -- Call_convention_expr_ok:
      p TC actctxt |- parameterTypeIR typedExpressionIR
                    : typedExpressionIR_cast

;;; NameAnyA name

rule Call_convention_argument_ok/nameanyA:
  p TC actctxt |- parameterTypeIR (NameAnyA name)
                : NameAnyA name
  -- if OUT _ _ _ = parameterTypeIR

;;; AnyA

rule Call_convention_argument_ok/anyA:
  p TC actctxt |- parameterTypeIR AnyA : AnyA
  -- if OUT _ _ _ = parameterTypeIR

;;
;; Calling convention (multiple arguments)
;;

rule Call_convention_ok/nil:
  p TC actctxt |- eps eps : eps

rule Call_convention_ok/cons:
  p TC actctxt |- (parameterTypeIR_h :: parameterTypeIR_t*) (argumentIR_h :: argumentIR_t*)
                : (argumentIR_h_cast :: argumentIR_t_cast*)
  -- Call_convention_argument_ok:
      p TC actctxt |- parameterTypeIR_h argumentIR_h
                    : argumentIR_h_cast
  -- Call_convention_ok:
      p TC actctxt |- parameterTypeIR_t* argumentIR_t*
                    : argumentIR_t_cast*
