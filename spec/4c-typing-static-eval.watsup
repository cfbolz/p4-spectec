;;
;; Static evaluation of expressions that are local compile-time known
;;

;;
;; Value expression
;;

rule Eval_static/valuee:
  p C |- ValueE val _ ~> val

;;
;; Boolean expression
;;

rule Eval_static/boole:
  p C |- BoolE b _ ~> BoolV b

;;
;; String expression
;;

rule Eval_static/stre:
  p C |- StrE t _ ~> StrV t

;;
;; Number expression
;;

rule Eval_static/nume-intt:
  p C |- NumE (INT i) _ ~> IntV i

rule Eval_static/nume-fintt:
  p C |- NumE (FINT w i) _ ~> FIntV w bs
  -- if bs = $to_bitstr(w, i)

rule Eval_static/nume-fbitt:
  p C |- NumE (FBIT w i) _ ~> FBitV w bs
  -- if bs = $to_bitstr(w, i)

;;
;; Variable expression
;;

rule Eval_static/namee:
  p C |- NameE name _ ~> val
  -- if val = $find_val(p, C, name)

;;
;; Sequence expression
;;

rule Eval_static/seqe:
  p C |- SeqE exprIL* _ ~> SeqV val*
  -- (Eval_static: p C |- exprIL ~> val)*

rule Eval_static/seqdefaulte:
  p C |- SeqDefaultE exprIL* _ ~> SeqDefaultV val*
  -- (Eval_static: p C |- exprIL ~> val)*

;;
;; Record expression
;;

rule Eval_static/recorde:
  p C |- RecordE (member, exprIL)* _ ~> RecordV (member, val)*
  -- (Eval_static: p C |- exprIL ~> val)*

rule Eval_static/recorddefaulte:
  p C |- RecordDefaultE (member, exprIL)* _ ~> RecordDefaultV (member, val)*
  -- (Eval_static: p C |- exprIL ~> val)*

;;
;; Default expression
;;

rule Eval_static/defaulte:
  p C |- DefaultE _ ~> DefaultV

rule Eval_static/invalide:
  p C |- InvalidE _ ~> InvalidV

;;
;; Unary expression
;;

rule Eval_static/une:
  p C |- UnE unop exprIL _ ~> $un_op(unop, val)
  -- Eval_static: p C |- exprIL ~> val

;;
;; Binary expression
;;

rule Eval_static/bine:
  p C |- BinE binop exprIL_l exprIL_r _ ~> $bin_op(binop, val_l, val_r)
  -- Eval_static: p C |- exprIL_l ~> val_l
  -- Eval_static: p C |- exprIL_r ~> val_r

;;
;; Ternary expression
;;

rule Eval_static/terne-true:
  p C |- TernE exprIL_c exprIL_t exprIL_f _ ~> val
  -- Eval_static: p C |- exprIL_c ~> BoolV true
  -- Eval_static: p C |- exprIL_t ~> val

rule Eval_static/terne-false:
  p C |- TernE exprIL_c exprIL_t exprIL_f _ ~> val
  -- Eval_static: p C |- exprIL_c ~> BoolV false
  -- Eval_static: p C |- exprIL_f ~> val

;;
;; Cast expression
;;

rule Eval_static/caste:
  p C |- CastE typ exprIL _ ~> $cast_op(typ, val)
  -- Eval_static: p C |- exprIL ~> val

;;
;; Array access expression
;;

rule Eval_static/arracce-tuple:
  p C |- ArrAccE exprIL_b exprIL_i _ ~> val
  -- Eval_static: p C |- exprIL_b ~> TupleV val_e*
  -- Eval_static: p C |- exprIL_i ~> val_i
  -- if n_i = $get_num(val_i)
  -- if $(n_i < |val_e*|)
  -- if val = val_e*[n_i]

rule Eval_static/arracce-stack:
  p C |- ArrAccE exprIL_b exprIL_i _ ~> val
  -- Eval_static: p C |- exprIL_b ~> StackV val_e* _ _
  -- Eval_static: p C |- exprIL_i ~> val_i
  -- if n_i = $get_num(val_i)
  -- if $(n_i < |val_e*|)
  -- if val = val_e*[n_i] 

;;
;; Bitstring access expression
;;

rule Eval_static/bitacce:
  p C |- BitAccE exprIL_b exprIL_l exprIL_h _ ~> $bitacc_op(val_b, val_h, val_l)
  -- Eval_static: p C |- exprIL_b ~> val_b
  -- Eval_static: p C |- exprIL_l ~> val_l
  -- Eval_static: p C |- exprIL_h ~> val_h

;;
;; Error access expression
;;

rule Eval_static/erracce:
  p C |- ErrAccE member _ ~> ErrV member
  -- if id = $concat_text([ "error.", member ])
  -- if ErrV member = $find_val(p, C, TOP id)

;;
;; Type access expression
;;

rule Eval_static/typeacce-enumt:
  p C |- TypeAccE name member _ ~> EnumFieldV id_t member
  -- if MonoD typ = $find_typdef(p, C, name)
  -- if EnumT id_t member_t* = $canon_typ(typ)
  -- if member <- member_t*

rule Eval_static/typeacce-senumt:
  p C |- TypeAccE name member _ ~> SEnumFieldV id_t member val
  -- if MonoD typ = $find_typdef(p, C, name)
  -- if SEnumT id_t typ_t (member_t, val_t)* = $canon_typ(typ)
  -- if val = $assoc_<member, val>(member, (member_t, val_t)*)

;;
;; Expression access expression
;;

rule Eval_static/expracce-stack:
  p C |- ExprAccE exprIL_b "size" _ ~> IntV i_size
  -- Eval_static: p C |- exprIL_b ~> StackV val* i_size i_idx

rule Eval_static/expracce-struct:
  p C |- ExprAccE exprIL_b member _ ~> val
  -- Eval_static: p C |- exprIL_b ~> StructV id (member_f, val_f)*
  -- if val = $assoc_<member, val>(member, (member_f, val_f)*)

rule Eval_static/expracce-header:
  p C |- ExprAccE exprIL_b member _ ~> val
  -- Eval_static: p C |- exprIL_b ~> HeaderV id _ (member_f, val_f)*
  -- if val = $assoc_<member, val>(member, (member_f, val_f)*)

rule Eval_static/expracce-union:
  p C |- ExprAccE exprIL_b member _ ~> val
  -- Eval_static: p C |- exprIL_b ~> UnionV id (member_f, val_f)*
  -- if val = $assoc_<member, val>(member, (member_f, val_f)*)

;;
;; Method call expression
;;

rule Eval_static/callmethode:
  p C |- CallMethodE exprIL_b member eps eps _ ~> val
  -- if member = "minSizeInBits" \/ member = "minSizeInBytes"
        \/ member = "maxSizeInBits" \/ member = "maxSizeInBytes"
  -- if `(typ_b; _) = $annot(exprIL_b)
  -- if val = $size(typ_b, member)

;;
;; Type call expression
;;

rule Eval_static/calltypee:
  p C |- CallTypeE name member eps eps _ ~> $size(typ, member)
  -- if member = "minSizeInBits" \/ member = "minSizeInBytes"
        \/ member = "maxSizeInBits" \/ member = "maxSizeInBytes"
  -- if MonoD typ = $find_typdef(p, C, name)
